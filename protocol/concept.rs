/*
 * Copyright (C) 2021 Vaticle
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

// This file is generated by rust-protobuf 2.8.2. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `common/concept.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_2;

#[derive(PartialEq,Clone,Default)]
pub struct ConceptManager {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptManager {
    fn default() -> &'a ConceptManager {
        <ConceptManager as ::protobuf::Message>::default_instance()
    }
}

impl ConceptManager {
    pub fn new() -> ConceptManager {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ConceptManager {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptManager {
        ConceptManager::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ConceptManager>(
                    "ConceptManager",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConceptManager {
        static mut instance: ::protobuf::lazy::Lazy<ConceptManager> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConceptManager,
        };
        unsafe {
            instance.get(ConceptManager::new)
        }
    }
}

impl ::protobuf::Clear for ConceptManager {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptManager {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptManager {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptManager_Req {
    // message oneof groups
    pub req: ::std::option::Option<ConceptManager_Req_oneof_req>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptManager_Req {
    fn default() -> &'a ConceptManager_Req {
        <ConceptManager_Req as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ConceptManager_Req_oneof_req {
    get_thing_type_req(ConceptManager_GetThingType_Req),
    get_thing_req(ConceptManager_GetThing_Req),
    put_entity_type_req(ConceptManager_PutEntityType_Req),
    put_attribute_type_req(ConceptManager_PutAttributeType_Req),
    put_relation_type_req(ConceptManager_PutRelationType_Req),
}

impl ConceptManager_Req {
    pub fn new() -> ConceptManager_Req {
        ::std::default::Default::default()
    }

    // .typedb.protocol.ConceptManager.GetThingType.Req get_thing_type_req = 1;


    pub fn get_get_thing_type_req(&self) -> &ConceptManager_GetThingType_Req {
        match self.req {
            ::std::option::Option::Some(ConceptManager_Req_oneof_req::get_thing_type_req(ref v)) => v,
            _ => ConceptManager_GetThingType_Req::default_instance(),
        }
    }
    pub fn clear_get_thing_type_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_get_thing_type_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(ConceptManager_Req_oneof_req::get_thing_type_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_thing_type_req(&mut self, v: ConceptManager_GetThingType_Req) {
        self.req = ::std::option::Option::Some(ConceptManager_Req_oneof_req::get_thing_type_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_thing_type_req(&mut self) -> &mut ConceptManager_GetThingType_Req {
        if let ::std::option::Option::Some(ConceptManager_Req_oneof_req::get_thing_type_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(ConceptManager_Req_oneof_req::get_thing_type_req(ConceptManager_GetThingType_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(ConceptManager_Req_oneof_req::get_thing_type_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_thing_type_req(&mut self) -> ConceptManager_GetThingType_Req {
        if self.has_get_thing_type_req() {
            match self.req.take() {
                ::std::option::Option::Some(ConceptManager_Req_oneof_req::get_thing_type_req(v)) => v,
                _ => panic!(),
            }
        } else {
            ConceptManager_GetThingType_Req::new()
        }
    }

    // .typedb.protocol.ConceptManager.GetThing.Req get_thing_req = 2;


    pub fn get_get_thing_req(&self) -> &ConceptManager_GetThing_Req {
        match self.req {
            ::std::option::Option::Some(ConceptManager_Req_oneof_req::get_thing_req(ref v)) => v,
            _ => ConceptManager_GetThing_Req::default_instance(),
        }
    }
    pub fn clear_get_thing_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_get_thing_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(ConceptManager_Req_oneof_req::get_thing_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_thing_req(&mut self, v: ConceptManager_GetThing_Req) {
        self.req = ::std::option::Option::Some(ConceptManager_Req_oneof_req::get_thing_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_thing_req(&mut self) -> &mut ConceptManager_GetThing_Req {
        if let ::std::option::Option::Some(ConceptManager_Req_oneof_req::get_thing_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(ConceptManager_Req_oneof_req::get_thing_req(ConceptManager_GetThing_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(ConceptManager_Req_oneof_req::get_thing_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_thing_req(&mut self) -> ConceptManager_GetThing_Req {
        if self.has_get_thing_req() {
            match self.req.take() {
                ::std::option::Option::Some(ConceptManager_Req_oneof_req::get_thing_req(v)) => v,
                _ => panic!(),
            }
        } else {
            ConceptManager_GetThing_Req::new()
        }
    }

    // .typedb.protocol.ConceptManager.PutEntityType.Req put_entity_type_req = 3;


    pub fn get_put_entity_type_req(&self) -> &ConceptManager_PutEntityType_Req {
        match self.req {
            ::std::option::Option::Some(ConceptManager_Req_oneof_req::put_entity_type_req(ref v)) => v,
            _ => ConceptManager_PutEntityType_Req::default_instance(),
        }
    }
    pub fn clear_put_entity_type_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_put_entity_type_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(ConceptManager_Req_oneof_req::put_entity_type_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_put_entity_type_req(&mut self, v: ConceptManager_PutEntityType_Req) {
        self.req = ::std::option::Option::Some(ConceptManager_Req_oneof_req::put_entity_type_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_put_entity_type_req(&mut self) -> &mut ConceptManager_PutEntityType_Req {
        if let ::std::option::Option::Some(ConceptManager_Req_oneof_req::put_entity_type_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(ConceptManager_Req_oneof_req::put_entity_type_req(ConceptManager_PutEntityType_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(ConceptManager_Req_oneof_req::put_entity_type_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_put_entity_type_req(&mut self) -> ConceptManager_PutEntityType_Req {
        if self.has_put_entity_type_req() {
            match self.req.take() {
                ::std::option::Option::Some(ConceptManager_Req_oneof_req::put_entity_type_req(v)) => v,
                _ => panic!(),
            }
        } else {
            ConceptManager_PutEntityType_Req::new()
        }
    }

    // .typedb.protocol.ConceptManager.PutAttributeType.Req put_attribute_type_req = 4;


    pub fn get_put_attribute_type_req(&self) -> &ConceptManager_PutAttributeType_Req {
        match self.req {
            ::std::option::Option::Some(ConceptManager_Req_oneof_req::put_attribute_type_req(ref v)) => v,
            _ => ConceptManager_PutAttributeType_Req::default_instance(),
        }
    }
    pub fn clear_put_attribute_type_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_put_attribute_type_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(ConceptManager_Req_oneof_req::put_attribute_type_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_put_attribute_type_req(&mut self, v: ConceptManager_PutAttributeType_Req) {
        self.req = ::std::option::Option::Some(ConceptManager_Req_oneof_req::put_attribute_type_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_put_attribute_type_req(&mut self) -> &mut ConceptManager_PutAttributeType_Req {
        if let ::std::option::Option::Some(ConceptManager_Req_oneof_req::put_attribute_type_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(ConceptManager_Req_oneof_req::put_attribute_type_req(ConceptManager_PutAttributeType_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(ConceptManager_Req_oneof_req::put_attribute_type_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_put_attribute_type_req(&mut self) -> ConceptManager_PutAttributeType_Req {
        if self.has_put_attribute_type_req() {
            match self.req.take() {
                ::std::option::Option::Some(ConceptManager_Req_oneof_req::put_attribute_type_req(v)) => v,
                _ => panic!(),
            }
        } else {
            ConceptManager_PutAttributeType_Req::new()
        }
    }

    // .typedb.protocol.ConceptManager.PutRelationType.Req put_relation_type_req = 5;


    pub fn get_put_relation_type_req(&self) -> &ConceptManager_PutRelationType_Req {
        match self.req {
            ::std::option::Option::Some(ConceptManager_Req_oneof_req::put_relation_type_req(ref v)) => v,
            _ => ConceptManager_PutRelationType_Req::default_instance(),
        }
    }
    pub fn clear_put_relation_type_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_put_relation_type_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(ConceptManager_Req_oneof_req::put_relation_type_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_put_relation_type_req(&mut self, v: ConceptManager_PutRelationType_Req) {
        self.req = ::std::option::Option::Some(ConceptManager_Req_oneof_req::put_relation_type_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_put_relation_type_req(&mut self) -> &mut ConceptManager_PutRelationType_Req {
        if let ::std::option::Option::Some(ConceptManager_Req_oneof_req::put_relation_type_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(ConceptManager_Req_oneof_req::put_relation_type_req(ConceptManager_PutRelationType_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(ConceptManager_Req_oneof_req::put_relation_type_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_put_relation_type_req(&mut self) -> ConceptManager_PutRelationType_Req {
        if self.has_put_relation_type_req() {
            match self.req.take() {
                ::std::option::Option::Some(ConceptManager_Req_oneof_req::put_relation_type_req(v)) => v,
                _ => panic!(),
            }
        } else {
            ConceptManager_PutRelationType_Req::new()
        }
    }
}

impl ::protobuf::Message for ConceptManager_Req {
    fn is_initialized(&self) -> bool {
        if let Some(ConceptManager_Req_oneof_req::get_thing_type_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConceptManager_Req_oneof_req::get_thing_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConceptManager_Req_oneof_req::put_entity_type_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConceptManager_Req_oneof_req::put_attribute_type_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConceptManager_Req_oneof_req::put_relation_type_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(ConceptManager_Req_oneof_req::get_thing_type_req(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(ConceptManager_Req_oneof_req::get_thing_req(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(ConceptManager_Req_oneof_req::put_entity_type_req(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(ConceptManager_Req_oneof_req::put_attribute_type_req(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(ConceptManager_Req_oneof_req::put_relation_type_req(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.req {
            match v {
                &ConceptManager_Req_oneof_req::get_thing_type_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConceptManager_Req_oneof_req::get_thing_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConceptManager_Req_oneof_req::put_entity_type_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConceptManager_Req_oneof_req::put_attribute_type_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConceptManager_Req_oneof_req::put_relation_type_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.req {
            match v {
                &ConceptManager_Req_oneof_req::get_thing_type_req(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConceptManager_Req_oneof_req::get_thing_req(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConceptManager_Req_oneof_req::put_entity_type_req(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConceptManager_Req_oneof_req::put_attribute_type_req(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConceptManager_Req_oneof_req::put_relation_type_req(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptManager_Req {
        ConceptManager_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConceptManager_GetThingType_Req>(
                    "get_thing_type_req",
                    ConceptManager_Req::has_get_thing_type_req,
                    ConceptManager_Req::get_get_thing_type_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConceptManager_GetThing_Req>(
                    "get_thing_req",
                    ConceptManager_Req::has_get_thing_req,
                    ConceptManager_Req::get_get_thing_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConceptManager_PutEntityType_Req>(
                    "put_entity_type_req",
                    ConceptManager_Req::has_put_entity_type_req,
                    ConceptManager_Req::get_put_entity_type_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConceptManager_PutAttributeType_Req>(
                    "put_attribute_type_req",
                    ConceptManager_Req::has_put_attribute_type_req,
                    ConceptManager_Req::get_put_attribute_type_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConceptManager_PutRelationType_Req>(
                    "put_relation_type_req",
                    ConceptManager_Req::has_put_relation_type_req,
                    ConceptManager_Req::get_put_relation_type_req,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConceptManager_Req>(
                    "ConceptManager_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConceptManager_Req {
        static mut instance: ::protobuf::lazy::Lazy<ConceptManager_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConceptManager_Req,
        };
        unsafe {
            instance.get(ConceptManager_Req::new)
        }
    }
}

impl ::protobuf::Clear for ConceptManager_Req {
    fn clear(&mut self) {
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptManager_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptManager_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptManager_Res {
    // message oneof groups
    pub res: ::std::option::Option<ConceptManager_Res_oneof_res>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptManager_Res {
    fn default() -> &'a ConceptManager_Res {
        <ConceptManager_Res as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ConceptManager_Res_oneof_res {
    get_thing_type_res(ConceptManager_GetThingType_Res),
    get_thing_res(ConceptManager_GetThing_Res),
    put_entity_type_res(ConceptManager_PutEntityType_Res),
    put_attribute_type_res(ConceptManager_PutAttributeType_Res),
    put_relation_type_res(ConceptManager_PutRelationType_Res),
}

impl ConceptManager_Res {
    pub fn new() -> ConceptManager_Res {
        ::std::default::Default::default()
    }

    // .typedb.protocol.ConceptManager.GetThingType.Res get_thing_type_res = 1;


    pub fn get_get_thing_type_res(&self) -> &ConceptManager_GetThingType_Res {
        match self.res {
            ::std::option::Option::Some(ConceptManager_Res_oneof_res::get_thing_type_res(ref v)) => v,
            _ => ConceptManager_GetThingType_Res::default_instance(),
        }
    }
    pub fn clear_get_thing_type_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_get_thing_type_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(ConceptManager_Res_oneof_res::get_thing_type_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_thing_type_res(&mut self, v: ConceptManager_GetThingType_Res) {
        self.res = ::std::option::Option::Some(ConceptManager_Res_oneof_res::get_thing_type_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_thing_type_res(&mut self) -> &mut ConceptManager_GetThingType_Res {
        if let ::std::option::Option::Some(ConceptManager_Res_oneof_res::get_thing_type_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(ConceptManager_Res_oneof_res::get_thing_type_res(ConceptManager_GetThingType_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(ConceptManager_Res_oneof_res::get_thing_type_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_thing_type_res(&mut self) -> ConceptManager_GetThingType_Res {
        if self.has_get_thing_type_res() {
            match self.res.take() {
                ::std::option::Option::Some(ConceptManager_Res_oneof_res::get_thing_type_res(v)) => v,
                _ => panic!(),
            }
        } else {
            ConceptManager_GetThingType_Res::new()
        }
    }

    // .typedb.protocol.ConceptManager.GetThing.Res get_thing_res = 2;


    pub fn get_get_thing_res(&self) -> &ConceptManager_GetThing_Res {
        match self.res {
            ::std::option::Option::Some(ConceptManager_Res_oneof_res::get_thing_res(ref v)) => v,
            _ => ConceptManager_GetThing_Res::default_instance(),
        }
    }
    pub fn clear_get_thing_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_get_thing_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(ConceptManager_Res_oneof_res::get_thing_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_thing_res(&mut self, v: ConceptManager_GetThing_Res) {
        self.res = ::std::option::Option::Some(ConceptManager_Res_oneof_res::get_thing_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_thing_res(&mut self) -> &mut ConceptManager_GetThing_Res {
        if let ::std::option::Option::Some(ConceptManager_Res_oneof_res::get_thing_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(ConceptManager_Res_oneof_res::get_thing_res(ConceptManager_GetThing_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(ConceptManager_Res_oneof_res::get_thing_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_thing_res(&mut self) -> ConceptManager_GetThing_Res {
        if self.has_get_thing_res() {
            match self.res.take() {
                ::std::option::Option::Some(ConceptManager_Res_oneof_res::get_thing_res(v)) => v,
                _ => panic!(),
            }
        } else {
            ConceptManager_GetThing_Res::new()
        }
    }

    // .typedb.protocol.ConceptManager.PutEntityType.Res put_entity_type_res = 3;


    pub fn get_put_entity_type_res(&self) -> &ConceptManager_PutEntityType_Res {
        match self.res {
            ::std::option::Option::Some(ConceptManager_Res_oneof_res::put_entity_type_res(ref v)) => v,
            _ => ConceptManager_PutEntityType_Res::default_instance(),
        }
    }
    pub fn clear_put_entity_type_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_put_entity_type_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(ConceptManager_Res_oneof_res::put_entity_type_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_put_entity_type_res(&mut self, v: ConceptManager_PutEntityType_Res) {
        self.res = ::std::option::Option::Some(ConceptManager_Res_oneof_res::put_entity_type_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_put_entity_type_res(&mut self) -> &mut ConceptManager_PutEntityType_Res {
        if let ::std::option::Option::Some(ConceptManager_Res_oneof_res::put_entity_type_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(ConceptManager_Res_oneof_res::put_entity_type_res(ConceptManager_PutEntityType_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(ConceptManager_Res_oneof_res::put_entity_type_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_put_entity_type_res(&mut self) -> ConceptManager_PutEntityType_Res {
        if self.has_put_entity_type_res() {
            match self.res.take() {
                ::std::option::Option::Some(ConceptManager_Res_oneof_res::put_entity_type_res(v)) => v,
                _ => panic!(),
            }
        } else {
            ConceptManager_PutEntityType_Res::new()
        }
    }

    // .typedb.protocol.ConceptManager.PutAttributeType.Res put_attribute_type_res = 4;


    pub fn get_put_attribute_type_res(&self) -> &ConceptManager_PutAttributeType_Res {
        match self.res {
            ::std::option::Option::Some(ConceptManager_Res_oneof_res::put_attribute_type_res(ref v)) => v,
            _ => ConceptManager_PutAttributeType_Res::default_instance(),
        }
    }
    pub fn clear_put_attribute_type_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_put_attribute_type_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(ConceptManager_Res_oneof_res::put_attribute_type_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_put_attribute_type_res(&mut self, v: ConceptManager_PutAttributeType_Res) {
        self.res = ::std::option::Option::Some(ConceptManager_Res_oneof_res::put_attribute_type_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_put_attribute_type_res(&mut self) -> &mut ConceptManager_PutAttributeType_Res {
        if let ::std::option::Option::Some(ConceptManager_Res_oneof_res::put_attribute_type_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(ConceptManager_Res_oneof_res::put_attribute_type_res(ConceptManager_PutAttributeType_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(ConceptManager_Res_oneof_res::put_attribute_type_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_put_attribute_type_res(&mut self) -> ConceptManager_PutAttributeType_Res {
        if self.has_put_attribute_type_res() {
            match self.res.take() {
                ::std::option::Option::Some(ConceptManager_Res_oneof_res::put_attribute_type_res(v)) => v,
                _ => panic!(),
            }
        } else {
            ConceptManager_PutAttributeType_Res::new()
        }
    }

    // .typedb.protocol.ConceptManager.PutRelationType.Res put_relation_type_res = 5;


    pub fn get_put_relation_type_res(&self) -> &ConceptManager_PutRelationType_Res {
        match self.res {
            ::std::option::Option::Some(ConceptManager_Res_oneof_res::put_relation_type_res(ref v)) => v,
            _ => ConceptManager_PutRelationType_Res::default_instance(),
        }
    }
    pub fn clear_put_relation_type_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_put_relation_type_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(ConceptManager_Res_oneof_res::put_relation_type_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_put_relation_type_res(&mut self, v: ConceptManager_PutRelationType_Res) {
        self.res = ::std::option::Option::Some(ConceptManager_Res_oneof_res::put_relation_type_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_put_relation_type_res(&mut self) -> &mut ConceptManager_PutRelationType_Res {
        if let ::std::option::Option::Some(ConceptManager_Res_oneof_res::put_relation_type_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(ConceptManager_Res_oneof_res::put_relation_type_res(ConceptManager_PutRelationType_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(ConceptManager_Res_oneof_res::put_relation_type_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_put_relation_type_res(&mut self) -> ConceptManager_PutRelationType_Res {
        if self.has_put_relation_type_res() {
            match self.res.take() {
                ::std::option::Option::Some(ConceptManager_Res_oneof_res::put_relation_type_res(v)) => v,
                _ => panic!(),
            }
        } else {
            ConceptManager_PutRelationType_Res::new()
        }
    }
}

impl ::protobuf::Message for ConceptManager_Res {
    fn is_initialized(&self) -> bool {
        if let Some(ConceptManager_Res_oneof_res::get_thing_type_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConceptManager_Res_oneof_res::get_thing_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConceptManager_Res_oneof_res::put_entity_type_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConceptManager_Res_oneof_res::put_attribute_type_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConceptManager_Res_oneof_res::put_relation_type_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(ConceptManager_Res_oneof_res::get_thing_type_res(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(ConceptManager_Res_oneof_res::get_thing_res(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(ConceptManager_Res_oneof_res::put_entity_type_res(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(ConceptManager_Res_oneof_res::put_attribute_type_res(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(ConceptManager_Res_oneof_res::put_relation_type_res(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &ConceptManager_Res_oneof_res::get_thing_type_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConceptManager_Res_oneof_res::get_thing_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConceptManager_Res_oneof_res::put_entity_type_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConceptManager_Res_oneof_res::put_attribute_type_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConceptManager_Res_oneof_res::put_relation_type_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &ConceptManager_Res_oneof_res::get_thing_type_res(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConceptManager_Res_oneof_res::get_thing_res(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConceptManager_Res_oneof_res::put_entity_type_res(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConceptManager_Res_oneof_res::put_attribute_type_res(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConceptManager_Res_oneof_res::put_relation_type_res(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptManager_Res {
        ConceptManager_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConceptManager_GetThingType_Res>(
                    "get_thing_type_res",
                    ConceptManager_Res::has_get_thing_type_res,
                    ConceptManager_Res::get_get_thing_type_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConceptManager_GetThing_Res>(
                    "get_thing_res",
                    ConceptManager_Res::has_get_thing_res,
                    ConceptManager_Res::get_get_thing_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConceptManager_PutEntityType_Res>(
                    "put_entity_type_res",
                    ConceptManager_Res::has_put_entity_type_res,
                    ConceptManager_Res::get_put_entity_type_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConceptManager_PutAttributeType_Res>(
                    "put_attribute_type_res",
                    ConceptManager_Res::has_put_attribute_type_res,
                    ConceptManager_Res::get_put_attribute_type_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConceptManager_PutRelationType_Res>(
                    "put_relation_type_res",
                    ConceptManager_Res::has_put_relation_type_res,
                    ConceptManager_Res::get_put_relation_type_res,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConceptManager_Res>(
                    "ConceptManager_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConceptManager_Res {
        static mut instance: ::protobuf::lazy::Lazy<ConceptManager_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConceptManager_Res,
        };
        unsafe {
            instance.get(ConceptManager_Res::new)
        }
    }
}

impl ::protobuf::Clear for ConceptManager_Res {
    fn clear(&mut self) {
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptManager_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptManager_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptManager_GetThingType {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptManager_GetThingType {
    fn default() -> &'a ConceptManager_GetThingType {
        <ConceptManager_GetThingType as ::protobuf::Message>::default_instance()
    }
}

impl ConceptManager_GetThingType {
    pub fn new() -> ConceptManager_GetThingType {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ConceptManager_GetThingType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptManager_GetThingType {
        ConceptManager_GetThingType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ConceptManager_GetThingType>(
                    "ConceptManager_GetThingType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConceptManager_GetThingType {
        static mut instance: ::protobuf::lazy::Lazy<ConceptManager_GetThingType> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConceptManager_GetThingType,
        };
        unsafe {
            instance.get(ConceptManager_GetThingType::new)
        }
    }
}

impl ::protobuf::Clear for ConceptManager_GetThingType {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptManager_GetThingType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptManager_GetThingType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptManager_GetThingType_Req {
    // message fields
    pub label: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptManager_GetThingType_Req {
    fn default() -> &'a ConceptManager_GetThingType_Req {
        <ConceptManager_GetThingType_Req as ::protobuf::Message>::default_instance()
    }
}

impl ConceptManager_GetThingType_Req {
    pub fn new() -> ConceptManager_GetThingType_Req {
        ::std::default::Default::default()
    }

    // string label = 1;


    pub fn get_label(&self) -> &str {
        &self.label
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        &mut self.label
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ConceptManager_GetThingType_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.label);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.label.is_empty() {
            os.write_string(1, &self.label)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptManager_GetThingType_Req {
        ConceptManager_GetThingType_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "label",
                    |m: &ConceptManager_GetThingType_Req| { &m.label },
                    |m: &mut ConceptManager_GetThingType_Req| { &mut m.label },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConceptManager_GetThingType_Req>(
                    "ConceptManager_GetThingType_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConceptManager_GetThingType_Req {
        static mut instance: ::protobuf::lazy::Lazy<ConceptManager_GetThingType_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConceptManager_GetThingType_Req,
        };
        unsafe {
            instance.get(ConceptManager_GetThingType_Req::new)
        }
    }
}

impl ::protobuf::Clear for ConceptManager_GetThingType_Req {
    fn clear(&mut self) {
        self.label.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptManager_GetThingType_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptManager_GetThingType_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptManager_GetThingType_Res {
    // message oneof groups
    pub res: ::std::option::Option<ConceptManager_GetThingType_Res_oneof_res>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptManager_GetThingType_Res {
    fn default() -> &'a ConceptManager_GetThingType_Res {
        <ConceptManager_GetThingType_Res as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ConceptManager_GetThingType_Res_oneof_res {
    thing_type(Type),
}

impl ConceptManager_GetThingType_Res {
    pub fn new() -> ConceptManager_GetThingType_Res {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Type thing_type = 1;


    pub fn get_thing_type(&self) -> &Type {
        match self.res {
            ::std::option::Option::Some(ConceptManager_GetThingType_Res_oneof_res::thing_type(ref v)) => v,
            _ => Type::default_instance(),
        }
    }
    pub fn clear_thing_type(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_thing_type(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(ConceptManager_GetThingType_Res_oneof_res::thing_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_type(&mut self, v: Type) {
        self.res = ::std::option::Option::Some(ConceptManager_GetThingType_Res_oneof_res::thing_type(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_type(&mut self) -> &mut Type {
        if let ::std::option::Option::Some(ConceptManager_GetThingType_Res_oneof_res::thing_type(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(ConceptManager_GetThingType_Res_oneof_res::thing_type(Type::new()));
        }
        match self.res {
            ::std::option::Option::Some(ConceptManager_GetThingType_Res_oneof_res::thing_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_type(&mut self) -> Type {
        if self.has_thing_type() {
            match self.res.take() {
                ::std::option::Option::Some(ConceptManager_GetThingType_Res_oneof_res::thing_type(v)) => v,
                _ => panic!(),
            }
        } else {
            Type::new()
        }
    }
}

impl ::protobuf::Message for ConceptManager_GetThingType_Res {
    fn is_initialized(&self) -> bool {
        if let Some(ConceptManager_GetThingType_Res_oneof_res::thing_type(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(ConceptManager_GetThingType_Res_oneof_res::thing_type(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &ConceptManager_GetThingType_Res_oneof_res::thing_type(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &ConceptManager_GetThingType_Res_oneof_res::thing_type(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptManager_GetThingType_Res {
        ConceptManager_GetThingType_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type>(
                    "thing_type",
                    ConceptManager_GetThingType_Res::has_thing_type,
                    ConceptManager_GetThingType_Res::get_thing_type,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConceptManager_GetThingType_Res>(
                    "ConceptManager_GetThingType_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConceptManager_GetThingType_Res {
        static mut instance: ::protobuf::lazy::Lazy<ConceptManager_GetThingType_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConceptManager_GetThingType_Res,
        };
        unsafe {
            instance.get(ConceptManager_GetThingType_Res::new)
        }
    }
}

impl ::protobuf::Clear for ConceptManager_GetThingType_Res {
    fn clear(&mut self) {
        self.res = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptManager_GetThingType_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptManager_GetThingType_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptManager_GetThing {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptManager_GetThing {
    fn default() -> &'a ConceptManager_GetThing {
        <ConceptManager_GetThing as ::protobuf::Message>::default_instance()
    }
}

impl ConceptManager_GetThing {
    pub fn new() -> ConceptManager_GetThing {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ConceptManager_GetThing {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptManager_GetThing {
        ConceptManager_GetThing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ConceptManager_GetThing>(
                    "ConceptManager_GetThing",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConceptManager_GetThing {
        static mut instance: ::protobuf::lazy::Lazy<ConceptManager_GetThing> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConceptManager_GetThing,
        };
        unsafe {
            instance.get(ConceptManager_GetThing::new)
        }
    }
}

impl ::protobuf::Clear for ConceptManager_GetThing {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptManager_GetThing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptManager_GetThing {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptManager_GetThing_Req {
    // message fields
    pub iid: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptManager_GetThing_Req {
    fn default() -> &'a ConceptManager_GetThing_Req {
        <ConceptManager_GetThing_Req as ::protobuf::Message>::default_instance()
    }
}

impl ConceptManager_GetThing_Req {
    pub fn new() -> ConceptManager_GetThing_Req {
        ::std::default::Default::default()
    }

    // bytes iid = 1;


    pub fn get_iid(&self) -> &[u8] {
        &self.iid
    }
    pub fn clear_iid(&mut self) {
        self.iid.clear();
    }

    // Param is passed by value, moved
    pub fn set_iid(&mut self, v: ::std::vec::Vec<u8>) {
        self.iid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.iid
    }

    // Take field
    pub fn take_iid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.iid, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ConceptManager_GetThing_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.iid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.iid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.iid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.iid.is_empty() {
            os.write_bytes(1, &self.iid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptManager_GetThing_Req {
        ConceptManager_GetThing_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "iid",
                    |m: &ConceptManager_GetThing_Req| { &m.iid },
                    |m: &mut ConceptManager_GetThing_Req| { &mut m.iid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConceptManager_GetThing_Req>(
                    "ConceptManager_GetThing_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConceptManager_GetThing_Req {
        static mut instance: ::protobuf::lazy::Lazy<ConceptManager_GetThing_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConceptManager_GetThing_Req,
        };
        unsafe {
            instance.get(ConceptManager_GetThing_Req::new)
        }
    }
}

impl ::protobuf::Clear for ConceptManager_GetThing_Req {
    fn clear(&mut self) {
        self.iid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptManager_GetThing_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptManager_GetThing_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptManager_GetThing_Res {
    // message oneof groups
    pub res: ::std::option::Option<ConceptManager_GetThing_Res_oneof_res>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptManager_GetThing_Res {
    fn default() -> &'a ConceptManager_GetThing_Res {
        <ConceptManager_GetThing_Res as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ConceptManager_GetThing_Res_oneof_res {
    thing(Thing),
}

impl ConceptManager_GetThing_Res {
    pub fn new() -> ConceptManager_GetThing_Res {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Thing thing = 1;


    pub fn get_thing(&self) -> &Thing {
        match self.res {
            ::std::option::Option::Some(ConceptManager_GetThing_Res_oneof_res::thing(ref v)) => v,
            _ => Thing::default_instance(),
        }
    }
    pub fn clear_thing(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_thing(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(ConceptManager_GetThing_Res_oneof_res::thing(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing(&mut self, v: Thing) {
        self.res = ::std::option::Option::Some(ConceptManager_GetThing_Res_oneof_res::thing(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing(&mut self) -> &mut Thing {
        if let ::std::option::Option::Some(ConceptManager_GetThing_Res_oneof_res::thing(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(ConceptManager_GetThing_Res_oneof_res::thing(Thing::new()));
        }
        match self.res {
            ::std::option::Option::Some(ConceptManager_GetThing_Res_oneof_res::thing(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing(&mut self) -> Thing {
        if self.has_thing() {
            match self.res.take() {
                ::std::option::Option::Some(ConceptManager_GetThing_Res_oneof_res::thing(v)) => v,
                _ => panic!(),
            }
        } else {
            Thing::new()
        }
    }
}

impl ::protobuf::Message for ConceptManager_GetThing_Res {
    fn is_initialized(&self) -> bool {
        if let Some(ConceptManager_GetThing_Res_oneof_res::thing(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(ConceptManager_GetThing_Res_oneof_res::thing(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &ConceptManager_GetThing_Res_oneof_res::thing(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &ConceptManager_GetThing_Res_oneof_res::thing(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptManager_GetThing_Res {
        ConceptManager_GetThing_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Thing>(
                    "thing",
                    ConceptManager_GetThing_Res::has_thing,
                    ConceptManager_GetThing_Res::get_thing,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConceptManager_GetThing_Res>(
                    "ConceptManager_GetThing_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConceptManager_GetThing_Res {
        static mut instance: ::protobuf::lazy::Lazy<ConceptManager_GetThing_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConceptManager_GetThing_Res,
        };
        unsafe {
            instance.get(ConceptManager_GetThing_Res::new)
        }
    }
}

impl ::protobuf::Clear for ConceptManager_GetThing_Res {
    fn clear(&mut self) {
        self.res = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptManager_GetThing_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptManager_GetThing_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptManager_PutEntityType {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptManager_PutEntityType {
    fn default() -> &'a ConceptManager_PutEntityType {
        <ConceptManager_PutEntityType as ::protobuf::Message>::default_instance()
    }
}

impl ConceptManager_PutEntityType {
    pub fn new() -> ConceptManager_PutEntityType {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ConceptManager_PutEntityType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptManager_PutEntityType {
        ConceptManager_PutEntityType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ConceptManager_PutEntityType>(
                    "ConceptManager_PutEntityType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConceptManager_PutEntityType {
        static mut instance: ::protobuf::lazy::Lazy<ConceptManager_PutEntityType> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConceptManager_PutEntityType,
        };
        unsafe {
            instance.get(ConceptManager_PutEntityType::new)
        }
    }
}

impl ::protobuf::Clear for ConceptManager_PutEntityType {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptManager_PutEntityType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptManager_PutEntityType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptManager_PutEntityType_Req {
    // message fields
    pub label: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptManager_PutEntityType_Req {
    fn default() -> &'a ConceptManager_PutEntityType_Req {
        <ConceptManager_PutEntityType_Req as ::protobuf::Message>::default_instance()
    }
}

impl ConceptManager_PutEntityType_Req {
    pub fn new() -> ConceptManager_PutEntityType_Req {
        ::std::default::Default::default()
    }

    // string label = 1;


    pub fn get_label(&self) -> &str {
        &self.label
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        &mut self.label
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ConceptManager_PutEntityType_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.label);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.label.is_empty() {
            os.write_string(1, &self.label)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptManager_PutEntityType_Req {
        ConceptManager_PutEntityType_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "label",
                    |m: &ConceptManager_PutEntityType_Req| { &m.label },
                    |m: &mut ConceptManager_PutEntityType_Req| { &mut m.label },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConceptManager_PutEntityType_Req>(
                    "ConceptManager_PutEntityType_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConceptManager_PutEntityType_Req {
        static mut instance: ::protobuf::lazy::Lazy<ConceptManager_PutEntityType_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConceptManager_PutEntityType_Req,
        };
        unsafe {
            instance.get(ConceptManager_PutEntityType_Req::new)
        }
    }
}

impl ::protobuf::Clear for ConceptManager_PutEntityType_Req {
    fn clear(&mut self) {
        self.label.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptManager_PutEntityType_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptManager_PutEntityType_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptManager_PutEntityType_Res {
    // message fields
    pub entity_type: ::protobuf::SingularPtrField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptManager_PutEntityType_Res {
    fn default() -> &'a ConceptManager_PutEntityType_Res {
        <ConceptManager_PutEntityType_Res as ::protobuf::Message>::default_instance()
    }
}

impl ConceptManager_PutEntityType_Res {
    pub fn new() -> ConceptManager_PutEntityType_Res {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Type entity_type = 1;


    pub fn get_entity_type(&self) -> &Type {
        self.entity_type.as_ref().unwrap_or_else(|| Type::default_instance())
    }
    pub fn clear_entity_type(&mut self) {
        self.entity_type.clear();
    }

    pub fn has_entity_type(&self) -> bool {
        self.entity_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_type(&mut self, v: Type) {
        self.entity_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_type(&mut self) -> &mut Type {
        if self.entity_type.is_none() {
            self.entity_type.set_default();
        }
        self.entity_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_entity_type(&mut self) -> Type {
        self.entity_type.take().unwrap_or_else(|| Type::new())
    }
}

impl ::protobuf::Message for ConceptManager_PutEntityType_Res {
    fn is_initialized(&self) -> bool {
        for v in &self.entity_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.entity_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.entity_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.entity_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptManager_PutEntityType_Res {
        ConceptManager_PutEntityType_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "entity_type",
                    |m: &ConceptManager_PutEntityType_Res| { &m.entity_type },
                    |m: &mut ConceptManager_PutEntityType_Res| { &mut m.entity_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConceptManager_PutEntityType_Res>(
                    "ConceptManager_PutEntityType_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConceptManager_PutEntityType_Res {
        static mut instance: ::protobuf::lazy::Lazy<ConceptManager_PutEntityType_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConceptManager_PutEntityType_Res,
        };
        unsafe {
            instance.get(ConceptManager_PutEntityType_Res::new)
        }
    }
}

impl ::protobuf::Clear for ConceptManager_PutEntityType_Res {
    fn clear(&mut self) {
        self.entity_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptManager_PutEntityType_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptManager_PutEntityType_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptManager_PutAttributeType {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptManager_PutAttributeType {
    fn default() -> &'a ConceptManager_PutAttributeType {
        <ConceptManager_PutAttributeType as ::protobuf::Message>::default_instance()
    }
}

impl ConceptManager_PutAttributeType {
    pub fn new() -> ConceptManager_PutAttributeType {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ConceptManager_PutAttributeType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptManager_PutAttributeType {
        ConceptManager_PutAttributeType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ConceptManager_PutAttributeType>(
                    "ConceptManager_PutAttributeType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConceptManager_PutAttributeType {
        static mut instance: ::protobuf::lazy::Lazy<ConceptManager_PutAttributeType> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConceptManager_PutAttributeType,
        };
        unsafe {
            instance.get(ConceptManager_PutAttributeType::new)
        }
    }
}

impl ::protobuf::Clear for ConceptManager_PutAttributeType {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptManager_PutAttributeType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptManager_PutAttributeType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptManager_PutAttributeType_Req {
    // message fields
    pub label: ::std::string::String,
    pub value_type: AttributeType_ValueType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptManager_PutAttributeType_Req {
    fn default() -> &'a ConceptManager_PutAttributeType_Req {
        <ConceptManager_PutAttributeType_Req as ::protobuf::Message>::default_instance()
    }
}

impl ConceptManager_PutAttributeType_Req {
    pub fn new() -> ConceptManager_PutAttributeType_Req {
        ::std::default::Default::default()
    }

    // string label = 1;


    pub fn get_label(&self) -> &str {
        &self.label
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        &mut self.label
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label, ::std::string::String::new())
    }

    // .typedb.protocol.AttributeType.ValueType value_type = 2;


    pub fn get_value_type(&self) -> AttributeType_ValueType {
        self.value_type
    }
    pub fn clear_value_type(&mut self) {
        self.value_type = AttributeType_ValueType::OBJECT;
    }

    // Param is passed by value, moved
    pub fn set_value_type(&mut self, v: AttributeType_ValueType) {
        self.value_type = v;
    }
}

impl ::protobuf::Message for ConceptManager_PutAttributeType_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value_type, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.label);
        }
        if self.value_type != AttributeType_ValueType::OBJECT {
            my_size += ::protobuf::rt::enum_size(2, self.value_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.label.is_empty() {
            os.write_string(1, &self.label)?;
        }
        if self.value_type != AttributeType_ValueType::OBJECT {
            os.write_enum(2, self.value_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptManager_PutAttributeType_Req {
        ConceptManager_PutAttributeType_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "label",
                    |m: &ConceptManager_PutAttributeType_Req| { &m.label },
                    |m: &mut ConceptManager_PutAttributeType_Req| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AttributeType_ValueType>>(
                    "value_type",
                    |m: &ConceptManager_PutAttributeType_Req| { &m.value_type },
                    |m: &mut ConceptManager_PutAttributeType_Req| { &mut m.value_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConceptManager_PutAttributeType_Req>(
                    "ConceptManager_PutAttributeType_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConceptManager_PutAttributeType_Req {
        static mut instance: ::protobuf::lazy::Lazy<ConceptManager_PutAttributeType_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConceptManager_PutAttributeType_Req,
        };
        unsafe {
            instance.get(ConceptManager_PutAttributeType_Req::new)
        }
    }
}

impl ::protobuf::Clear for ConceptManager_PutAttributeType_Req {
    fn clear(&mut self) {
        self.label.clear();
        self.value_type = AttributeType_ValueType::OBJECT;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptManager_PutAttributeType_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptManager_PutAttributeType_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptManager_PutAttributeType_Res {
    // message fields
    pub attribute_type: ::protobuf::SingularPtrField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptManager_PutAttributeType_Res {
    fn default() -> &'a ConceptManager_PutAttributeType_Res {
        <ConceptManager_PutAttributeType_Res as ::protobuf::Message>::default_instance()
    }
}

impl ConceptManager_PutAttributeType_Res {
    pub fn new() -> ConceptManager_PutAttributeType_Res {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Type attribute_type = 1;


    pub fn get_attribute_type(&self) -> &Type {
        self.attribute_type.as_ref().unwrap_or_else(|| Type::default_instance())
    }
    pub fn clear_attribute_type(&mut self) {
        self.attribute_type.clear();
    }

    pub fn has_attribute_type(&self) -> bool {
        self.attribute_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attribute_type(&mut self, v: Type) {
        self.attribute_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attribute_type(&mut self) -> &mut Type {
        if self.attribute_type.is_none() {
            self.attribute_type.set_default();
        }
        self.attribute_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_attribute_type(&mut self) -> Type {
        self.attribute_type.take().unwrap_or_else(|| Type::new())
    }
}

impl ::protobuf::Message for ConceptManager_PutAttributeType_Res {
    fn is_initialized(&self) -> bool {
        for v in &self.attribute_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attribute_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.attribute_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.attribute_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptManager_PutAttributeType_Res {
        ConceptManager_PutAttributeType_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "attribute_type",
                    |m: &ConceptManager_PutAttributeType_Res| { &m.attribute_type },
                    |m: &mut ConceptManager_PutAttributeType_Res| { &mut m.attribute_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConceptManager_PutAttributeType_Res>(
                    "ConceptManager_PutAttributeType_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConceptManager_PutAttributeType_Res {
        static mut instance: ::protobuf::lazy::Lazy<ConceptManager_PutAttributeType_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConceptManager_PutAttributeType_Res,
        };
        unsafe {
            instance.get(ConceptManager_PutAttributeType_Res::new)
        }
    }
}

impl ::protobuf::Clear for ConceptManager_PutAttributeType_Res {
    fn clear(&mut self) {
        self.attribute_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptManager_PutAttributeType_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptManager_PutAttributeType_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptManager_PutRelationType {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptManager_PutRelationType {
    fn default() -> &'a ConceptManager_PutRelationType {
        <ConceptManager_PutRelationType as ::protobuf::Message>::default_instance()
    }
}

impl ConceptManager_PutRelationType {
    pub fn new() -> ConceptManager_PutRelationType {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ConceptManager_PutRelationType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptManager_PutRelationType {
        ConceptManager_PutRelationType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ConceptManager_PutRelationType>(
                    "ConceptManager_PutRelationType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConceptManager_PutRelationType {
        static mut instance: ::protobuf::lazy::Lazy<ConceptManager_PutRelationType> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConceptManager_PutRelationType,
        };
        unsafe {
            instance.get(ConceptManager_PutRelationType::new)
        }
    }
}

impl ::protobuf::Clear for ConceptManager_PutRelationType {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptManager_PutRelationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptManager_PutRelationType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptManager_PutRelationType_Req {
    // message fields
    pub label: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptManager_PutRelationType_Req {
    fn default() -> &'a ConceptManager_PutRelationType_Req {
        <ConceptManager_PutRelationType_Req as ::protobuf::Message>::default_instance()
    }
}

impl ConceptManager_PutRelationType_Req {
    pub fn new() -> ConceptManager_PutRelationType_Req {
        ::std::default::Default::default()
    }

    // string label = 1;


    pub fn get_label(&self) -> &str {
        &self.label
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        &mut self.label
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ConceptManager_PutRelationType_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.label);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.label.is_empty() {
            os.write_string(1, &self.label)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptManager_PutRelationType_Req {
        ConceptManager_PutRelationType_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "label",
                    |m: &ConceptManager_PutRelationType_Req| { &m.label },
                    |m: &mut ConceptManager_PutRelationType_Req| { &mut m.label },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConceptManager_PutRelationType_Req>(
                    "ConceptManager_PutRelationType_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConceptManager_PutRelationType_Req {
        static mut instance: ::protobuf::lazy::Lazy<ConceptManager_PutRelationType_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConceptManager_PutRelationType_Req,
        };
        unsafe {
            instance.get(ConceptManager_PutRelationType_Req::new)
        }
    }
}

impl ::protobuf::Clear for ConceptManager_PutRelationType_Req {
    fn clear(&mut self) {
        self.label.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptManager_PutRelationType_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptManager_PutRelationType_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptManager_PutRelationType_Res {
    // message fields
    pub relation_type: ::protobuf::SingularPtrField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptManager_PutRelationType_Res {
    fn default() -> &'a ConceptManager_PutRelationType_Res {
        <ConceptManager_PutRelationType_Res as ::protobuf::Message>::default_instance()
    }
}

impl ConceptManager_PutRelationType_Res {
    pub fn new() -> ConceptManager_PutRelationType_Res {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Type relation_type = 1;


    pub fn get_relation_type(&self) -> &Type {
        self.relation_type.as_ref().unwrap_or_else(|| Type::default_instance())
    }
    pub fn clear_relation_type(&mut self) {
        self.relation_type.clear();
    }

    pub fn has_relation_type(&self) -> bool {
        self.relation_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relation_type(&mut self, v: Type) {
        self.relation_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relation_type(&mut self) -> &mut Type {
        if self.relation_type.is_none() {
            self.relation_type.set_default();
        }
        self.relation_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_relation_type(&mut self) -> Type {
        self.relation_type.take().unwrap_or_else(|| Type::new())
    }
}

impl ::protobuf::Message for ConceptManager_PutRelationType_Res {
    fn is_initialized(&self) -> bool {
        for v in &self.relation_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.relation_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.relation_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.relation_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptManager_PutRelationType_Res {
        ConceptManager_PutRelationType_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "relation_type",
                    |m: &ConceptManager_PutRelationType_Res| { &m.relation_type },
                    |m: &mut ConceptManager_PutRelationType_Res| { &mut m.relation_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConceptManager_PutRelationType_Res>(
                    "ConceptManager_PutRelationType_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConceptManager_PutRelationType_Res {
        static mut instance: ::protobuf::lazy::Lazy<ConceptManager_PutRelationType_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConceptManager_PutRelationType_Res,
        };
        unsafe {
            instance.get(ConceptManager_PutRelationType_Res::new)
        }
    }
}

impl ::protobuf::Clear for ConceptManager_PutRelationType_Res {
    fn clear(&mut self) {
        self.relation_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptManager_PutRelationType_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptManager_PutRelationType_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Concept {
    // message oneof groups
    pub concept: ::std::option::Option<Concept_oneof_concept>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Concept {
    fn default() -> &'a Concept {
        <Concept as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Concept_oneof_concept {
    thing(Thing),
    field_type(Type),
}

impl Concept {
    pub fn new() -> Concept {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Thing thing = 1;


    pub fn get_thing(&self) -> &Thing {
        match self.concept {
            ::std::option::Option::Some(Concept_oneof_concept::thing(ref v)) => v,
            _ => Thing::default_instance(),
        }
    }
    pub fn clear_thing(&mut self) {
        self.concept = ::std::option::Option::None;
    }

    pub fn has_thing(&self) -> bool {
        match self.concept {
            ::std::option::Option::Some(Concept_oneof_concept::thing(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing(&mut self, v: Thing) {
        self.concept = ::std::option::Option::Some(Concept_oneof_concept::thing(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing(&mut self) -> &mut Thing {
        if let ::std::option::Option::Some(Concept_oneof_concept::thing(_)) = self.concept {
        } else {
            self.concept = ::std::option::Option::Some(Concept_oneof_concept::thing(Thing::new()));
        }
        match self.concept {
            ::std::option::Option::Some(Concept_oneof_concept::thing(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing(&mut self) -> Thing {
        if self.has_thing() {
            match self.concept.take() {
                ::std::option::Option::Some(Concept_oneof_concept::thing(v)) => v,
                _ => panic!(),
            }
        } else {
            Thing::new()
        }
    }

    // .typedb.protocol.Type type = 2;


    pub fn get_field_type(&self) -> &Type {
        match self.concept {
            ::std::option::Option::Some(Concept_oneof_concept::field_type(ref v)) => v,
            _ => Type::default_instance(),
        }
    }
    pub fn clear_field_type(&mut self) {
        self.concept = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        match self.concept {
            ::std::option::Option::Some(Concept_oneof_concept::field_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Type) {
        self.concept = ::std::option::Option::Some(Concept_oneof_concept::field_type(v))
    }

    // Mutable pointer to the field.
    pub fn mut_field_type(&mut self) -> &mut Type {
        if let ::std::option::Option::Some(Concept_oneof_concept::field_type(_)) = self.concept {
        } else {
            self.concept = ::std::option::Option::Some(Concept_oneof_concept::field_type(Type::new()));
        }
        match self.concept {
            ::std::option::Option::Some(Concept_oneof_concept::field_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_field_type(&mut self) -> Type {
        if self.has_field_type() {
            match self.concept.take() {
                ::std::option::Option::Some(Concept_oneof_concept::field_type(v)) => v,
                _ => panic!(),
            }
        } else {
            Type::new()
        }
    }
}

impl ::protobuf::Message for Concept {
    fn is_initialized(&self) -> bool {
        if let Some(Concept_oneof_concept::thing(ref v)) = self.concept {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Concept_oneof_concept::field_type(ref v)) = self.concept {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.concept = ::std::option::Option::Some(Concept_oneof_concept::thing(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.concept = ::std::option::Option::Some(Concept_oneof_concept::field_type(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.concept {
            match v {
                &Concept_oneof_concept::thing(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Concept_oneof_concept::field_type(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.concept {
            match v {
                &Concept_oneof_concept::thing(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Concept_oneof_concept::field_type(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Concept {
        Concept::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Thing>(
                    "thing",
                    Concept::has_thing,
                    Concept::get_thing,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type>(
                    "type",
                    Concept::has_field_type,
                    Concept::get_field_type,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Concept>(
                    "Concept",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Concept {
        static mut instance: ::protobuf::lazy::Lazy<Concept> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Concept,
        };
        unsafe {
            instance.get(Concept::new)
        }
    }
}

impl ::protobuf::Clear for Concept {
    fn clear(&mut self) {
        self.concept = ::std::option::Option::None;
        self.concept = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Concept {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Concept {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing {
    // message fields
    pub iid: ::std::vec::Vec<u8>,
    pub field_type: ::protobuf::SingularPtrField<Type>,
    pub value: ::protobuf::SingularPtrField<Attribute_Value>,
    pub inferred: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing {
    fn default() -> &'a Thing {
        <Thing as ::protobuf::Message>::default_instance()
    }
}

impl Thing {
    pub fn new() -> Thing {
        ::std::default::Default::default()
    }

    // bytes iid = 1;


    pub fn get_iid(&self) -> &[u8] {
        &self.iid
    }
    pub fn clear_iid(&mut self) {
        self.iid.clear();
    }

    // Param is passed by value, moved
    pub fn set_iid(&mut self, v: ::std::vec::Vec<u8>) {
        self.iid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.iid
    }

    // Take field
    pub fn take_iid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.iid, ::std::vec::Vec::new())
    }

    // .typedb.protocol.Type type = 2;


    pub fn get_field_type(&self) -> &Type {
        self.field_type.as_ref().unwrap_or_else(|| Type::default_instance())
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Type) {
        self.field_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut Type {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> Type {
        self.field_type.take().unwrap_or_else(|| Type::new())
    }

    // .typedb.protocol.Attribute.Value value = 3;


    pub fn get_value(&self) -> &Attribute_Value {
        self.value.as_ref().unwrap_or_else(|| Attribute_Value::default_instance())
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: Attribute_Value) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut Attribute_Value {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> Attribute_Value {
        self.value.take().unwrap_or_else(|| Attribute_Value::new())
    }

    // bool inferred = 4;


    pub fn get_inferred(&self) -> bool {
        self.inferred
    }
    pub fn clear_inferred(&mut self) {
        self.inferred = false;
    }

    // Param is passed by value, moved
    pub fn set_inferred(&mut self, v: bool) {
        self.inferred = v;
    }
}

impl ::protobuf::Message for Thing {
    fn is_initialized(&self) -> bool {
        for v in &self.field_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.iid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inferred = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.iid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.iid);
        }
        if let Some(ref v) = self.field_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.inferred != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.iid.is_empty() {
            os.write_bytes(1, &self.iid)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.inferred != false {
            os.write_bool(4, self.inferred)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing {
        Thing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "iid",
                    |m: &Thing| { &m.iid },
                    |m: &mut Thing| { &mut m.iid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "type",
                    |m: &Thing| { &m.field_type },
                    |m: &mut Thing| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Attribute_Value>>(
                    "value",
                    |m: &Thing| { &m.value },
                    |m: &mut Thing| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "inferred",
                    |m: &Thing| { &m.inferred },
                    |m: &mut Thing| { &mut m.inferred },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Thing>(
                    "Thing",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing {
        static mut instance: ::protobuf::lazy::Lazy<Thing> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing,
        };
        unsafe {
            instance.get(Thing::new)
        }
    }
}

impl ::protobuf::Clear for Thing {
    fn clear(&mut self) {
        self.iid.clear();
        self.field_type.clear();
        self.value.clear();
        self.inferred = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing_Req {
    // message fields
    pub iid: ::std::vec::Vec<u8>,
    // message oneof groups
    pub req: ::std::option::Option<Thing_Req_oneof_req>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing_Req {
    fn default() -> &'a Thing_Req {
        <Thing_Req as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Thing_Req_oneof_req {
    thing_delete_req(Thing_Delete_Req),
    thing_get_type_req(Thing_GetType_Req),
    thing_get_has_req(Thing_GetHas_Req),
    thing_set_has_req(Thing_SetHas_Req),
    thing_unset_has_req(Thing_UnsetHas_Req),
    thing_get_relations_req(Thing_GetRelations_Req),
    thing_get_playing_req(Thing_GetPlaying_Req),
    relation_add_player_req(Relation_AddPlayer_Req),
    relation_remove_player_req(Relation_RemovePlayer_Req),
    relation_get_players_req(Relation_GetPlayers_Req),
    relation_get_players_by_role_type_req(Relation_GetPlayersByRoleType_Req),
    relation_get_relating_req(Relation_GetRelating_Req),
    attribute_get_owners_req(Attribute_GetOwners_Req),
}

impl Thing_Req {
    pub fn new() -> Thing_Req {
        ::std::default::Default::default()
    }

    // bytes iid = 1;


    pub fn get_iid(&self) -> &[u8] {
        &self.iid
    }
    pub fn clear_iid(&mut self) {
        self.iid.clear();
    }

    // Param is passed by value, moved
    pub fn set_iid(&mut self, v: ::std::vec::Vec<u8>) {
        self.iid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.iid
    }

    // Take field
    pub fn take_iid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.iid, ::std::vec::Vec::new())
    }

    // .typedb.protocol.Thing.Delete.Req thing_delete_req = 100;


    pub fn get_thing_delete_req(&self) -> &Thing_Delete_Req {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::thing_delete_req(ref v)) => v,
            _ => Thing_Delete_Req::default_instance(),
        }
    }
    pub fn clear_thing_delete_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_thing_delete_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::thing_delete_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_delete_req(&mut self, v: Thing_Delete_Req) {
        self.req = ::std::option::Option::Some(Thing_Req_oneof_req::thing_delete_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_delete_req(&mut self) -> &mut Thing_Delete_Req {
        if let ::std::option::Option::Some(Thing_Req_oneof_req::thing_delete_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Thing_Req_oneof_req::thing_delete_req(Thing_Delete_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::thing_delete_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_delete_req(&mut self) -> Thing_Delete_Req {
        if self.has_thing_delete_req() {
            match self.req.take() {
                ::std::option::Option::Some(Thing_Req_oneof_req::thing_delete_req(v)) => v,
                _ => panic!(),
            }
        } else {
            Thing_Delete_Req::new()
        }
    }

    // .typedb.protocol.Thing.GetType.Req thing_get_type_req = 101;


    pub fn get_thing_get_type_req(&self) -> &Thing_GetType_Req {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_type_req(ref v)) => v,
            _ => Thing_GetType_Req::default_instance(),
        }
    }
    pub fn clear_thing_get_type_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_thing_get_type_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_type_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_get_type_req(&mut self, v: Thing_GetType_Req) {
        self.req = ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_type_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_get_type_req(&mut self) -> &mut Thing_GetType_Req {
        if let ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_type_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_type_req(Thing_GetType_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_type_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_get_type_req(&mut self) -> Thing_GetType_Req {
        if self.has_thing_get_type_req() {
            match self.req.take() {
                ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_type_req(v)) => v,
                _ => panic!(),
            }
        } else {
            Thing_GetType_Req::new()
        }
    }

    // .typedb.protocol.Thing.GetHas.Req thing_get_has_req = 102;


    pub fn get_thing_get_has_req(&self) -> &Thing_GetHas_Req {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_has_req(ref v)) => v,
            _ => Thing_GetHas_Req::default_instance(),
        }
    }
    pub fn clear_thing_get_has_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_thing_get_has_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_has_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_get_has_req(&mut self, v: Thing_GetHas_Req) {
        self.req = ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_has_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_get_has_req(&mut self) -> &mut Thing_GetHas_Req {
        if let ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_has_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_has_req(Thing_GetHas_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_has_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_get_has_req(&mut self) -> Thing_GetHas_Req {
        if self.has_thing_get_has_req() {
            match self.req.take() {
                ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_has_req(v)) => v,
                _ => panic!(),
            }
        } else {
            Thing_GetHas_Req::new()
        }
    }

    // .typedb.protocol.Thing.SetHas.Req thing_set_has_req = 103;


    pub fn get_thing_set_has_req(&self) -> &Thing_SetHas_Req {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::thing_set_has_req(ref v)) => v,
            _ => Thing_SetHas_Req::default_instance(),
        }
    }
    pub fn clear_thing_set_has_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_thing_set_has_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::thing_set_has_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_set_has_req(&mut self, v: Thing_SetHas_Req) {
        self.req = ::std::option::Option::Some(Thing_Req_oneof_req::thing_set_has_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_set_has_req(&mut self) -> &mut Thing_SetHas_Req {
        if let ::std::option::Option::Some(Thing_Req_oneof_req::thing_set_has_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Thing_Req_oneof_req::thing_set_has_req(Thing_SetHas_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::thing_set_has_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_set_has_req(&mut self) -> Thing_SetHas_Req {
        if self.has_thing_set_has_req() {
            match self.req.take() {
                ::std::option::Option::Some(Thing_Req_oneof_req::thing_set_has_req(v)) => v,
                _ => panic!(),
            }
        } else {
            Thing_SetHas_Req::new()
        }
    }

    // .typedb.protocol.Thing.UnsetHas.Req thing_unset_has_req = 104;


    pub fn get_thing_unset_has_req(&self) -> &Thing_UnsetHas_Req {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::thing_unset_has_req(ref v)) => v,
            _ => Thing_UnsetHas_Req::default_instance(),
        }
    }
    pub fn clear_thing_unset_has_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_thing_unset_has_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::thing_unset_has_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_unset_has_req(&mut self, v: Thing_UnsetHas_Req) {
        self.req = ::std::option::Option::Some(Thing_Req_oneof_req::thing_unset_has_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_unset_has_req(&mut self) -> &mut Thing_UnsetHas_Req {
        if let ::std::option::Option::Some(Thing_Req_oneof_req::thing_unset_has_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Thing_Req_oneof_req::thing_unset_has_req(Thing_UnsetHas_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::thing_unset_has_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_unset_has_req(&mut self) -> Thing_UnsetHas_Req {
        if self.has_thing_unset_has_req() {
            match self.req.take() {
                ::std::option::Option::Some(Thing_Req_oneof_req::thing_unset_has_req(v)) => v,
                _ => panic!(),
            }
        } else {
            Thing_UnsetHas_Req::new()
        }
    }

    // .typedb.protocol.Thing.GetRelations.Req thing_get_relations_req = 105;


    pub fn get_thing_get_relations_req(&self) -> &Thing_GetRelations_Req {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_relations_req(ref v)) => v,
            _ => Thing_GetRelations_Req::default_instance(),
        }
    }
    pub fn clear_thing_get_relations_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_thing_get_relations_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_relations_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_get_relations_req(&mut self, v: Thing_GetRelations_Req) {
        self.req = ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_relations_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_get_relations_req(&mut self) -> &mut Thing_GetRelations_Req {
        if let ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_relations_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_relations_req(Thing_GetRelations_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_relations_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_get_relations_req(&mut self) -> Thing_GetRelations_Req {
        if self.has_thing_get_relations_req() {
            match self.req.take() {
                ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_relations_req(v)) => v,
                _ => panic!(),
            }
        } else {
            Thing_GetRelations_Req::new()
        }
    }

    // .typedb.protocol.Thing.GetPlaying.Req thing_get_playing_req = 106;


    pub fn get_thing_get_playing_req(&self) -> &Thing_GetPlaying_Req {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_playing_req(ref v)) => v,
            _ => Thing_GetPlaying_Req::default_instance(),
        }
    }
    pub fn clear_thing_get_playing_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_thing_get_playing_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_playing_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_get_playing_req(&mut self, v: Thing_GetPlaying_Req) {
        self.req = ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_playing_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_get_playing_req(&mut self) -> &mut Thing_GetPlaying_Req {
        if let ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_playing_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_playing_req(Thing_GetPlaying_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_playing_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_get_playing_req(&mut self) -> Thing_GetPlaying_Req {
        if self.has_thing_get_playing_req() {
            match self.req.take() {
                ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_playing_req(v)) => v,
                _ => panic!(),
            }
        } else {
            Thing_GetPlaying_Req::new()
        }
    }

    // .typedb.protocol.Relation.AddPlayer.Req relation_add_player_req = 200;


    pub fn get_relation_add_player_req(&self) -> &Relation_AddPlayer_Req {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::relation_add_player_req(ref v)) => v,
            _ => Relation_AddPlayer_Req::default_instance(),
        }
    }
    pub fn clear_relation_add_player_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_relation_add_player_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::relation_add_player_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_relation_add_player_req(&mut self, v: Relation_AddPlayer_Req) {
        self.req = ::std::option::Option::Some(Thing_Req_oneof_req::relation_add_player_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_relation_add_player_req(&mut self) -> &mut Relation_AddPlayer_Req {
        if let ::std::option::Option::Some(Thing_Req_oneof_req::relation_add_player_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Thing_Req_oneof_req::relation_add_player_req(Relation_AddPlayer_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::relation_add_player_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_relation_add_player_req(&mut self) -> Relation_AddPlayer_Req {
        if self.has_relation_add_player_req() {
            match self.req.take() {
                ::std::option::Option::Some(Thing_Req_oneof_req::relation_add_player_req(v)) => v,
                _ => panic!(),
            }
        } else {
            Relation_AddPlayer_Req::new()
        }
    }

    // .typedb.protocol.Relation.RemovePlayer.Req relation_remove_player_req = 201;


    pub fn get_relation_remove_player_req(&self) -> &Relation_RemovePlayer_Req {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::relation_remove_player_req(ref v)) => v,
            _ => Relation_RemovePlayer_Req::default_instance(),
        }
    }
    pub fn clear_relation_remove_player_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_relation_remove_player_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::relation_remove_player_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_relation_remove_player_req(&mut self, v: Relation_RemovePlayer_Req) {
        self.req = ::std::option::Option::Some(Thing_Req_oneof_req::relation_remove_player_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_relation_remove_player_req(&mut self) -> &mut Relation_RemovePlayer_Req {
        if let ::std::option::Option::Some(Thing_Req_oneof_req::relation_remove_player_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Thing_Req_oneof_req::relation_remove_player_req(Relation_RemovePlayer_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::relation_remove_player_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_relation_remove_player_req(&mut self) -> Relation_RemovePlayer_Req {
        if self.has_relation_remove_player_req() {
            match self.req.take() {
                ::std::option::Option::Some(Thing_Req_oneof_req::relation_remove_player_req(v)) => v,
                _ => panic!(),
            }
        } else {
            Relation_RemovePlayer_Req::new()
        }
    }

    // .typedb.protocol.Relation.GetPlayers.Req relation_get_players_req = 202;


    pub fn get_relation_get_players_req(&self) -> &Relation_GetPlayers_Req {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::relation_get_players_req(ref v)) => v,
            _ => Relation_GetPlayers_Req::default_instance(),
        }
    }
    pub fn clear_relation_get_players_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_relation_get_players_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::relation_get_players_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_relation_get_players_req(&mut self, v: Relation_GetPlayers_Req) {
        self.req = ::std::option::Option::Some(Thing_Req_oneof_req::relation_get_players_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_relation_get_players_req(&mut self) -> &mut Relation_GetPlayers_Req {
        if let ::std::option::Option::Some(Thing_Req_oneof_req::relation_get_players_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Thing_Req_oneof_req::relation_get_players_req(Relation_GetPlayers_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::relation_get_players_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_relation_get_players_req(&mut self) -> Relation_GetPlayers_Req {
        if self.has_relation_get_players_req() {
            match self.req.take() {
                ::std::option::Option::Some(Thing_Req_oneof_req::relation_get_players_req(v)) => v,
                _ => panic!(),
            }
        } else {
            Relation_GetPlayers_Req::new()
        }
    }

    // .typedb.protocol.Relation.GetPlayersByRoleType.Req relation_get_players_by_role_type_req = 203;


    pub fn get_relation_get_players_by_role_type_req(&self) -> &Relation_GetPlayersByRoleType_Req {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::relation_get_players_by_role_type_req(ref v)) => v,
            _ => Relation_GetPlayersByRoleType_Req::default_instance(),
        }
    }
    pub fn clear_relation_get_players_by_role_type_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_relation_get_players_by_role_type_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::relation_get_players_by_role_type_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_relation_get_players_by_role_type_req(&mut self, v: Relation_GetPlayersByRoleType_Req) {
        self.req = ::std::option::Option::Some(Thing_Req_oneof_req::relation_get_players_by_role_type_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_relation_get_players_by_role_type_req(&mut self) -> &mut Relation_GetPlayersByRoleType_Req {
        if let ::std::option::Option::Some(Thing_Req_oneof_req::relation_get_players_by_role_type_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Thing_Req_oneof_req::relation_get_players_by_role_type_req(Relation_GetPlayersByRoleType_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::relation_get_players_by_role_type_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_relation_get_players_by_role_type_req(&mut self) -> Relation_GetPlayersByRoleType_Req {
        if self.has_relation_get_players_by_role_type_req() {
            match self.req.take() {
                ::std::option::Option::Some(Thing_Req_oneof_req::relation_get_players_by_role_type_req(v)) => v,
                _ => panic!(),
            }
        } else {
            Relation_GetPlayersByRoleType_Req::new()
        }
    }

    // .typedb.protocol.Relation.GetRelating.Req relation_get_relating_req = 204;


    pub fn get_relation_get_relating_req(&self) -> &Relation_GetRelating_Req {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::relation_get_relating_req(ref v)) => v,
            _ => Relation_GetRelating_Req::default_instance(),
        }
    }
    pub fn clear_relation_get_relating_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_relation_get_relating_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::relation_get_relating_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_relation_get_relating_req(&mut self, v: Relation_GetRelating_Req) {
        self.req = ::std::option::Option::Some(Thing_Req_oneof_req::relation_get_relating_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_relation_get_relating_req(&mut self) -> &mut Relation_GetRelating_Req {
        if let ::std::option::Option::Some(Thing_Req_oneof_req::relation_get_relating_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Thing_Req_oneof_req::relation_get_relating_req(Relation_GetRelating_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::relation_get_relating_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_relation_get_relating_req(&mut self) -> Relation_GetRelating_Req {
        if self.has_relation_get_relating_req() {
            match self.req.take() {
                ::std::option::Option::Some(Thing_Req_oneof_req::relation_get_relating_req(v)) => v,
                _ => panic!(),
            }
        } else {
            Relation_GetRelating_Req::new()
        }
    }

    // .typedb.protocol.Attribute.GetOwners.Req attribute_get_owners_req = 300;


    pub fn get_attribute_get_owners_req(&self) -> &Attribute_GetOwners_Req {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::attribute_get_owners_req(ref v)) => v,
            _ => Attribute_GetOwners_Req::default_instance(),
        }
    }
    pub fn clear_attribute_get_owners_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_attribute_get_owners_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::attribute_get_owners_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_attribute_get_owners_req(&mut self, v: Attribute_GetOwners_Req) {
        self.req = ::std::option::Option::Some(Thing_Req_oneof_req::attribute_get_owners_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_attribute_get_owners_req(&mut self) -> &mut Attribute_GetOwners_Req {
        if let ::std::option::Option::Some(Thing_Req_oneof_req::attribute_get_owners_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Thing_Req_oneof_req::attribute_get_owners_req(Attribute_GetOwners_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Thing_Req_oneof_req::attribute_get_owners_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_attribute_get_owners_req(&mut self) -> Attribute_GetOwners_Req {
        if self.has_attribute_get_owners_req() {
            match self.req.take() {
                ::std::option::Option::Some(Thing_Req_oneof_req::attribute_get_owners_req(v)) => v,
                _ => panic!(),
            }
        } else {
            Attribute_GetOwners_Req::new()
        }
    }
}

impl ::protobuf::Message for Thing_Req {
    fn is_initialized(&self) -> bool {
        if let Some(Thing_Req_oneof_req::thing_delete_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Thing_Req_oneof_req::thing_get_type_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Thing_Req_oneof_req::thing_get_has_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Thing_Req_oneof_req::thing_set_has_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Thing_Req_oneof_req::thing_unset_has_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Thing_Req_oneof_req::thing_get_relations_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Thing_Req_oneof_req::thing_get_playing_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Thing_Req_oneof_req::relation_add_player_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Thing_Req_oneof_req::relation_remove_player_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Thing_Req_oneof_req::relation_get_players_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Thing_Req_oneof_req::relation_get_players_by_role_type_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Thing_Req_oneof_req::relation_get_relating_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Thing_Req_oneof_req::attribute_get_owners_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.iid)?;
                },
                100 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Thing_Req_oneof_req::thing_delete_req(is.read_message()?));
                },
                101 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_type_req(is.read_message()?));
                },
                102 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_has_req(is.read_message()?));
                },
                103 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Thing_Req_oneof_req::thing_set_has_req(is.read_message()?));
                },
                104 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Thing_Req_oneof_req::thing_unset_has_req(is.read_message()?));
                },
                105 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_relations_req(is.read_message()?));
                },
                106 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Thing_Req_oneof_req::thing_get_playing_req(is.read_message()?));
                },
                200 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Thing_Req_oneof_req::relation_add_player_req(is.read_message()?));
                },
                201 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Thing_Req_oneof_req::relation_remove_player_req(is.read_message()?));
                },
                202 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Thing_Req_oneof_req::relation_get_players_req(is.read_message()?));
                },
                203 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Thing_Req_oneof_req::relation_get_players_by_role_type_req(is.read_message()?));
                },
                204 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Thing_Req_oneof_req::relation_get_relating_req(is.read_message()?));
                },
                300 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Thing_Req_oneof_req::attribute_get_owners_req(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.iid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.iid);
        }
        if let ::std::option::Option::Some(ref v) = self.req {
            match v {
                &Thing_Req_oneof_req::thing_delete_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Thing_Req_oneof_req::thing_get_type_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Thing_Req_oneof_req::thing_get_has_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Thing_Req_oneof_req::thing_set_has_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Thing_Req_oneof_req::thing_unset_has_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Thing_Req_oneof_req::thing_get_relations_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Thing_Req_oneof_req::thing_get_playing_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Thing_Req_oneof_req::relation_add_player_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Thing_Req_oneof_req::relation_remove_player_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Thing_Req_oneof_req::relation_get_players_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Thing_Req_oneof_req::relation_get_players_by_role_type_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Thing_Req_oneof_req::relation_get_relating_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Thing_Req_oneof_req::attribute_get_owners_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.iid.is_empty() {
            os.write_bytes(1, &self.iid)?;
        }
        if let ::std::option::Option::Some(ref v) = self.req {
            match v {
                &Thing_Req_oneof_req::thing_delete_req(ref v) => {
                    os.write_tag(100, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Thing_Req_oneof_req::thing_get_type_req(ref v) => {
                    os.write_tag(101, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Thing_Req_oneof_req::thing_get_has_req(ref v) => {
                    os.write_tag(102, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Thing_Req_oneof_req::thing_set_has_req(ref v) => {
                    os.write_tag(103, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Thing_Req_oneof_req::thing_unset_has_req(ref v) => {
                    os.write_tag(104, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Thing_Req_oneof_req::thing_get_relations_req(ref v) => {
                    os.write_tag(105, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Thing_Req_oneof_req::thing_get_playing_req(ref v) => {
                    os.write_tag(106, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Thing_Req_oneof_req::relation_add_player_req(ref v) => {
                    os.write_tag(200, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Thing_Req_oneof_req::relation_remove_player_req(ref v) => {
                    os.write_tag(201, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Thing_Req_oneof_req::relation_get_players_req(ref v) => {
                    os.write_tag(202, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Thing_Req_oneof_req::relation_get_players_by_role_type_req(ref v) => {
                    os.write_tag(203, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Thing_Req_oneof_req::relation_get_relating_req(ref v) => {
                    os.write_tag(204, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Thing_Req_oneof_req::attribute_get_owners_req(ref v) => {
                    os.write_tag(300, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing_Req {
        Thing_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "iid",
                    |m: &Thing_Req| { &m.iid },
                    |m: &mut Thing_Req| { &mut m.iid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Thing_Delete_Req>(
                    "thing_delete_req",
                    Thing_Req::has_thing_delete_req,
                    Thing_Req::get_thing_delete_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Thing_GetType_Req>(
                    "thing_get_type_req",
                    Thing_Req::has_thing_get_type_req,
                    Thing_Req::get_thing_get_type_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Thing_GetHas_Req>(
                    "thing_get_has_req",
                    Thing_Req::has_thing_get_has_req,
                    Thing_Req::get_thing_get_has_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Thing_SetHas_Req>(
                    "thing_set_has_req",
                    Thing_Req::has_thing_set_has_req,
                    Thing_Req::get_thing_set_has_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Thing_UnsetHas_Req>(
                    "thing_unset_has_req",
                    Thing_Req::has_thing_unset_has_req,
                    Thing_Req::get_thing_unset_has_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Thing_GetRelations_Req>(
                    "thing_get_relations_req",
                    Thing_Req::has_thing_get_relations_req,
                    Thing_Req::get_thing_get_relations_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Thing_GetPlaying_Req>(
                    "thing_get_playing_req",
                    Thing_Req::has_thing_get_playing_req,
                    Thing_Req::get_thing_get_playing_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Relation_AddPlayer_Req>(
                    "relation_add_player_req",
                    Thing_Req::has_relation_add_player_req,
                    Thing_Req::get_relation_add_player_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Relation_RemovePlayer_Req>(
                    "relation_remove_player_req",
                    Thing_Req::has_relation_remove_player_req,
                    Thing_Req::get_relation_remove_player_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Relation_GetPlayers_Req>(
                    "relation_get_players_req",
                    Thing_Req::has_relation_get_players_req,
                    Thing_Req::get_relation_get_players_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Relation_GetPlayersByRoleType_Req>(
                    "relation_get_players_by_role_type_req",
                    Thing_Req::has_relation_get_players_by_role_type_req,
                    Thing_Req::get_relation_get_players_by_role_type_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Relation_GetRelating_Req>(
                    "relation_get_relating_req",
                    Thing_Req::has_relation_get_relating_req,
                    Thing_Req::get_relation_get_relating_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Attribute_GetOwners_Req>(
                    "attribute_get_owners_req",
                    Thing_Req::has_attribute_get_owners_req,
                    Thing_Req::get_attribute_get_owners_req,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Thing_Req>(
                    "Thing_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing_Req {
        static mut instance: ::protobuf::lazy::Lazy<Thing_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing_Req,
        };
        unsafe {
            instance.get(Thing_Req::new)
        }
    }
}

impl ::protobuf::Clear for Thing_Req {
    fn clear(&mut self) {
        self.iid.clear();
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing_Res {
    // message oneof groups
    pub res: ::std::option::Option<Thing_Res_oneof_res>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing_Res {
    fn default() -> &'a Thing_Res {
        <Thing_Res as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Thing_Res_oneof_res {
    thing_delete_res(Thing_Delete_Res),
    thing_get_type_res(Thing_GetType_Res),
    thing_set_has_res(Thing_SetHas_Res),
    thing_unset_has_res(Thing_UnsetHas_Res),
    relation_add_player_res(Relation_AddPlayer_Res),
    relation_remove_player_res(Relation_RemovePlayer_Res),
}

impl Thing_Res {
    pub fn new() -> Thing_Res {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Thing.Delete.Res thing_delete_res = 100;


    pub fn get_thing_delete_res(&self) -> &Thing_Delete_Res {
        match self.res {
            ::std::option::Option::Some(Thing_Res_oneof_res::thing_delete_res(ref v)) => v,
            _ => Thing_Delete_Res::default_instance(),
        }
    }
    pub fn clear_thing_delete_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_thing_delete_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Thing_Res_oneof_res::thing_delete_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_delete_res(&mut self, v: Thing_Delete_Res) {
        self.res = ::std::option::Option::Some(Thing_Res_oneof_res::thing_delete_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_delete_res(&mut self) -> &mut Thing_Delete_Res {
        if let ::std::option::Option::Some(Thing_Res_oneof_res::thing_delete_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Thing_Res_oneof_res::thing_delete_res(Thing_Delete_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Thing_Res_oneof_res::thing_delete_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_delete_res(&mut self) -> Thing_Delete_Res {
        if self.has_thing_delete_res() {
            match self.res.take() {
                ::std::option::Option::Some(Thing_Res_oneof_res::thing_delete_res(v)) => v,
                _ => panic!(),
            }
        } else {
            Thing_Delete_Res::new()
        }
    }

    // .typedb.protocol.Thing.GetType.Res thing_get_type_res = 101;


    pub fn get_thing_get_type_res(&self) -> &Thing_GetType_Res {
        match self.res {
            ::std::option::Option::Some(Thing_Res_oneof_res::thing_get_type_res(ref v)) => v,
            _ => Thing_GetType_Res::default_instance(),
        }
    }
    pub fn clear_thing_get_type_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_thing_get_type_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Thing_Res_oneof_res::thing_get_type_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_get_type_res(&mut self, v: Thing_GetType_Res) {
        self.res = ::std::option::Option::Some(Thing_Res_oneof_res::thing_get_type_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_get_type_res(&mut self) -> &mut Thing_GetType_Res {
        if let ::std::option::Option::Some(Thing_Res_oneof_res::thing_get_type_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Thing_Res_oneof_res::thing_get_type_res(Thing_GetType_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Thing_Res_oneof_res::thing_get_type_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_get_type_res(&mut self) -> Thing_GetType_Res {
        if self.has_thing_get_type_res() {
            match self.res.take() {
                ::std::option::Option::Some(Thing_Res_oneof_res::thing_get_type_res(v)) => v,
                _ => panic!(),
            }
        } else {
            Thing_GetType_Res::new()
        }
    }

    // .typedb.protocol.Thing.SetHas.Res thing_set_has_res = 102;


    pub fn get_thing_set_has_res(&self) -> &Thing_SetHas_Res {
        match self.res {
            ::std::option::Option::Some(Thing_Res_oneof_res::thing_set_has_res(ref v)) => v,
            _ => Thing_SetHas_Res::default_instance(),
        }
    }
    pub fn clear_thing_set_has_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_thing_set_has_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Thing_Res_oneof_res::thing_set_has_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_set_has_res(&mut self, v: Thing_SetHas_Res) {
        self.res = ::std::option::Option::Some(Thing_Res_oneof_res::thing_set_has_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_set_has_res(&mut self) -> &mut Thing_SetHas_Res {
        if let ::std::option::Option::Some(Thing_Res_oneof_res::thing_set_has_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Thing_Res_oneof_res::thing_set_has_res(Thing_SetHas_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Thing_Res_oneof_res::thing_set_has_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_set_has_res(&mut self) -> Thing_SetHas_Res {
        if self.has_thing_set_has_res() {
            match self.res.take() {
                ::std::option::Option::Some(Thing_Res_oneof_res::thing_set_has_res(v)) => v,
                _ => panic!(),
            }
        } else {
            Thing_SetHas_Res::new()
        }
    }

    // .typedb.protocol.Thing.UnsetHas.Res thing_unset_has_res = 103;


    pub fn get_thing_unset_has_res(&self) -> &Thing_UnsetHas_Res {
        match self.res {
            ::std::option::Option::Some(Thing_Res_oneof_res::thing_unset_has_res(ref v)) => v,
            _ => Thing_UnsetHas_Res::default_instance(),
        }
    }
    pub fn clear_thing_unset_has_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_thing_unset_has_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Thing_Res_oneof_res::thing_unset_has_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_unset_has_res(&mut self, v: Thing_UnsetHas_Res) {
        self.res = ::std::option::Option::Some(Thing_Res_oneof_res::thing_unset_has_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_unset_has_res(&mut self) -> &mut Thing_UnsetHas_Res {
        if let ::std::option::Option::Some(Thing_Res_oneof_res::thing_unset_has_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Thing_Res_oneof_res::thing_unset_has_res(Thing_UnsetHas_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Thing_Res_oneof_res::thing_unset_has_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_unset_has_res(&mut self) -> Thing_UnsetHas_Res {
        if self.has_thing_unset_has_res() {
            match self.res.take() {
                ::std::option::Option::Some(Thing_Res_oneof_res::thing_unset_has_res(v)) => v,
                _ => panic!(),
            }
        } else {
            Thing_UnsetHas_Res::new()
        }
    }

    // .typedb.protocol.Relation.AddPlayer.Res relation_add_player_res = 200;


    pub fn get_relation_add_player_res(&self) -> &Relation_AddPlayer_Res {
        match self.res {
            ::std::option::Option::Some(Thing_Res_oneof_res::relation_add_player_res(ref v)) => v,
            _ => Relation_AddPlayer_Res::default_instance(),
        }
    }
    pub fn clear_relation_add_player_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_relation_add_player_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Thing_Res_oneof_res::relation_add_player_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_relation_add_player_res(&mut self, v: Relation_AddPlayer_Res) {
        self.res = ::std::option::Option::Some(Thing_Res_oneof_res::relation_add_player_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_relation_add_player_res(&mut self) -> &mut Relation_AddPlayer_Res {
        if let ::std::option::Option::Some(Thing_Res_oneof_res::relation_add_player_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Thing_Res_oneof_res::relation_add_player_res(Relation_AddPlayer_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Thing_Res_oneof_res::relation_add_player_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_relation_add_player_res(&mut self) -> Relation_AddPlayer_Res {
        if self.has_relation_add_player_res() {
            match self.res.take() {
                ::std::option::Option::Some(Thing_Res_oneof_res::relation_add_player_res(v)) => v,
                _ => panic!(),
            }
        } else {
            Relation_AddPlayer_Res::new()
        }
    }

    // .typedb.protocol.Relation.RemovePlayer.Res relation_remove_player_res = 201;


    pub fn get_relation_remove_player_res(&self) -> &Relation_RemovePlayer_Res {
        match self.res {
            ::std::option::Option::Some(Thing_Res_oneof_res::relation_remove_player_res(ref v)) => v,
            _ => Relation_RemovePlayer_Res::default_instance(),
        }
    }
    pub fn clear_relation_remove_player_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_relation_remove_player_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Thing_Res_oneof_res::relation_remove_player_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_relation_remove_player_res(&mut self, v: Relation_RemovePlayer_Res) {
        self.res = ::std::option::Option::Some(Thing_Res_oneof_res::relation_remove_player_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_relation_remove_player_res(&mut self) -> &mut Relation_RemovePlayer_Res {
        if let ::std::option::Option::Some(Thing_Res_oneof_res::relation_remove_player_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Thing_Res_oneof_res::relation_remove_player_res(Relation_RemovePlayer_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Thing_Res_oneof_res::relation_remove_player_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_relation_remove_player_res(&mut self) -> Relation_RemovePlayer_Res {
        if self.has_relation_remove_player_res() {
            match self.res.take() {
                ::std::option::Option::Some(Thing_Res_oneof_res::relation_remove_player_res(v)) => v,
                _ => panic!(),
            }
        } else {
            Relation_RemovePlayer_Res::new()
        }
    }
}

impl ::protobuf::Message for Thing_Res {
    fn is_initialized(&self) -> bool {
        if let Some(Thing_Res_oneof_res::thing_delete_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Thing_Res_oneof_res::thing_get_type_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Thing_Res_oneof_res::thing_set_has_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Thing_Res_oneof_res::thing_unset_has_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Thing_Res_oneof_res::relation_add_player_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Thing_Res_oneof_res::relation_remove_player_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                100 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Thing_Res_oneof_res::thing_delete_res(is.read_message()?));
                },
                101 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Thing_Res_oneof_res::thing_get_type_res(is.read_message()?));
                },
                102 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Thing_Res_oneof_res::thing_set_has_res(is.read_message()?));
                },
                103 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Thing_Res_oneof_res::thing_unset_has_res(is.read_message()?));
                },
                200 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Thing_Res_oneof_res::relation_add_player_res(is.read_message()?));
                },
                201 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Thing_Res_oneof_res::relation_remove_player_res(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &Thing_Res_oneof_res::thing_delete_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Thing_Res_oneof_res::thing_get_type_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Thing_Res_oneof_res::thing_set_has_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Thing_Res_oneof_res::thing_unset_has_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Thing_Res_oneof_res::relation_add_player_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Thing_Res_oneof_res::relation_remove_player_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &Thing_Res_oneof_res::thing_delete_res(ref v) => {
                    os.write_tag(100, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Thing_Res_oneof_res::thing_get_type_res(ref v) => {
                    os.write_tag(101, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Thing_Res_oneof_res::thing_set_has_res(ref v) => {
                    os.write_tag(102, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Thing_Res_oneof_res::thing_unset_has_res(ref v) => {
                    os.write_tag(103, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Thing_Res_oneof_res::relation_add_player_res(ref v) => {
                    os.write_tag(200, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Thing_Res_oneof_res::relation_remove_player_res(ref v) => {
                    os.write_tag(201, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing_Res {
        Thing_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Thing_Delete_Res>(
                    "thing_delete_res",
                    Thing_Res::has_thing_delete_res,
                    Thing_Res::get_thing_delete_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Thing_GetType_Res>(
                    "thing_get_type_res",
                    Thing_Res::has_thing_get_type_res,
                    Thing_Res::get_thing_get_type_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Thing_SetHas_Res>(
                    "thing_set_has_res",
                    Thing_Res::has_thing_set_has_res,
                    Thing_Res::get_thing_set_has_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Thing_UnsetHas_Res>(
                    "thing_unset_has_res",
                    Thing_Res::has_thing_unset_has_res,
                    Thing_Res::get_thing_unset_has_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Relation_AddPlayer_Res>(
                    "relation_add_player_res",
                    Thing_Res::has_relation_add_player_res,
                    Thing_Res::get_relation_add_player_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Relation_RemovePlayer_Res>(
                    "relation_remove_player_res",
                    Thing_Res::has_relation_remove_player_res,
                    Thing_Res::get_relation_remove_player_res,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Thing_Res>(
                    "Thing_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing_Res {
        static mut instance: ::protobuf::lazy::Lazy<Thing_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing_Res,
        };
        unsafe {
            instance.get(Thing_Res::new)
        }
    }
}

impl ::protobuf::Clear for Thing_Res {
    fn clear(&mut self) {
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing_ResPart {
    // message oneof groups
    pub res: ::std::option::Option<Thing_ResPart_oneof_res>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing_ResPart {
    fn default() -> &'a Thing_ResPart {
        <Thing_ResPart as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Thing_ResPart_oneof_res {
    thing_get_has_res_part(Thing_GetHas_ResPart),
    thing_get_relations_res_part(Thing_GetRelations_ResPart),
    thing_get_playing_res_part(Thing_GetPlaying_ResPart),
    relation_get_players_res_part(Relation_GetPlayers_ResPart),
    relation_get_players_by_role_type_res_part(Relation_GetPlayersByRoleType_ResPart),
    relation_get_relating_res_part(Relation_GetRelating_ResPart),
    attribute_get_owners_res_part(Attribute_GetOwners_ResPart),
}

impl Thing_ResPart {
    pub fn new() -> Thing_ResPart {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Thing.GetHas.ResPart thing_get_has_res_part = 100;


    pub fn get_thing_get_has_res_part(&self) -> &Thing_GetHas_ResPart {
        match self.res {
            ::std::option::Option::Some(Thing_ResPart_oneof_res::thing_get_has_res_part(ref v)) => v,
            _ => Thing_GetHas_ResPart::default_instance(),
        }
    }
    pub fn clear_thing_get_has_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_thing_get_has_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Thing_ResPart_oneof_res::thing_get_has_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_get_has_res_part(&mut self, v: Thing_GetHas_ResPart) {
        self.res = ::std::option::Option::Some(Thing_ResPart_oneof_res::thing_get_has_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_get_has_res_part(&mut self) -> &mut Thing_GetHas_ResPart {
        if let ::std::option::Option::Some(Thing_ResPart_oneof_res::thing_get_has_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Thing_ResPart_oneof_res::thing_get_has_res_part(Thing_GetHas_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(Thing_ResPart_oneof_res::thing_get_has_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_get_has_res_part(&mut self) -> Thing_GetHas_ResPart {
        if self.has_thing_get_has_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(Thing_ResPart_oneof_res::thing_get_has_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            Thing_GetHas_ResPart::new()
        }
    }

    // .typedb.protocol.Thing.GetRelations.ResPart thing_get_relations_res_part = 101;


    pub fn get_thing_get_relations_res_part(&self) -> &Thing_GetRelations_ResPart {
        match self.res {
            ::std::option::Option::Some(Thing_ResPart_oneof_res::thing_get_relations_res_part(ref v)) => v,
            _ => Thing_GetRelations_ResPart::default_instance(),
        }
    }
    pub fn clear_thing_get_relations_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_thing_get_relations_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Thing_ResPart_oneof_res::thing_get_relations_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_get_relations_res_part(&mut self, v: Thing_GetRelations_ResPart) {
        self.res = ::std::option::Option::Some(Thing_ResPart_oneof_res::thing_get_relations_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_get_relations_res_part(&mut self) -> &mut Thing_GetRelations_ResPart {
        if let ::std::option::Option::Some(Thing_ResPart_oneof_res::thing_get_relations_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Thing_ResPart_oneof_res::thing_get_relations_res_part(Thing_GetRelations_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(Thing_ResPart_oneof_res::thing_get_relations_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_get_relations_res_part(&mut self) -> Thing_GetRelations_ResPart {
        if self.has_thing_get_relations_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(Thing_ResPart_oneof_res::thing_get_relations_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            Thing_GetRelations_ResPart::new()
        }
    }

    // .typedb.protocol.Thing.GetPlaying.ResPart thing_get_playing_res_part = 102;


    pub fn get_thing_get_playing_res_part(&self) -> &Thing_GetPlaying_ResPart {
        match self.res {
            ::std::option::Option::Some(Thing_ResPart_oneof_res::thing_get_playing_res_part(ref v)) => v,
            _ => Thing_GetPlaying_ResPart::default_instance(),
        }
    }
    pub fn clear_thing_get_playing_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_thing_get_playing_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Thing_ResPart_oneof_res::thing_get_playing_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_get_playing_res_part(&mut self, v: Thing_GetPlaying_ResPart) {
        self.res = ::std::option::Option::Some(Thing_ResPart_oneof_res::thing_get_playing_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_get_playing_res_part(&mut self) -> &mut Thing_GetPlaying_ResPart {
        if let ::std::option::Option::Some(Thing_ResPart_oneof_res::thing_get_playing_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Thing_ResPart_oneof_res::thing_get_playing_res_part(Thing_GetPlaying_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(Thing_ResPart_oneof_res::thing_get_playing_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_get_playing_res_part(&mut self) -> Thing_GetPlaying_ResPart {
        if self.has_thing_get_playing_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(Thing_ResPart_oneof_res::thing_get_playing_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            Thing_GetPlaying_ResPart::new()
        }
    }

    // .typedb.protocol.Relation.GetPlayers.ResPart relation_get_players_res_part = 200;


    pub fn get_relation_get_players_res_part(&self) -> &Relation_GetPlayers_ResPart {
        match self.res {
            ::std::option::Option::Some(Thing_ResPart_oneof_res::relation_get_players_res_part(ref v)) => v,
            _ => Relation_GetPlayers_ResPart::default_instance(),
        }
    }
    pub fn clear_relation_get_players_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_relation_get_players_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Thing_ResPart_oneof_res::relation_get_players_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_relation_get_players_res_part(&mut self, v: Relation_GetPlayers_ResPart) {
        self.res = ::std::option::Option::Some(Thing_ResPart_oneof_res::relation_get_players_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_relation_get_players_res_part(&mut self) -> &mut Relation_GetPlayers_ResPart {
        if let ::std::option::Option::Some(Thing_ResPart_oneof_res::relation_get_players_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Thing_ResPart_oneof_res::relation_get_players_res_part(Relation_GetPlayers_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(Thing_ResPart_oneof_res::relation_get_players_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_relation_get_players_res_part(&mut self) -> Relation_GetPlayers_ResPart {
        if self.has_relation_get_players_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(Thing_ResPart_oneof_res::relation_get_players_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            Relation_GetPlayers_ResPart::new()
        }
    }

    // .typedb.protocol.Relation.GetPlayersByRoleType.ResPart relation_get_players_by_role_type_res_part = 201;


    pub fn get_relation_get_players_by_role_type_res_part(&self) -> &Relation_GetPlayersByRoleType_ResPart {
        match self.res {
            ::std::option::Option::Some(Thing_ResPart_oneof_res::relation_get_players_by_role_type_res_part(ref v)) => v,
            _ => Relation_GetPlayersByRoleType_ResPart::default_instance(),
        }
    }
    pub fn clear_relation_get_players_by_role_type_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_relation_get_players_by_role_type_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Thing_ResPart_oneof_res::relation_get_players_by_role_type_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_relation_get_players_by_role_type_res_part(&mut self, v: Relation_GetPlayersByRoleType_ResPart) {
        self.res = ::std::option::Option::Some(Thing_ResPart_oneof_res::relation_get_players_by_role_type_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_relation_get_players_by_role_type_res_part(&mut self) -> &mut Relation_GetPlayersByRoleType_ResPart {
        if let ::std::option::Option::Some(Thing_ResPart_oneof_res::relation_get_players_by_role_type_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Thing_ResPart_oneof_res::relation_get_players_by_role_type_res_part(Relation_GetPlayersByRoleType_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(Thing_ResPart_oneof_res::relation_get_players_by_role_type_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_relation_get_players_by_role_type_res_part(&mut self) -> Relation_GetPlayersByRoleType_ResPart {
        if self.has_relation_get_players_by_role_type_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(Thing_ResPart_oneof_res::relation_get_players_by_role_type_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            Relation_GetPlayersByRoleType_ResPart::new()
        }
    }

    // .typedb.protocol.Relation.GetRelating.ResPart relation_get_relating_res_part = 202;


    pub fn get_relation_get_relating_res_part(&self) -> &Relation_GetRelating_ResPart {
        match self.res {
            ::std::option::Option::Some(Thing_ResPart_oneof_res::relation_get_relating_res_part(ref v)) => v,
            _ => Relation_GetRelating_ResPart::default_instance(),
        }
    }
    pub fn clear_relation_get_relating_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_relation_get_relating_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Thing_ResPart_oneof_res::relation_get_relating_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_relation_get_relating_res_part(&mut self, v: Relation_GetRelating_ResPart) {
        self.res = ::std::option::Option::Some(Thing_ResPart_oneof_res::relation_get_relating_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_relation_get_relating_res_part(&mut self) -> &mut Relation_GetRelating_ResPart {
        if let ::std::option::Option::Some(Thing_ResPart_oneof_res::relation_get_relating_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Thing_ResPart_oneof_res::relation_get_relating_res_part(Relation_GetRelating_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(Thing_ResPart_oneof_res::relation_get_relating_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_relation_get_relating_res_part(&mut self) -> Relation_GetRelating_ResPart {
        if self.has_relation_get_relating_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(Thing_ResPart_oneof_res::relation_get_relating_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            Relation_GetRelating_ResPart::new()
        }
    }

    // .typedb.protocol.Attribute.GetOwners.ResPart attribute_get_owners_res_part = 300;


    pub fn get_attribute_get_owners_res_part(&self) -> &Attribute_GetOwners_ResPart {
        match self.res {
            ::std::option::Option::Some(Thing_ResPart_oneof_res::attribute_get_owners_res_part(ref v)) => v,
            _ => Attribute_GetOwners_ResPart::default_instance(),
        }
    }
    pub fn clear_attribute_get_owners_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_attribute_get_owners_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Thing_ResPart_oneof_res::attribute_get_owners_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_attribute_get_owners_res_part(&mut self, v: Attribute_GetOwners_ResPart) {
        self.res = ::std::option::Option::Some(Thing_ResPart_oneof_res::attribute_get_owners_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_attribute_get_owners_res_part(&mut self) -> &mut Attribute_GetOwners_ResPart {
        if let ::std::option::Option::Some(Thing_ResPart_oneof_res::attribute_get_owners_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Thing_ResPart_oneof_res::attribute_get_owners_res_part(Attribute_GetOwners_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(Thing_ResPart_oneof_res::attribute_get_owners_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_attribute_get_owners_res_part(&mut self) -> Attribute_GetOwners_ResPart {
        if self.has_attribute_get_owners_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(Thing_ResPart_oneof_res::attribute_get_owners_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            Attribute_GetOwners_ResPart::new()
        }
    }
}

impl ::protobuf::Message for Thing_ResPart {
    fn is_initialized(&self) -> bool {
        if let Some(Thing_ResPart_oneof_res::thing_get_has_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Thing_ResPart_oneof_res::thing_get_relations_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Thing_ResPart_oneof_res::thing_get_playing_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Thing_ResPart_oneof_res::relation_get_players_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Thing_ResPart_oneof_res::relation_get_players_by_role_type_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Thing_ResPart_oneof_res::relation_get_relating_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Thing_ResPart_oneof_res::attribute_get_owners_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                100 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Thing_ResPart_oneof_res::thing_get_has_res_part(is.read_message()?));
                },
                101 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Thing_ResPart_oneof_res::thing_get_relations_res_part(is.read_message()?));
                },
                102 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Thing_ResPart_oneof_res::thing_get_playing_res_part(is.read_message()?));
                },
                200 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Thing_ResPart_oneof_res::relation_get_players_res_part(is.read_message()?));
                },
                201 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Thing_ResPart_oneof_res::relation_get_players_by_role_type_res_part(is.read_message()?));
                },
                202 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Thing_ResPart_oneof_res::relation_get_relating_res_part(is.read_message()?));
                },
                300 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Thing_ResPart_oneof_res::attribute_get_owners_res_part(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &Thing_ResPart_oneof_res::thing_get_has_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Thing_ResPart_oneof_res::thing_get_relations_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Thing_ResPart_oneof_res::thing_get_playing_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Thing_ResPart_oneof_res::relation_get_players_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Thing_ResPart_oneof_res::relation_get_players_by_role_type_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Thing_ResPart_oneof_res::relation_get_relating_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Thing_ResPart_oneof_res::attribute_get_owners_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &Thing_ResPart_oneof_res::thing_get_has_res_part(ref v) => {
                    os.write_tag(100, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Thing_ResPart_oneof_res::thing_get_relations_res_part(ref v) => {
                    os.write_tag(101, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Thing_ResPart_oneof_res::thing_get_playing_res_part(ref v) => {
                    os.write_tag(102, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Thing_ResPart_oneof_res::relation_get_players_res_part(ref v) => {
                    os.write_tag(200, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Thing_ResPart_oneof_res::relation_get_players_by_role_type_res_part(ref v) => {
                    os.write_tag(201, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Thing_ResPart_oneof_res::relation_get_relating_res_part(ref v) => {
                    os.write_tag(202, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Thing_ResPart_oneof_res::attribute_get_owners_res_part(ref v) => {
                    os.write_tag(300, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing_ResPart {
        Thing_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Thing_GetHas_ResPart>(
                    "thing_get_has_res_part",
                    Thing_ResPart::has_thing_get_has_res_part,
                    Thing_ResPart::get_thing_get_has_res_part,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Thing_GetRelations_ResPart>(
                    "thing_get_relations_res_part",
                    Thing_ResPart::has_thing_get_relations_res_part,
                    Thing_ResPart::get_thing_get_relations_res_part,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Thing_GetPlaying_ResPart>(
                    "thing_get_playing_res_part",
                    Thing_ResPart::has_thing_get_playing_res_part,
                    Thing_ResPart::get_thing_get_playing_res_part,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Relation_GetPlayers_ResPart>(
                    "relation_get_players_res_part",
                    Thing_ResPart::has_relation_get_players_res_part,
                    Thing_ResPart::get_relation_get_players_res_part,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Relation_GetPlayersByRoleType_ResPart>(
                    "relation_get_players_by_role_type_res_part",
                    Thing_ResPart::has_relation_get_players_by_role_type_res_part,
                    Thing_ResPart::get_relation_get_players_by_role_type_res_part,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Relation_GetRelating_ResPart>(
                    "relation_get_relating_res_part",
                    Thing_ResPart::has_relation_get_relating_res_part,
                    Thing_ResPart::get_relation_get_relating_res_part,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Attribute_GetOwners_ResPart>(
                    "attribute_get_owners_res_part",
                    Thing_ResPart::has_attribute_get_owners_res_part,
                    Thing_ResPart::get_attribute_get_owners_res_part,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Thing_ResPart>(
                    "Thing_ResPart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing_ResPart {
        static mut instance: ::protobuf::lazy::Lazy<Thing_ResPart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing_ResPart,
        };
        unsafe {
            instance.get(Thing_ResPart::new)
        }
    }
}

impl ::protobuf::Clear for Thing_ResPart {
    fn clear(&mut self) {
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing_Delete {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing_Delete {
    fn default() -> &'a Thing_Delete {
        <Thing_Delete as ::protobuf::Message>::default_instance()
    }
}

impl Thing_Delete {
    pub fn new() -> Thing_Delete {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Thing_Delete {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing_Delete {
        Thing_Delete::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Thing_Delete>(
                    "Thing_Delete",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing_Delete {
        static mut instance: ::protobuf::lazy::Lazy<Thing_Delete> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing_Delete,
        };
        unsafe {
            instance.get(Thing_Delete::new)
        }
    }
}

impl ::protobuf::Clear for Thing_Delete {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing_Delete {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing_Delete {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing_Delete_Req {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing_Delete_Req {
    fn default() -> &'a Thing_Delete_Req {
        <Thing_Delete_Req as ::protobuf::Message>::default_instance()
    }
}

impl Thing_Delete_Req {
    pub fn new() -> Thing_Delete_Req {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Thing_Delete_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing_Delete_Req {
        Thing_Delete_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Thing_Delete_Req>(
                    "Thing_Delete_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing_Delete_Req {
        static mut instance: ::protobuf::lazy::Lazy<Thing_Delete_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing_Delete_Req,
        };
        unsafe {
            instance.get(Thing_Delete_Req::new)
        }
    }
}

impl ::protobuf::Clear for Thing_Delete_Req {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing_Delete_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing_Delete_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing_Delete_Res {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing_Delete_Res {
    fn default() -> &'a Thing_Delete_Res {
        <Thing_Delete_Res as ::protobuf::Message>::default_instance()
    }
}

impl Thing_Delete_Res {
    pub fn new() -> Thing_Delete_Res {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Thing_Delete_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing_Delete_Res {
        Thing_Delete_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Thing_Delete_Res>(
                    "Thing_Delete_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing_Delete_Res {
        static mut instance: ::protobuf::lazy::Lazy<Thing_Delete_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing_Delete_Res,
        };
        unsafe {
            instance.get(Thing_Delete_Res::new)
        }
    }
}

impl ::protobuf::Clear for Thing_Delete_Res {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing_Delete_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing_Delete_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing_GetType {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing_GetType {
    fn default() -> &'a Thing_GetType {
        <Thing_GetType as ::protobuf::Message>::default_instance()
    }
}

impl Thing_GetType {
    pub fn new() -> Thing_GetType {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Thing_GetType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing_GetType {
        Thing_GetType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Thing_GetType>(
                    "Thing_GetType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing_GetType {
        static mut instance: ::protobuf::lazy::Lazy<Thing_GetType> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing_GetType,
        };
        unsafe {
            instance.get(Thing_GetType::new)
        }
    }
}

impl ::protobuf::Clear for Thing_GetType {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing_GetType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing_GetType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing_GetType_Req {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing_GetType_Req {
    fn default() -> &'a Thing_GetType_Req {
        <Thing_GetType_Req as ::protobuf::Message>::default_instance()
    }
}

impl Thing_GetType_Req {
    pub fn new() -> Thing_GetType_Req {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Thing_GetType_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing_GetType_Req {
        Thing_GetType_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Thing_GetType_Req>(
                    "Thing_GetType_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing_GetType_Req {
        static mut instance: ::protobuf::lazy::Lazy<Thing_GetType_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing_GetType_Req,
        };
        unsafe {
            instance.get(Thing_GetType_Req::new)
        }
    }
}

impl ::protobuf::Clear for Thing_GetType_Req {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing_GetType_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing_GetType_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing_GetType_Res {
    // message fields
    pub thing_type: ::protobuf::SingularPtrField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing_GetType_Res {
    fn default() -> &'a Thing_GetType_Res {
        <Thing_GetType_Res as ::protobuf::Message>::default_instance()
    }
}

impl Thing_GetType_Res {
    pub fn new() -> Thing_GetType_Res {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Type thing_type = 1;


    pub fn get_thing_type(&self) -> &Type {
        self.thing_type.as_ref().unwrap_or_else(|| Type::default_instance())
    }
    pub fn clear_thing_type(&mut self) {
        self.thing_type.clear();
    }

    pub fn has_thing_type(&self) -> bool {
        self.thing_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thing_type(&mut self, v: Type) {
        self.thing_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thing_type(&mut self) -> &mut Type {
        if self.thing_type.is_none() {
            self.thing_type.set_default();
        }
        self.thing_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_thing_type(&mut self) -> Type {
        self.thing_type.take().unwrap_or_else(|| Type::new())
    }
}

impl ::protobuf::Message for Thing_GetType_Res {
    fn is_initialized(&self) -> bool {
        for v in &self.thing_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.thing_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.thing_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.thing_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing_GetType_Res {
        Thing_GetType_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "thing_type",
                    |m: &Thing_GetType_Res| { &m.thing_type },
                    |m: &mut Thing_GetType_Res| { &mut m.thing_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Thing_GetType_Res>(
                    "Thing_GetType_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing_GetType_Res {
        static mut instance: ::protobuf::lazy::Lazy<Thing_GetType_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing_GetType_Res,
        };
        unsafe {
            instance.get(Thing_GetType_Res::new)
        }
    }
}

impl ::protobuf::Clear for Thing_GetType_Res {
    fn clear(&mut self) {
        self.thing_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing_GetType_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing_GetType_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing_SetHas {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing_SetHas {
    fn default() -> &'a Thing_SetHas {
        <Thing_SetHas as ::protobuf::Message>::default_instance()
    }
}

impl Thing_SetHas {
    pub fn new() -> Thing_SetHas {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Thing_SetHas {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing_SetHas {
        Thing_SetHas::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Thing_SetHas>(
                    "Thing_SetHas",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing_SetHas {
        static mut instance: ::protobuf::lazy::Lazy<Thing_SetHas> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing_SetHas,
        };
        unsafe {
            instance.get(Thing_SetHas::new)
        }
    }
}

impl ::protobuf::Clear for Thing_SetHas {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing_SetHas {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing_SetHas {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing_SetHas_Req {
    // message fields
    pub attribute: ::protobuf::SingularPtrField<Thing>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing_SetHas_Req {
    fn default() -> &'a Thing_SetHas_Req {
        <Thing_SetHas_Req as ::protobuf::Message>::default_instance()
    }
}

impl Thing_SetHas_Req {
    pub fn new() -> Thing_SetHas_Req {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Thing attribute = 1;


    pub fn get_attribute(&self) -> &Thing {
        self.attribute.as_ref().unwrap_or_else(|| Thing::default_instance())
    }
    pub fn clear_attribute(&mut self) {
        self.attribute.clear();
    }

    pub fn has_attribute(&self) -> bool {
        self.attribute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attribute(&mut self, v: Thing) {
        self.attribute = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attribute(&mut self) -> &mut Thing {
        if self.attribute.is_none() {
            self.attribute.set_default();
        }
        self.attribute.as_mut().unwrap()
    }

    // Take field
    pub fn take_attribute(&mut self) -> Thing {
        self.attribute.take().unwrap_or_else(|| Thing::new())
    }
}

impl ::protobuf::Message for Thing_SetHas_Req {
    fn is_initialized(&self) -> bool {
        for v in &self.attribute {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attribute)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.attribute.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.attribute.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing_SetHas_Req {
        Thing_SetHas_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Thing>>(
                    "attribute",
                    |m: &Thing_SetHas_Req| { &m.attribute },
                    |m: &mut Thing_SetHas_Req| { &mut m.attribute },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Thing_SetHas_Req>(
                    "Thing_SetHas_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing_SetHas_Req {
        static mut instance: ::protobuf::lazy::Lazy<Thing_SetHas_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing_SetHas_Req,
        };
        unsafe {
            instance.get(Thing_SetHas_Req::new)
        }
    }
}

impl ::protobuf::Clear for Thing_SetHas_Req {
    fn clear(&mut self) {
        self.attribute.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing_SetHas_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing_SetHas_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing_SetHas_Res {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing_SetHas_Res {
    fn default() -> &'a Thing_SetHas_Res {
        <Thing_SetHas_Res as ::protobuf::Message>::default_instance()
    }
}

impl Thing_SetHas_Res {
    pub fn new() -> Thing_SetHas_Res {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Thing_SetHas_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing_SetHas_Res {
        Thing_SetHas_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Thing_SetHas_Res>(
                    "Thing_SetHas_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing_SetHas_Res {
        static mut instance: ::protobuf::lazy::Lazy<Thing_SetHas_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing_SetHas_Res,
        };
        unsafe {
            instance.get(Thing_SetHas_Res::new)
        }
    }
}

impl ::protobuf::Clear for Thing_SetHas_Res {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing_SetHas_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing_SetHas_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing_UnsetHas {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing_UnsetHas {
    fn default() -> &'a Thing_UnsetHas {
        <Thing_UnsetHas as ::protobuf::Message>::default_instance()
    }
}

impl Thing_UnsetHas {
    pub fn new() -> Thing_UnsetHas {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Thing_UnsetHas {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing_UnsetHas {
        Thing_UnsetHas::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Thing_UnsetHas>(
                    "Thing_UnsetHas",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing_UnsetHas {
        static mut instance: ::protobuf::lazy::Lazy<Thing_UnsetHas> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing_UnsetHas,
        };
        unsafe {
            instance.get(Thing_UnsetHas::new)
        }
    }
}

impl ::protobuf::Clear for Thing_UnsetHas {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing_UnsetHas {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing_UnsetHas {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing_UnsetHas_Req {
    // message fields
    pub attribute: ::protobuf::SingularPtrField<Thing>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing_UnsetHas_Req {
    fn default() -> &'a Thing_UnsetHas_Req {
        <Thing_UnsetHas_Req as ::protobuf::Message>::default_instance()
    }
}

impl Thing_UnsetHas_Req {
    pub fn new() -> Thing_UnsetHas_Req {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Thing attribute = 1;


    pub fn get_attribute(&self) -> &Thing {
        self.attribute.as_ref().unwrap_or_else(|| Thing::default_instance())
    }
    pub fn clear_attribute(&mut self) {
        self.attribute.clear();
    }

    pub fn has_attribute(&self) -> bool {
        self.attribute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attribute(&mut self, v: Thing) {
        self.attribute = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attribute(&mut self) -> &mut Thing {
        if self.attribute.is_none() {
            self.attribute.set_default();
        }
        self.attribute.as_mut().unwrap()
    }

    // Take field
    pub fn take_attribute(&mut self) -> Thing {
        self.attribute.take().unwrap_or_else(|| Thing::new())
    }
}

impl ::protobuf::Message for Thing_UnsetHas_Req {
    fn is_initialized(&self) -> bool {
        for v in &self.attribute {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attribute)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.attribute.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.attribute.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing_UnsetHas_Req {
        Thing_UnsetHas_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Thing>>(
                    "attribute",
                    |m: &Thing_UnsetHas_Req| { &m.attribute },
                    |m: &mut Thing_UnsetHas_Req| { &mut m.attribute },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Thing_UnsetHas_Req>(
                    "Thing_UnsetHas_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing_UnsetHas_Req {
        static mut instance: ::protobuf::lazy::Lazy<Thing_UnsetHas_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing_UnsetHas_Req,
        };
        unsafe {
            instance.get(Thing_UnsetHas_Req::new)
        }
    }
}

impl ::protobuf::Clear for Thing_UnsetHas_Req {
    fn clear(&mut self) {
        self.attribute.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing_UnsetHas_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing_UnsetHas_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing_UnsetHas_Res {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing_UnsetHas_Res {
    fn default() -> &'a Thing_UnsetHas_Res {
        <Thing_UnsetHas_Res as ::protobuf::Message>::default_instance()
    }
}

impl Thing_UnsetHas_Res {
    pub fn new() -> Thing_UnsetHas_Res {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Thing_UnsetHas_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing_UnsetHas_Res {
        Thing_UnsetHas_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Thing_UnsetHas_Res>(
                    "Thing_UnsetHas_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing_UnsetHas_Res {
        static mut instance: ::protobuf::lazy::Lazy<Thing_UnsetHas_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing_UnsetHas_Res,
        };
        unsafe {
            instance.get(Thing_UnsetHas_Res::new)
        }
    }
}

impl ::protobuf::Clear for Thing_UnsetHas_Res {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing_UnsetHas_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing_UnsetHas_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing_GetHas {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing_GetHas {
    fn default() -> &'a Thing_GetHas {
        <Thing_GetHas as ::protobuf::Message>::default_instance()
    }
}

impl Thing_GetHas {
    pub fn new() -> Thing_GetHas {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Thing_GetHas {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing_GetHas {
        Thing_GetHas::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Thing_GetHas>(
                    "Thing_GetHas",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing_GetHas {
        static mut instance: ::protobuf::lazy::Lazy<Thing_GetHas> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing_GetHas,
        };
        unsafe {
            instance.get(Thing_GetHas::new)
        }
    }
}

impl ::protobuf::Clear for Thing_GetHas {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing_GetHas {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing_GetHas {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing_GetHas_Req {
    // message fields
    pub attribute_types: ::protobuf::RepeatedField<Type>,
    pub keys_only: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing_GetHas_Req {
    fn default() -> &'a Thing_GetHas_Req {
        <Thing_GetHas_Req as ::protobuf::Message>::default_instance()
    }
}

impl Thing_GetHas_Req {
    pub fn new() -> Thing_GetHas_Req {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.Type attribute_types = 1;


    pub fn get_attribute_types(&self) -> &[Type] {
        &self.attribute_types
    }
    pub fn clear_attribute_types(&mut self) {
        self.attribute_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_attribute_types(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.attribute_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attribute_types(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.attribute_types
    }

    // Take field
    pub fn take_attribute_types(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.attribute_types, ::protobuf::RepeatedField::new())
    }

    // bool keys_only = 2;


    pub fn get_keys_only(&self) -> bool {
        self.keys_only
    }
    pub fn clear_keys_only(&mut self) {
        self.keys_only = false;
    }

    // Param is passed by value, moved
    pub fn set_keys_only(&mut self, v: bool) {
        self.keys_only = v;
    }
}

impl ::protobuf::Message for Thing_GetHas_Req {
    fn is_initialized(&self) -> bool {
        for v in &self.attribute_types {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attribute_types)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.keys_only = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.attribute_types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.keys_only != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.attribute_types {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.keys_only != false {
            os.write_bool(2, self.keys_only)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing_GetHas_Req {
        Thing_GetHas_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "attribute_types",
                    |m: &Thing_GetHas_Req| { &m.attribute_types },
                    |m: &mut Thing_GetHas_Req| { &mut m.attribute_types },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "keys_only",
                    |m: &Thing_GetHas_Req| { &m.keys_only },
                    |m: &mut Thing_GetHas_Req| { &mut m.keys_only },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Thing_GetHas_Req>(
                    "Thing_GetHas_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing_GetHas_Req {
        static mut instance: ::protobuf::lazy::Lazy<Thing_GetHas_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing_GetHas_Req,
        };
        unsafe {
            instance.get(Thing_GetHas_Req::new)
        }
    }
}

impl ::protobuf::Clear for Thing_GetHas_Req {
    fn clear(&mut self) {
        self.attribute_types.clear();
        self.keys_only = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing_GetHas_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing_GetHas_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing_GetHas_ResPart {
    // message fields
    pub attributes: ::protobuf::RepeatedField<Thing>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing_GetHas_ResPart {
    fn default() -> &'a Thing_GetHas_ResPart {
        <Thing_GetHas_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl Thing_GetHas_ResPart {
    pub fn new() -> Thing_GetHas_ResPart {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.Thing attributes = 1;


    pub fn get_attributes(&self) -> &[Thing] {
        &self.attributes
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::protobuf::RepeatedField<Thing>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes(&mut self) -> &mut ::protobuf::RepeatedField<Thing> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::protobuf::RepeatedField<Thing> {
        ::std::mem::replace(&mut self.attributes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Thing_GetHas_ResPart {
    fn is_initialized(&self) -> bool {
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attributes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.attributes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing_GetHas_ResPart {
        Thing_GetHas_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Thing>>(
                    "attributes",
                    |m: &Thing_GetHas_ResPart| { &m.attributes },
                    |m: &mut Thing_GetHas_ResPart| { &mut m.attributes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Thing_GetHas_ResPart>(
                    "Thing_GetHas_ResPart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing_GetHas_ResPart {
        static mut instance: ::protobuf::lazy::Lazy<Thing_GetHas_ResPart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing_GetHas_ResPart,
        };
        unsafe {
            instance.get(Thing_GetHas_ResPart::new)
        }
    }
}

impl ::protobuf::Clear for Thing_GetHas_ResPart {
    fn clear(&mut self) {
        self.attributes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing_GetHas_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing_GetHas_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing_GetPlaying {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing_GetPlaying {
    fn default() -> &'a Thing_GetPlaying {
        <Thing_GetPlaying as ::protobuf::Message>::default_instance()
    }
}

impl Thing_GetPlaying {
    pub fn new() -> Thing_GetPlaying {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Thing_GetPlaying {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing_GetPlaying {
        Thing_GetPlaying::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Thing_GetPlaying>(
                    "Thing_GetPlaying",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing_GetPlaying {
        static mut instance: ::protobuf::lazy::Lazy<Thing_GetPlaying> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing_GetPlaying,
        };
        unsafe {
            instance.get(Thing_GetPlaying::new)
        }
    }
}

impl ::protobuf::Clear for Thing_GetPlaying {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing_GetPlaying {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing_GetPlaying {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing_GetPlaying_Req {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing_GetPlaying_Req {
    fn default() -> &'a Thing_GetPlaying_Req {
        <Thing_GetPlaying_Req as ::protobuf::Message>::default_instance()
    }
}

impl Thing_GetPlaying_Req {
    pub fn new() -> Thing_GetPlaying_Req {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Thing_GetPlaying_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing_GetPlaying_Req {
        Thing_GetPlaying_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Thing_GetPlaying_Req>(
                    "Thing_GetPlaying_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing_GetPlaying_Req {
        static mut instance: ::protobuf::lazy::Lazy<Thing_GetPlaying_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing_GetPlaying_Req,
        };
        unsafe {
            instance.get(Thing_GetPlaying_Req::new)
        }
    }
}

impl ::protobuf::Clear for Thing_GetPlaying_Req {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing_GetPlaying_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing_GetPlaying_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing_GetPlaying_ResPart {
    // message fields
    pub role_types: ::protobuf::RepeatedField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing_GetPlaying_ResPart {
    fn default() -> &'a Thing_GetPlaying_ResPart {
        <Thing_GetPlaying_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl Thing_GetPlaying_ResPart {
    pub fn new() -> Thing_GetPlaying_ResPart {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.Type role_types = 1;


    pub fn get_role_types(&self) -> &[Type] {
        &self.role_types
    }
    pub fn clear_role_types(&mut self) {
        self.role_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_role_types(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.role_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_role_types(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.role_types
    }

    // Take field
    pub fn take_role_types(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.role_types, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Thing_GetPlaying_ResPart {
    fn is_initialized(&self) -> bool {
        for v in &self.role_types {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.role_types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.role_types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.role_types {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing_GetPlaying_ResPart {
        Thing_GetPlaying_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "role_types",
                    |m: &Thing_GetPlaying_ResPart| { &m.role_types },
                    |m: &mut Thing_GetPlaying_ResPart| { &mut m.role_types },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Thing_GetPlaying_ResPart>(
                    "Thing_GetPlaying_ResPart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing_GetPlaying_ResPart {
        static mut instance: ::protobuf::lazy::Lazy<Thing_GetPlaying_ResPart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing_GetPlaying_ResPart,
        };
        unsafe {
            instance.get(Thing_GetPlaying_ResPart::new)
        }
    }
}

impl ::protobuf::Clear for Thing_GetPlaying_ResPart {
    fn clear(&mut self) {
        self.role_types.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing_GetPlaying_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing_GetPlaying_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing_GetRelations {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing_GetRelations {
    fn default() -> &'a Thing_GetRelations {
        <Thing_GetRelations as ::protobuf::Message>::default_instance()
    }
}

impl Thing_GetRelations {
    pub fn new() -> Thing_GetRelations {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Thing_GetRelations {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing_GetRelations {
        Thing_GetRelations::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Thing_GetRelations>(
                    "Thing_GetRelations",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing_GetRelations {
        static mut instance: ::protobuf::lazy::Lazy<Thing_GetRelations> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing_GetRelations,
        };
        unsafe {
            instance.get(Thing_GetRelations::new)
        }
    }
}

impl ::protobuf::Clear for Thing_GetRelations {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing_GetRelations {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing_GetRelations {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing_GetRelations_Req {
    // message fields
    pub role_types: ::protobuf::RepeatedField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing_GetRelations_Req {
    fn default() -> &'a Thing_GetRelations_Req {
        <Thing_GetRelations_Req as ::protobuf::Message>::default_instance()
    }
}

impl Thing_GetRelations_Req {
    pub fn new() -> Thing_GetRelations_Req {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.Type role_types = 1;


    pub fn get_role_types(&self) -> &[Type] {
        &self.role_types
    }
    pub fn clear_role_types(&mut self) {
        self.role_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_role_types(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.role_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_role_types(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.role_types
    }

    // Take field
    pub fn take_role_types(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.role_types, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Thing_GetRelations_Req {
    fn is_initialized(&self) -> bool {
        for v in &self.role_types {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.role_types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.role_types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.role_types {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing_GetRelations_Req {
        Thing_GetRelations_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "role_types",
                    |m: &Thing_GetRelations_Req| { &m.role_types },
                    |m: &mut Thing_GetRelations_Req| { &mut m.role_types },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Thing_GetRelations_Req>(
                    "Thing_GetRelations_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing_GetRelations_Req {
        static mut instance: ::protobuf::lazy::Lazy<Thing_GetRelations_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing_GetRelations_Req,
        };
        unsafe {
            instance.get(Thing_GetRelations_Req::new)
        }
    }
}

impl ::protobuf::Clear for Thing_GetRelations_Req {
    fn clear(&mut self) {
        self.role_types.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing_GetRelations_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing_GetRelations_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Thing_GetRelations_ResPart {
    // message fields
    pub relations: ::protobuf::RepeatedField<Thing>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Thing_GetRelations_ResPart {
    fn default() -> &'a Thing_GetRelations_ResPart {
        <Thing_GetRelations_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl Thing_GetRelations_ResPart {
    pub fn new() -> Thing_GetRelations_ResPart {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.Thing relations = 1;


    pub fn get_relations(&self) -> &[Thing] {
        &self.relations
    }
    pub fn clear_relations(&mut self) {
        self.relations.clear();
    }

    // Param is passed by value, moved
    pub fn set_relations(&mut self, v: ::protobuf::RepeatedField<Thing>) {
        self.relations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_relations(&mut self) -> &mut ::protobuf::RepeatedField<Thing> {
        &mut self.relations
    }

    // Take field
    pub fn take_relations(&mut self) -> ::protobuf::RepeatedField<Thing> {
        ::std::mem::replace(&mut self.relations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Thing_GetRelations_ResPart {
    fn is_initialized(&self) -> bool {
        for v in &self.relations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.relations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.relations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.relations {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Thing_GetRelations_ResPart {
        Thing_GetRelations_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Thing>>(
                    "relations",
                    |m: &Thing_GetRelations_ResPart| { &m.relations },
                    |m: &mut Thing_GetRelations_ResPart| { &mut m.relations },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Thing_GetRelations_ResPart>(
                    "Thing_GetRelations_ResPart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Thing_GetRelations_ResPart {
        static mut instance: ::protobuf::lazy::Lazy<Thing_GetRelations_ResPart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Thing_GetRelations_ResPart,
        };
        unsafe {
            instance.get(Thing_GetRelations_ResPart::new)
        }
    }
}

impl ::protobuf::Clear for Thing_GetRelations_ResPart {
    fn clear(&mut self) {
        self.relations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Thing_GetRelations_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Thing_GetRelations_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Relation {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Relation {
    fn default() -> &'a Relation {
        <Relation as ::protobuf::Message>::default_instance()
    }
}

impl Relation {
    pub fn new() -> Relation {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Relation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Relation {
        Relation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Relation>(
                    "Relation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Relation {
        static mut instance: ::protobuf::lazy::Lazy<Relation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Relation,
        };
        unsafe {
            instance.get(Relation::new)
        }
    }
}

impl ::protobuf::Clear for Relation {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Relation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Relation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Relation_AddPlayer {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Relation_AddPlayer {
    fn default() -> &'a Relation_AddPlayer {
        <Relation_AddPlayer as ::protobuf::Message>::default_instance()
    }
}

impl Relation_AddPlayer {
    pub fn new() -> Relation_AddPlayer {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Relation_AddPlayer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Relation_AddPlayer {
        Relation_AddPlayer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Relation_AddPlayer>(
                    "Relation_AddPlayer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Relation_AddPlayer {
        static mut instance: ::protobuf::lazy::Lazy<Relation_AddPlayer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Relation_AddPlayer,
        };
        unsafe {
            instance.get(Relation_AddPlayer::new)
        }
    }
}

impl ::protobuf::Clear for Relation_AddPlayer {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Relation_AddPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Relation_AddPlayer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Relation_AddPlayer_Req {
    // message fields
    pub role_type: ::protobuf::SingularPtrField<Type>,
    pub player: ::protobuf::SingularPtrField<Thing>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Relation_AddPlayer_Req {
    fn default() -> &'a Relation_AddPlayer_Req {
        <Relation_AddPlayer_Req as ::protobuf::Message>::default_instance()
    }
}

impl Relation_AddPlayer_Req {
    pub fn new() -> Relation_AddPlayer_Req {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Type role_type = 1;


    pub fn get_role_type(&self) -> &Type {
        self.role_type.as_ref().unwrap_or_else(|| Type::default_instance())
    }
    pub fn clear_role_type(&mut self) {
        self.role_type.clear();
    }

    pub fn has_role_type(&self) -> bool {
        self.role_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_type(&mut self, v: Type) {
        self.role_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role_type(&mut self) -> &mut Type {
        if self.role_type.is_none() {
            self.role_type.set_default();
        }
        self.role_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_role_type(&mut self) -> Type {
        self.role_type.take().unwrap_or_else(|| Type::new())
    }

    // .typedb.protocol.Thing player = 2;


    pub fn get_player(&self) -> &Thing {
        self.player.as_ref().unwrap_or_else(|| Thing::default_instance())
    }
    pub fn clear_player(&mut self) {
        self.player.clear();
    }

    pub fn has_player(&self) -> bool {
        self.player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player(&mut self, v: Thing) {
        self.player = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player(&mut self) -> &mut Thing {
        if self.player.is_none() {
            self.player.set_default();
        }
        self.player.as_mut().unwrap()
    }

    // Take field
    pub fn take_player(&mut self) -> Thing {
        self.player.take().unwrap_or_else(|| Thing::new())
    }
}

impl ::protobuf::Message for Relation_AddPlayer_Req {
    fn is_initialized(&self) -> bool {
        for v in &self.role_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.player {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.role_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.player)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.role_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.player.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.role_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.player.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Relation_AddPlayer_Req {
        Relation_AddPlayer_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "role_type",
                    |m: &Relation_AddPlayer_Req| { &m.role_type },
                    |m: &mut Relation_AddPlayer_Req| { &mut m.role_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Thing>>(
                    "player",
                    |m: &Relation_AddPlayer_Req| { &m.player },
                    |m: &mut Relation_AddPlayer_Req| { &mut m.player },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Relation_AddPlayer_Req>(
                    "Relation_AddPlayer_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Relation_AddPlayer_Req {
        static mut instance: ::protobuf::lazy::Lazy<Relation_AddPlayer_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Relation_AddPlayer_Req,
        };
        unsafe {
            instance.get(Relation_AddPlayer_Req::new)
        }
    }
}

impl ::protobuf::Clear for Relation_AddPlayer_Req {
    fn clear(&mut self) {
        self.role_type.clear();
        self.player.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Relation_AddPlayer_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Relation_AddPlayer_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Relation_AddPlayer_Res {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Relation_AddPlayer_Res {
    fn default() -> &'a Relation_AddPlayer_Res {
        <Relation_AddPlayer_Res as ::protobuf::Message>::default_instance()
    }
}

impl Relation_AddPlayer_Res {
    pub fn new() -> Relation_AddPlayer_Res {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Relation_AddPlayer_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Relation_AddPlayer_Res {
        Relation_AddPlayer_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Relation_AddPlayer_Res>(
                    "Relation_AddPlayer_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Relation_AddPlayer_Res {
        static mut instance: ::protobuf::lazy::Lazy<Relation_AddPlayer_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Relation_AddPlayer_Res,
        };
        unsafe {
            instance.get(Relation_AddPlayer_Res::new)
        }
    }
}

impl ::protobuf::Clear for Relation_AddPlayer_Res {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Relation_AddPlayer_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Relation_AddPlayer_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Relation_RemovePlayer {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Relation_RemovePlayer {
    fn default() -> &'a Relation_RemovePlayer {
        <Relation_RemovePlayer as ::protobuf::Message>::default_instance()
    }
}

impl Relation_RemovePlayer {
    pub fn new() -> Relation_RemovePlayer {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Relation_RemovePlayer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Relation_RemovePlayer {
        Relation_RemovePlayer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Relation_RemovePlayer>(
                    "Relation_RemovePlayer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Relation_RemovePlayer {
        static mut instance: ::protobuf::lazy::Lazy<Relation_RemovePlayer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Relation_RemovePlayer,
        };
        unsafe {
            instance.get(Relation_RemovePlayer::new)
        }
    }
}

impl ::protobuf::Clear for Relation_RemovePlayer {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Relation_RemovePlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Relation_RemovePlayer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Relation_RemovePlayer_Req {
    // message fields
    pub role_type: ::protobuf::SingularPtrField<Type>,
    pub player: ::protobuf::SingularPtrField<Thing>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Relation_RemovePlayer_Req {
    fn default() -> &'a Relation_RemovePlayer_Req {
        <Relation_RemovePlayer_Req as ::protobuf::Message>::default_instance()
    }
}

impl Relation_RemovePlayer_Req {
    pub fn new() -> Relation_RemovePlayer_Req {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Type role_type = 1;


    pub fn get_role_type(&self) -> &Type {
        self.role_type.as_ref().unwrap_or_else(|| Type::default_instance())
    }
    pub fn clear_role_type(&mut self) {
        self.role_type.clear();
    }

    pub fn has_role_type(&self) -> bool {
        self.role_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_type(&mut self, v: Type) {
        self.role_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role_type(&mut self) -> &mut Type {
        if self.role_type.is_none() {
            self.role_type.set_default();
        }
        self.role_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_role_type(&mut self) -> Type {
        self.role_type.take().unwrap_or_else(|| Type::new())
    }

    // .typedb.protocol.Thing player = 2;


    pub fn get_player(&self) -> &Thing {
        self.player.as_ref().unwrap_or_else(|| Thing::default_instance())
    }
    pub fn clear_player(&mut self) {
        self.player.clear();
    }

    pub fn has_player(&self) -> bool {
        self.player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player(&mut self, v: Thing) {
        self.player = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player(&mut self) -> &mut Thing {
        if self.player.is_none() {
            self.player.set_default();
        }
        self.player.as_mut().unwrap()
    }

    // Take field
    pub fn take_player(&mut self) -> Thing {
        self.player.take().unwrap_or_else(|| Thing::new())
    }
}

impl ::protobuf::Message for Relation_RemovePlayer_Req {
    fn is_initialized(&self) -> bool {
        for v in &self.role_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.player {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.role_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.player)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.role_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.player.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.role_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.player.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Relation_RemovePlayer_Req {
        Relation_RemovePlayer_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "role_type",
                    |m: &Relation_RemovePlayer_Req| { &m.role_type },
                    |m: &mut Relation_RemovePlayer_Req| { &mut m.role_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Thing>>(
                    "player",
                    |m: &Relation_RemovePlayer_Req| { &m.player },
                    |m: &mut Relation_RemovePlayer_Req| { &mut m.player },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Relation_RemovePlayer_Req>(
                    "Relation_RemovePlayer_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Relation_RemovePlayer_Req {
        static mut instance: ::protobuf::lazy::Lazy<Relation_RemovePlayer_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Relation_RemovePlayer_Req,
        };
        unsafe {
            instance.get(Relation_RemovePlayer_Req::new)
        }
    }
}

impl ::protobuf::Clear for Relation_RemovePlayer_Req {
    fn clear(&mut self) {
        self.role_type.clear();
        self.player.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Relation_RemovePlayer_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Relation_RemovePlayer_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Relation_RemovePlayer_Res {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Relation_RemovePlayer_Res {
    fn default() -> &'a Relation_RemovePlayer_Res {
        <Relation_RemovePlayer_Res as ::protobuf::Message>::default_instance()
    }
}

impl Relation_RemovePlayer_Res {
    pub fn new() -> Relation_RemovePlayer_Res {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Relation_RemovePlayer_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Relation_RemovePlayer_Res {
        Relation_RemovePlayer_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Relation_RemovePlayer_Res>(
                    "Relation_RemovePlayer_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Relation_RemovePlayer_Res {
        static mut instance: ::protobuf::lazy::Lazy<Relation_RemovePlayer_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Relation_RemovePlayer_Res,
        };
        unsafe {
            instance.get(Relation_RemovePlayer_Res::new)
        }
    }
}

impl ::protobuf::Clear for Relation_RemovePlayer_Res {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Relation_RemovePlayer_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Relation_RemovePlayer_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Relation_GetPlayers {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Relation_GetPlayers {
    fn default() -> &'a Relation_GetPlayers {
        <Relation_GetPlayers as ::protobuf::Message>::default_instance()
    }
}

impl Relation_GetPlayers {
    pub fn new() -> Relation_GetPlayers {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Relation_GetPlayers {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Relation_GetPlayers {
        Relation_GetPlayers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Relation_GetPlayers>(
                    "Relation_GetPlayers",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Relation_GetPlayers {
        static mut instance: ::protobuf::lazy::Lazy<Relation_GetPlayers> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Relation_GetPlayers,
        };
        unsafe {
            instance.get(Relation_GetPlayers::new)
        }
    }
}

impl ::protobuf::Clear for Relation_GetPlayers {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Relation_GetPlayers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Relation_GetPlayers {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Relation_GetPlayers_Req {
    // message fields
    pub role_types: ::protobuf::RepeatedField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Relation_GetPlayers_Req {
    fn default() -> &'a Relation_GetPlayers_Req {
        <Relation_GetPlayers_Req as ::protobuf::Message>::default_instance()
    }
}

impl Relation_GetPlayers_Req {
    pub fn new() -> Relation_GetPlayers_Req {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.Type role_types = 1;


    pub fn get_role_types(&self) -> &[Type] {
        &self.role_types
    }
    pub fn clear_role_types(&mut self) {
        self.role_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_role_types(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.role_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_role_types(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.role_types
    }

    // Take field
    pub fn take_role_types(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.role_types, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Relation_GetPlayers_Req {
    fn is_initialized(&self) -> bool {
        for v in &self.role_types {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.role_types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.role_types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.role_types {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Relation_GetPlayers_Req {
        Relation_GetPlayers_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "role_types",
                    |m: &Relation_GetPlayers_Req| { &m.role_types },
                    |m: &mut Relation_GetPlayers_Req| { &mut m.role_types },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Relation_GetPlayers_Req>(
                    "Relation_GetPlayers_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Relation_GetPlayers_Req {
        static mut instance: ::protobuf::lazy::Lazy<Relation_GetPlayers_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Relation_GetPlayers_Req,
        };
        unsafe {
            instance.get(Relation_GetPlayers_Req::new)
        }
    }
}

impl ::protobuf::Clear for Relation_GetPlayers_Req {
    fn clear(&mut self) {
        self.role_types.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Relation_GetPlayers_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Relation_GetPlayers_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Relation_GetPlayers_ResPart {
    // message fields
    pub things: ::protobuf::RepeatedField<Thing>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Relation_GetPlayers_ResPart {
    fn default() -> &'a Relation_GetPlayers_ResPart {
        <Relation_GetPlayers_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl Relation_GetPlayers_ResPart {
    pub fn new() -> Relation_GetPlayers_ResPart {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.Thing things = 1;


    pub fn get_things(&self) -> &[Thing] {
        &self.things
    }
    pub fn clear_things(&mut self) {
        self.things.clear();
    }

    // Param is passed by value, moved
    pub fn set_things(&mut self, v: ::protobuf::RepeatedField<Thing>) {
        self.things = v;
    }

    // Mutable pointer to the field.
    pub fn mut_things(&mut self) -> &mut ::protobuf::RepeatedField<Thing> {
        &mut self.things
    }

    // Take field
    pub fn take_things(&mut self) -> ::protobuf::RepeatedField<Thing> {
        ::std::mem::replace(&mut self.things, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Relation_GetPlayers_ResPart {
    fn is_initialized(&self) -> bool {
        for v in &self.things {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.things)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.things {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.things {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Relation_GetPlayers_ResPart {
        Relation_GetPlayers_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Thing>>(
                    "things",
                    |m: &Relation_GetPlayers_ResPart| { &m.things },
                    |m: &mut Relation_GetPlayers_ResPart| { &mut m.things },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Relation_GetPlayers_ResPart>(
                    "Relation_GetPlayers_ResPart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Relation_GetPlayers_ResPart {
        static mut instance: ::protobuf::lazy::Lazy<Relation_GetPlayers_ResPart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Relation_GetPlayers_ResPart,
        };
        unsafe {
            instance.get(Relation_GetPlayers_ResPart::new)
        }
    }
}

impl ::protobuf::Clear for Relation_GetPlayers_ResPart {
    fn clear(&mut self) {
        self.things.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Relation_GetPlayers_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Relation_GetPlayers_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Relation_GetPlayersByRoleType {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Relation_GetPlayersByRoleType {
    fn default() -> &'a Relation_GetPlayersByRoleType {
        <Relation_GetPlayersByRoleType as ::protobuf::Message>::default_instance()
    }
}

impl Relation_GetPlayersByRoleType {
    pub fn new() -> Relation_GetPlayersByRoleType {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Relation_GetPlayersByRoleType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Relation_GetPlayersByRoleType {
        Relation_GetPlayersByRoleType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Relation_GetPlayersByRoleType>(
                    "Relation_GetPlayersByRoleType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Relation_GetPlayersByRoleType {
        static mut instance: ::protobuf::lazy::Lazy<Relation_GetPlayersByRoleType> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Relation_GetPlayersByRoleType,
        };
        unsafe {
            instance.get(Relation_GetPlayersByRoleType::new)
        }
    }
}

impl ::protobuf::Clear for Relation_GetPlayersByRoleType {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Relation_GetPlayersByRoleType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Relation_GetPlayersByRoleType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Relation_GetPlayersByRoleType_RoleTypeWithPlayer {
    // message fields
    pub role_type: ::protobuf::SingularPtrField<Type>,
    pub player: ::protobuf::SingularPtrField<Thing>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Relation_GetPlayersByRoleType_RoleTypeWithPlayer {
    fn default() -> &'a Relation_GetPlayersByRoleType_RoleTypeWithPlayer {
        <Relation_GetPlayersByRoleType_RoleTypeWithPlayer as ::protobuf::Message>::default_instance()
    }
}

impl Relation_GetPlayersByRoleType_RoleTypeWithPlayer {
    pub fn new() -> Relation_GetPlayersByRoleType_RoleTypeWithPlayer {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Type role_type = 1;


    pub fn get_role_type(&self) -> &Type {
        self.role_type.as_ref().unwrap_or_else(|| Type::default_instance())
    }
    pub fn clear_role_type(&mut self) {
        self.role_type.clear();
    }

    pub fn has_role_type(&self) -> bool {
        self.role_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_type(&mut self, v: Type) {
        self.role_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role_type(&mut self) -> &mut Type {
        if self.role_type.is_none() {
            self.role_type.set_default();
        }
        self.role_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_role_type(&mut self) -> Type {
        self.role_type.take().unwrap_or_else(|| Type::new())
    }

    // .typedb.protocol.Thing player = 2;


    pub fn get_player(&self) -> &Thing {
        self.player.as_ref().unwrap_or_else(|| Thing::default_instance())
    }
    pub fn clear_player(&mut self) {
        self.player.clear();
    }

    pub fn has_player(&self) -> bool {
        self.player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player(&mut self, v: Thing) {
        self.player = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player(&mut self) -> &mut Thing {
        if self.player.is_none() {
            self.player.set_default();
        }
        self.player.as_mut().unwrap()
    }

    // Take field
    pub fn take_player(&mut self) -> Thing {
        self.player.take().unwrap_or_else(|| Thing::new())
    }
}

impl ::protobuf::Message for Relation_GetPlayersByRoleType_RoleTypeWithPlayer {
    fn is_initialized(&self) -> bool {
        for v in &self.role_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.player {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.role_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.player)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.role_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.player.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.role_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.player.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Relation_GetPlayersByRoleType_RoleTypeWithPlayer {
        Relation_GetPlayersByRoleType_RoleTypeWithPlayer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "role_type",
                    |m: &Relation_GetPlayersByRoleType_RoleTypeWithPlayer| { &m.role_type },
                    |m: &mut Relation_GetPlayersByRoleType_RoleTypeWithPlayer| { &mut m.role_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Thing>>(
                    "player",
                    |m: &Relation_GetPlayersByRoleType_RoleTypeWithPlayer| { &m.player },
                    |m: &mut Relation_GetPlayersByRoleType_RoleTypeWithPlayer| { &mut m.player },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Relation_GetPlayersByRoleType_RoleTypeWithPlayer>(
                    "Relation_GetPlayersByRoleType_RoleTypeWithPlayer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Relation_GetPlayersByRoleType_RoleTypeWithPlayer {
        static mut instance: ::protobuf::lazy::Lazy<Relation_GetPlayersByRoleType_RoleTypeWithPlayer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Relation_GetPlayersByRoleType_RoleTypeWithPlayer,
        };
        unsafe {
            instance.get(Relation_GetPlayersByRoleType_RoleTypeWithPlayer::new)
        }
    }
}

impl ::protobuf::Clear for Relation_GetPlayersByRoleType_RoleTypeWithPlayer {
    fn clear(&mut self) {
        self.role_type.clear();
        self.player.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Relation_GetPlayersByRoleType_RoleTypeWithPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Relation_GetPlayersByRoleType_RoleTypeWithPlayer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Relation_GetPlayersByRoleType_Req {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Relation_GetPlayersByRoleType_Req {
    fn default() -> &'a Relation_GetPlayersByRoleType_Req {
        <Relation_GetPlayersByRoleType_Req as ::protobuf::Message>::default_instance()
    }
}

impl Relation_GetPlayersByRoleType_Req {
    pub fn new() -> Relation_GetPlayersByRoleType_Req {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Relation_GetPlayersByRoleType_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Relation_GetPlayersByRoleType_Req {
        Relation_GetPlayersByRoleType_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Relation_GetPlayersByRoleType_Req>(
                    "Relation_GetPlayersByRoleType_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Relation_GetPlayersByRoleType_Req {
        static mut instance: ::protobuf::lazy::Lazy<Relation_GetPlayersByRoleType_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Relation_GetPlayersByRoleType_Req,
        };
        unsafe {
            instance.get(Relation_GetPlayersByRoleType_Req::new)
        }
    }
}

impl ::protobuf::Clear for Relation_GetPlayersByRoleType_Req {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Relation_GetPlayersByRoleType_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Relation_GetPlayersByRoleType_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Relation_GetPlayersByRoleType_ResPart {
    // message fields
    pub role_types_with_players: ::protobuf::RepeatedField<Relation_GetPlayersByRoleType_RoleTypeWithPlayer>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Relation_GetPlayersByRoleType_ResPart {
    fn default() -> &'a Relation_GetPlayersByRoleType_ResPart {
        <Relation_GetPlayersByRoleType_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl Relation_GetPlayersByRoleType_ResPart {
    pub fn new() -> Relation_GetPlayersByRoleType_ResPart {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.Relation.GetPlayersByRoleType.RoleTypeWithPlayer role_types_with_players = 1;


    pub fn get_role_types_with_players(&self) -> &[Relation_GetPlayersByRoleType_RoleTypeWithPlayer] {
        &self.role_types_with_players
    }
    pub fn clear_role_types_with_players(&mut self) {
        self.role_types_with_players.clear();
    }

    // Param is passed by value, moved
    pub fn set_role_types_with_players(&mut self, v: ::protobuf::RepeatedField<Relation_GetPlayersByRoleType_RoleTypeWithPlayer>) {
        self.role_types_with_players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_role_types_with_players(&mut self) -> &mut ::protobuf::RepeatedField<Relation_GetPlayersByRoleType_RoleTypeWithPlayer> {
        &mut self.role_types_with_players
    }

    // Take field
    pub fn take_role_types_with_players(&mut self) -> ::protobuf::RepeatedField<Relation_GetPlayersByRoleType_RoleTypeWithPlayer> {
        ::std::mem::replace(&mut self.role_types_with_players, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Relation_GetPlayersByRoleType_ResPart {
    fn is_initialized(&self) -> bool {
        for v in &self.role_types_with_players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.role_types_with_players)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.role_types_with_players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.role_types_with_players {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Relation_GetPlayersByRoleType_ResPart {
        Relation_GetPlayersByRoleType_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Relation_GetPlayersByRoleType_RoleTypeWithPlayer>>(
                    "role_types_with_players",
                    |m: &Relation_GetPlayersByRoleType_ResPart| { &m.role_types_with_players },
                    |m: &mut Relation_GetPlayersByRoleType_ResPart| { &mut m.role_types_with_players },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Relation_GetPlayersByRoleType_ResPart>(
                    "Relation_GetPlayersByRoleType_ResPart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Relation_GetPlayersByRoleType_ResPart {
        static mut instance: ::protobuf::lazy::Lazy<Relation_GetPlayersByRoleType_ResPart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Relation_GetPlayersByRoleType_ResPart,
        };
        unsafe {
            instance.get(Relation_GetPlayersByRoleType_ResPart::new)
        }
    }
}

impl ::protobuf::Clear for Relation_GetPlayersByRoleType_ResPart {
    fn clear(&mut self) {
        self.role_types_with_players.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Relation_GetPlayersByRoleType_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Relation_GetPlayersByRoleType_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Relation_GetRelating {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Relation_GetRelating {
    fn default() -> &'a Relation_GetRelating {
        <Relation_GetRelating as ::protobuf::Message>::default_instance()
    }
}

impl Relation_GetRelating {
    pub fn new() -> Relation_GetRelating {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Relation_GetRelating {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Relation_GetRelating {
        Relation_GetRelating::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Relation_GetRelating>(
                    "Relation_GetRelating",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Relation_GetRelating {
        static mut instance: ::protobuf::lazy::Lazy<Relation_GetRelating> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Relation_GetRelating,
        };
        unsafe {
            instance.get(Relation_GetRelating::new)
        }
    }
}

impl ::protobuf::Clear for Relation_GetRelating {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Relation_GetRelating {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Relation_GetRelating {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Relation_GetRelating_Req {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Relation_GetRelating_Req {
    fn default() -> &'a Relation_GetRelating_Req {
        <Relation_GetRelating_Req as ::protobuf::Message>::default_instance()
    }
}

impl Relation_GetRelating_Req {
    pub fn new() -> Relation_GetRelating_Req {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Relation_GetRelating_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Relation_GetRelating_Req {
        Relation_GetRelating_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Relation_GetRelating_Req>(
                    "Relation_GetRelating_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Relation_GetRelating_Req {
        static mut instance: ::protobuf::lazy::Lazy<Relation_GetRelating_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Relation_GetRelating_Req,
        };
        unsafe {
            instance.get(Relation_GetRelating_Req::new)
        }
    }
}

impl ::protobuf::Clear for Relation_GetRelating_Req {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Relation_GetRelating_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Relation_GetRelating_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Relation_GetRelating_ResPart {
    // message fields
    pub role_types: ::protobuf::RepeatedField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Relation_GetRelating_ResPart {
    fn default() -> &'a Relation_GetRelating_ResPart {
        <Relation_GetRelating_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl Relation_GetRelating_ResPart {
    pub fn new() -> Relation_GetRelating_ResPart {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.Type role_types = 1;


    pub fn get_role_types(&self) -> &[Type] {
        &self.role_types
    }
    pub fn clear_role_types(&mut self) {
        self.role_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_role_types(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.role_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_role_types(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.role_types
    }

    // Take field
    pub fn take_role_types(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.role_types, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Relation_GetRelating_ResPart {
    fn is_initialized(&self) -> bool {
        for v in &self.role_types {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.role_types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.role_types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.role_types {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Relation_GetRelating_ResPart {
        Relation_GetRelating_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "role_types",
                    |m: &Relation_GetRelating_ResPart| { &m.role_types },
                    |m: &mut Relation_GetRelating_ResPart| { &mut m.role_types },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Relation_GetRelating_ResPart>(
                    "Relation_GetRelating_ResPart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Relation_GetRelating_ResPart {
        static mut instance: ::protobuf::lazy::Lazy<Relation_GetRelating_ResPart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Relation_GetRelating_ResPart,
        };
        unsafe {
            instance.get(Relation_GetRelating_ResPart::new)
        }
    }
}

impl ::protobuf::Clear for Relation_GetRelating_ResPart {
    fn clear(&mut self) {
        self.role_types.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Relation_GetRelating_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Relation_GetRelating_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Attribute {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Attribute {
    fn default() -> &'a Attribute {
        <Attribute as ::protobuf::Message>::default_instance()
    }
}

impl Attribute {
    pub fn new() -> Attribute {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Attribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Attribute {
        Attribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Attribute>(
                    "Attribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Attribute {
        static mut instance: ::protobuf::lazy::Lazy<Attribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Attribute,
        };
        unsafe {
            instance.get(Attribute::new)
        }
    }
}

impl ::protobuf::Clear for Attribute {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Attribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Attribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Attribute_Value {
    // message oneof groups
    pub value: ::std::option::Option<Attribute_Value_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Attribute_Value {
    fn default() -> &'a Attribute_Value {
        <Attribute_Value as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Attribute_Value_oneof_value {
    string(::std::string::String),
    boolean(bool),
    long(i64),
    double(f64),
    date_time(i64),
}

impl Attribute_Value {
    pub fn new() -> Attribute_Value {
        ::std::default::Default::default()
    }

    // string string = 1;


    pub fn get_string(&self) -> &str {
        match self.value {
            ::std::option::Option::Some(Attribute_Value_oneof_value::string(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_string(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_string(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Attribute_Value_oneof_value::string(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(Attribute_Value_oneof_value::string(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Attribute_Value_oneof_value::string(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Attribute_Value_oneof_value::string(::std::string::String::new()));
        }
        match self.value {
            ::std::option::Option::Some(Attribute_Value_oneof_value::string(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string(&mut self) -> ::std::string::String {
        if self.has_string() {
            match self.value.take() {
                ::std::option::Option::Some(Attribute_Value_oneof_value::string(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bool boolean = 2;


    pub fn get_boolean(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Attribute_Value_oneof_value::boolean(v)) => v,
            _ => false,
        }
    }
    pub fn clear_boolean(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_boolean(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Attribute_Value_oneof_value::boolean(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_boolean(&mut self, v: bool) {
        self.value = ::std::option::Option::Some(Attribute_Value_oneof_value::boolean(v))
    }

    // int64 long = 3;


    pub fn get_long(&self) -> i64 {
        match self.value {
            ::std::option::Option::Some(Attribute_Value_oneof_value::long(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_long(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_long(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Attribute_Value_oneof_value::long(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_long(&mut self, v: i64) {
        self.value = ::std::option::Option::Some(Attribute_Value_oneof_value::long(v))
    }

    // double double = 4;


    pub fn get_double(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(Attribute_Value_oneof_value::double(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_double(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_double(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Attribute_Value_oneof_value::double(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_double(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(Attribute_Value_oneof_value::double(v))
    }

    // int64 date_time = 5;


    pub fn get_date_time(&self) -> i64 {
        match self.value {
            ::std::option::Option::Some(Attribute_Value_oneof_value::date_time(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_date_time(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_date_time(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Attribute_Value_oneof_value::date_time(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_date_time(&mut self, v: i64) {
        self.value = ::std::option::Option::Some(Attribute_Value_oneof_value::date_time(v))
    }
}

impl ::protobuf::Message for Attribute_Value {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Attribute_Value_oneof_value::string(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Attribute_Value_oneof_value::boolean(is.read_bool()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Attribute_Value_oneof_value::long(is.read_int64()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Attribute_Value_oneof_value::double(is.read_double()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Attribute_Value_oneof_value::date_time(is.read_int64()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Attribute_Value_oneof_value::string(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &Attribute_Value_oneof_value::boolean(v) => {
                    my_size += 2;
                },
                &Attribute_Value_oneof_value::long(v) => {
                    my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Attribute_Value_oneof_value::double(v) => {
                    my_size += 9;
                },
                &Attribute_Value_oneof_value::date_time(v) => {
                    my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Attribute_Value_oneof_value::string(ref v) => {
                    os.write_string(1, v)?;
                },
                &Attribute_Value_oneof_value::boolean(v) => {
                    os.write_bool(2, v)?;
                },
                &Attribute_Value_oneof_value::long(v) => {
                    os.write_int64(3, v)?;
                },
                &Attribute_Value_oneof_value::double(v) => {
                    os.write_double(4, v)?;
                },
                &Attribute_Value_oneof_value::date_time(v) => {
                    os.write_int64(5, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Attribute_Value {
        Attribute_Value::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "string",
                    Attribute_Value::has_string,
                    Attribute_Value::get_string,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                    "boolean",
                    Attribute_Value::has_boolean,
                    Attribute_Value::get_boolean,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                    "long",
                    Attribute_Value::has_long,
                    Attribute_Value::get_long,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor::<_>(
                    "double",
                    Attribute_Value::has_double,
                    Attribute_Value::get_double,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                    "date_time",
                    Attribute_Value::has_date_time,
                    Attribute_Value::get_date_time,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Attribute_Value>(
                    "Attribute_Value",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Attribute_Value {
        static mut instance: ::protobuf::lazy::Lazy<Attribute_Value> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Attribute_Value,
        };
        unsafe {
            instance.get(Attribute_Value::new)
        }
    }
}

impl ::protobuf::Clear for Attribute_Value {
    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Attribute_Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Attribute_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Attribute_GetOwners {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Attribute_GetOwners {
    fn default() -> &'a Attribute_GetOwners {
        <Attribute_GetOwners as ::protobuf::Message>::default_instance()
    }
}

impl Attribute_GetOwners {
    pub fn new() -> Attribute_GetOwners {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Attribute_GetOwners {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Attribute_GetOwners {
        Attribute_GetOwners::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Attribute_GetOwners>(
                    "Attribute_GetOwners",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Attribute_GetOwners {
        static mut instance: ::protobuf::lazy::Lazy<Attribute_GetOwners> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Attribute_GetOwners,
        };
        unsafe {
            instance.get(Attribute_GetOwners::new)
        }
    }
}

impl ::protobuf::Clear for Attribute_GetOwners {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Attribute_GetOwners {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Attribute_GetOwners {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Attribute_GetOwners_Req {
    // message oneof groups
    pub filter: ::std::option::Option<Attribute_GetOwners_Req_oneof_filter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Attribute_GetOwners_Req {
    fn default() -> &'a Attribute_GetOwners_Req {
        <Attribute_GetOwners_Req as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Attribute_GetOwners_Req_oneof_filter {
    thing_type(Type),
}

impl Attribute_GetOwners_Req {
    pub fn new() -> Attribute_GetOwners_Req {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Type thing_type = 1;


    pub fn get_thing_type(&self) -> &Type {
        match self.filter {
            ::std::option::Option::Some(Attribute_GetOwners_Req_oneof_filter::thing_type(ref v)) => v,
            _ => Type::default_instance(),
        }
    }
    pub fn clear_thing_type(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_thing_type(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(Attribute_GetOwners_Req_oneof_filter::thing_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_type(&mut self, v: Type) {
        self.filter = ::std::option::Option::Some(Attribute_GetOwners_Req_oneof_filter::thing_type(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_type(&mut self) -> &mut Type {
        if let ::std::option::Option::Some(Attribute_GetOwners_Req_oneof_filter::thing_type(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(Attribute_GetOwners_Req_oneof_filter::thing_type(Type::new()));
        }
        match self.filter {
            ::std::option::Option::Some(Attribute_GetOwners_Req_oneof_filter::thing_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_type(&mut self) -> Type {
        if self.has_thing_type() {
            match self.filter.take() {
                ::std::option::Option::Some(Attribute_GetOwners_Req_oneof_filter::thing_type(v)) => v,
                _ => panic!(),
            }
        } else {
            Type::new()
        }
    }
}

impl ::protobuf::Message for Attribute_GetOwners_Req {
    fn is_initialized(&self) -> bool {
        if let Some(Attribute_GetOwners_Req_oneof_filter::thing_type(ref v)) = self.filter {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(Attribute_GetOwners_Req_oneof_filter::thing_type(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.filter {
            match v {
                &Attribute_GetOwners_Req_oneof_filter::thing_type(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.filter {
            match v {
                &Attribute_GetOwners_Req_oneof_filter::thing_type(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Attribute_GetOwners_Req {
        Attribute_GetOwners_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type>(
                    "thing_type",
                    Attribute_GetOwners_Req::has_thing_type,
                    Attribute_GetOwners_Req::get_thing_type,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Attribute_GetOwners_Req>(
                    "Attribute_GetOwners_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Attribute_GetOwners_Req {
        static mut instance: ::protobuf::lazy::Lazy<Attribute_GetOwners_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Attribute_GetOwners_Req,
        };
        unsafe {
            instance.get(Attribute_GetOwners_Req::new)
        }
    }
}

impl ::protobuf::Clear for Attribute_GetOwners_Req {
    fn clear(&mut self) {
        self.filter = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Attribute_GetOwners_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Attribute_GetOwners_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Attribute_GetOwners_ResPart {
    // message fields
    pub things: ::protobuf::RepeatedField<Thing>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Attribute_GetOwners_ResPart {
    fn default() -> &'a Attribute_GetOwners_ResPart {
        <Attribute_GetOwners_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl Attribute_GetOwners_ResPart {
    pub fn new() -> Attribute_GetOwners_ResPart {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.Thing things = 1;


    pub fn get_things(&self) -> &[Thing] {
        &self.things
    }
    pub fn clear_things(&mut self) {
        self.things.clear();
    }

    // Param is passed by value, moved
    pub fn set_things(&mut self, v: ::protobuf::RepeatedField<Thing>) {
        self.things = v;
    }

    // Mutable pointer to the field.
    pub fn mut_things(&mut self) -> &mut ::protobuf::RepeatedField<Thing> {
        &mut self.things
    }

    // Take field
    pub fn take_things(&mut self) -> ::protobuf::RepeatedField<Thing> {
        ::std::mem::replace(&mut self.things, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Attribute_GetOwners_ResPart {
    fn is_initialized(&self) -> bool {
        for v in &self.things {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.things)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.things {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.things {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Attribute_GetOwners_ResPart {
        Attribute_GetOwners_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Thing>>(
                    "things",
                    |m: &Attribute_GetOwners_ResPart| { &m.things },
                    |m: &mut Attribute_GetOwners_ResPart| { &mut m.things },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Attribute_GetOwners_ResPart>(
                    "Attribute_GetOwners_ResPart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Attribute_GetOwners_ResPart {
        static mut instance: ::protobuf::lazy::Lazy<Attribute_GetOwners_ResPart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Attribute_GetOwners_ResPart,
        };
        unsafe {
            instance.get(Attribute_GetOwners_ResPart::new)
        }
    }
}

impl ::protobuf::Clear for Attribute_GetOwners_ResPart {
    fn clear(&mut self) {
        self.things.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Attribute_GetOwners_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Attribute_GetOwners_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type {
    // message fields
    pub label: ::std::string::String,
    pub scope: ::std::string::String,
    pub encoding: Type_Encoding,
    pub value_type: AttributeType_ValueType,
    pub root: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type {
    fn default() -> &'a Type {
        <Type as ::protobuf::Message>::default_instance()
    }
}

impl Type {
    pub fn new() -> Type {
        ::std::default::Default::default()
    }

    // string label = 1;


    pub fn get_label(&self) -> &str {
        &self.label
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        &mut self.label
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label, ::std::string::String::new())
    }

    // string scope = 2;


    pub fn get_scope(&self) -> &str {
        &self.scope
    }
    pub fn clear_scope(&mut self) {
        self.scope.clear();
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: ::std::string::String) {
        self.scope = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scope(&mut self) -> &mut ::std::string::String {
        &mut self.scope
    }

    // Take field
    pub fn take_scope(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.scope, ::std::string::String::new())
    }

    // .typedb.protocol.Type.Encoding encoding = 3;


    pub fn get_encoding(&self) -> Type_Encoding {
        self.encoding
    }
    pub fn clear_encoding(&mut self) {
        self.encoding = Type_Encoding::THING_TYPE;
    }

    // Param is passed by value, moved
    pub fn set_encoding(&mut self, v: Type_Encoding) {
        self.encoding = v;
    }

    // .typedb.protocol.AttributeType.ValueType value_type = 4;


    pub fn get_value_type(&self) -> AttributeType_ValueType {
        self.value_type
    }
    pub fn clear_value_type(&mut self) {
        self.value_type = AttributeType_ValueType::OBJECT;
    }

    // Param is passed by value, moved
    pub fn set_value_type(&mut self, v: AttributeType_ValueType) {
        self.value_type = v;
    }

    // bool root = 5;


    pub fn get_root(&self) -> bool {
        self.root
    }
    pub fn clear_root(&mut self) {
        self.root = false;
    }

    // Param is passed by value, moved
    pub fn set_root(&mut self, v: bool) {
        self.root = v;
    }
}

impl ::protobuf::Message for Type {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.scope)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.encoding, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.root = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.label);
        }
        if !self.scope.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.scope);
        }
        if self.encoding != Type_Encoding::THING_TYPE {
            my_size += ::protobuf::rt::enum_size(3, self.encoding);
        }
        if self.value_type != AttributeType_ValueType::OBJECT {
            my_size += ::protobuf::rt::enum_size(4, self.value_type);
        }
        if self.root != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.label.is_empty() {
            os.write_string(1, &self.label)?;
        }
        if !self.scope.is_empty() {
            os.write_string(2, &self.scope)?;
        }
        if self.encoding != Type_Encoding::THING_TYPE {
            os.write_enum(3, self.encoding.value())?;
        }
        if self.value_type != AttributeType_ValueType::OBJECT {
            os.write_enum(4, self.value_type.value())?;
        }
        if self.root != false {
            os.write_bool(5, self.root)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type {
        Type::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "label",
                    |m: &Type| { &m.label },
                    |m: &mut Type| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "scope",
                    |m: &Type| { &m.scope },
                    |m: &mut Type| { &mut m.scope },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Type_Encoding>>(
                    "encoding",
                    |m: &Type| { &m.encoding },
                    |m: &mut Type| { &mut m.encoding },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AttributeType_ValueType>>(
                    "value_type",
                    |m: &Type| { &m.value_type },
                    |m: &mut Type| { &mut m.value_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "root",
                    |m: &Type| { &m.root },
                    |m: &mut Type| { &mut m.root },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Type>(
                    "Type",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type {
        static mut instance: ::protobuf::lazy::Lazy<Type> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type,
        };
        unsafe {
            instance.get(Type::new)
        }
    }
}

impl ::protobuf::Clear for Type {
    fn clear(&mut self) {
        self.label.clear();
        self.scope.clear();
        self.encoding = Type_Encoding::THING_TYPE;
        self.value_type = AttributeType_ValueType::OBJECT;
        self.root = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_Req {
    // message fields
    pub label: ::std::string::String,
    pub scope: ::std::string::String,
    // message oneof groups
    pub req: ::std::option::Option<Type_Req_oneof_req>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_Req {
    fn default() -> &'a Type_Req {
        <Type_Req as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Type_Req_oneof_req {
    type_delete_req(Type_Delete_Req),
    type_set_label_req(Type_SetLabel_Req),
    type_is_abstract_req(Type_IsAbstract_Req),
    type_get_supertype_req(Type_GetSupertype_Req),
    type_set_supertype_req(Type_SetSupertype_Req),
    type_get_supertypes_req(Type_GetSupertypes_Req),
    type_get_subtypes_req(Type_GetSubtypes_Req),
    role_type_get_relation_types_req(RoleType_GetRelationTypes_Req),
    role_type_get_players_req(RoleType_GetPlayers_Req),
    thing_type_get_instances_req(ThingType_GetInstances_Req),
    thing_type_set_abstract_req(ThingType_SetAbstract_Req),
    thing_type_unset_abstract_req(ThingType_UnsetAbstract_Req),
    thing_type_get_owns_req(ThingType_GetOwns_Req),
    thing_type_set_owns_req(ThingType_SetOwns_Req),
    thing_type_unset_owns_req(ThingType_UnsetOwns_Req),
    thing_type_get_plays_req(ThingType_GetPlays_Req),
    thing_type_set_plays_req(ThingType_SetPlays_Req),
    thing_type_unset_plays_req(ThingType_UnsetPlays_Req),
    entity_type_create_req(EntityType_Create_Req),
    relation_type_create_req(RelationType_Create_Req),
    relation_type_get_relates_for_role_label_req(RelationType_GetRelatesForRoleLabel_Req),
    relation_type_get_relates_req(RelationType_GetRelates_Req),
    relation_type_set_relates_req(RelationType_SetRelates_Req),
    relation_type_unset_relates_req(RelationType_UnsetRelates_Req),
    attribute_type_put_req(AttributeType_Put_Req),
    attribute_type_get_req(AttributeType_Get_Req),
    attribute_type_get_regex_req(AttributeType_GetRegex_Req),
    attribute_type_set_regex_req(AttributeType_SetRegex_Req),
    attribute_type_get_owners_req(AttributeType_GetOwners_Req),
}

impl Type_Req {
    pub fn new() -> Type_Req {
        ::std::default::Default::default()
    }

    // string label = 1;


    pub fn get_label(&self) -> &str {
        &self.label
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        &mut self.label
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label, ::std::string::String::new())
    }

    // string scope = 2;


    pub fn get_scope(&self) -> &str {
        &self.scope
    }
    pub fn clear_scope(&mut self) {
        self.scope.clear();
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: ::std::string::String) {
        self.scope = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scope(&mut self) -> &mut ::std::string::String {
        &mut self.scope
    }

    // Take field
    pub fn take_scope(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.scope, ::std::string::String::new())
    }

    // .typedb.protocol.Type.Delete.Req type_delete_req = 100;


    pub fn get_type_delete_req(&self) -> &Type_Delete_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::type_delete_req(ref v)) => v,
            _ => Type_Delete_Req::default_instance(),
        }
    }
    pub fn clear_type_delete_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_type_delete_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::type_delete_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_type_delete_req(&mut self, v: Type_Delete_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::type_delete_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_type_delete_req(&mut self) -> &mut Type_Delete_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::type_delete_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::type_delete_req(Type_Delete_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::type_delete_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_type_delete_req(&mut self) -> Type_Delete_Req {
        if self.has_type_delete_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::type_delete_req(v)) => v,
                _ => panic!(),
            }
        } else {
            Type_Delete_Req::new()
        }
    }

    // .typedb.protocol.Type.SetLabel.Req type_set_label_req = 101;


    pub fn get_type_set_label_req(&self) -> &Type_SetLabel_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::type_set_label_req(ref v)) => v,
            _ => Type_SetLabel_Req::default_instance(),
        }
    }
    pub fn clear_type_set_label_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_type_set_label_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::type_set_label_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_type_set_label_req(&mut self, v: Type_SetLabel_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::type_set_label_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_type_set_label_req(&mut self) -> &mut Type_SetLabel_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::type_set_label_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::type_set_label_req(Type_SetLabel_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::type_set_label_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_type_set_label_req(&mut self) -> Type_SetLabel_Req {
        if self.has_type_set_label_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::type_set_label_req(v)) => v,
                _ => panic!(),
            }
        } else {
            Type_SetLabel_Req::new()
        }
    }

    // .typedb.protocol.Type.IsAbstract.Req type_is_abstract_req = 102;


    pub fn get_type_is_abstract_req(&self) -> &Type_IsAbstract_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::type_is_abstract_req(ref v)) => v,
            _ => Type_IsAbstract_Req::default_instance(),
        }
    }
    pub fn clear_type_is_abstract_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_type_is_abstract_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::type_is_abstract_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_type_is_abstract_req(&mut self, v: Type_IsAbstract_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::type_is_abstract_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_type_is_abstract_req(&mut self) -> &mut Type_IsAbstract_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::type_is_abstract_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::type_is_abstract_req(Type_IsAbstract_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::type_is_abstract_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_type_is_abstract_req(&mut self) -> Type_IsAbstract_Req {
        if self.has_type_is_abstract_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::type_is_abstract_req(v)) => v,
                _ => panic!(),
            }
        } else {
            Type_IsAbstract_Req::new()
        }
    }

    // .typedb.protocol.Type.GetSupertype.Req type_get_supertype_req = 103;


    pub fn get_type_get_supertype_req(&self) -> &Type_GetSupertype_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::type_get_supertype_req(ref v)) => v,
            _ => Type_GetSupertype_Req::default_instance(),
        }
    }
    pub fn clear_type_get_supertype_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_type_get_supertype_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::type_get_supertype_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_type_get_supertype_req(&mut self, v: Type_GetSupertype_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::type_get_supertype_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_type_get_supertype_req(&mut self) -> &mut Type_GetSupertype_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::type_get_supertype_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::type_get_supertype_req(Type_GetSupertype_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::type_get_supertype_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_type_get_supertype_req(&mut self) -> Type_GetSupertype_Req {
        if self.has_type_get_supertype_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::type_get_supertype_req(v)) => v,
                _ => panic!(),
            }
        } else {
            Type_GetSupertype_Req::new()
        }
    }

    // .typedb.protocol.Type.SetSupertype.Req type_set_supertype_req = 104;


    pub fn get_type_set_supertype_req(&self) -> &Type_SetSupertype_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::type_set_supertype_req(ref v)) => v,
            _ => Type_SetSupertype_Req::default_instance(),
        }
    }
    pub fn clear_type_set_supertype_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_type_set_supertype_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::type_set_supertype_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_type_set_supertype_req(&mut self, v: Type_SetSupertype_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::type_set_supertype_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_type_set_supertype_req(&mut self) -> &mut Type_SetSupertype_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::type_set_supertype_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::type_set_supertype_req(Type_SetSupertype_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::type_set_supertype_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_type_set_supertype_req(&mut self) -> Type_SetSupertype_Req {
        if self.has_type_set_supertype_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::type_set_supertype_req(v)) => v,
                _ => panic!(),
            }
        } else {
            Type_SetSupertype_Req::new()
        }
    }

    // .typedb.protocol.Type.GetSupertypes.Req type_get_supertypes_req = 105;


    pub fn get_type_get_supertypes_req(&self) -> &Type_GetSupertypes_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::type_get_supertypes_req(ref v)) => v,
            _ => Type_GetSupertypes_Req::default_instance(),
        }
    }
    pub fn clear_type_get_supertypes_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_type_get_supertypes_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::type_get_supertypes_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_type_get_supertypes_req(&mut self, v: Type_GetSupertypes_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::type_get_supertypes_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_type_get_supertypes_req(&mut self) -> &mut Type_GetSupertypes_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::type_get_supertypes_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::type_get_supertypes_req(Type_GetSupertypes_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::type_get_supertypes_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_type_get_supertypes_req(&mut self) -> Type_GetSupertypes_Req {
        if self.has_type_get_supertypes_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::type_get_supertypes_req(v)) => v,
                _ => panic!(),
            }
        } else {
            Type_GetSupertypes_Req::new()
        }
    }

    // .typedb.protocol.Type.GetSubtypes.Req type_get_subtypes_req = 106;


    pub fn get_type_get_subtypes_req(&self) -> &Type_GetSubtypes_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::type_get_subtypes_req(ref v)) => v,
            _ => Type_GetSubtypes_Req::default_instance(),
        }
    }
    pub fn clear_type_get_subtypes_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_type_get_subtypes_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::type_get_subtypes_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_type_get_subtypes_req(&mut self, v: Type_GetSubtypes_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::type_get_subtypes_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_type_get_subtypes_req(&mut self) -> &mut Type_GetSubtypes_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::type_get_subtypes_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::type_get_subtypes_req(Type_GetSubtypes_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::type_get_subtypes_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_type_get_subtypes_req(&mut self) -> Type_GetSubtypes_Req {
        if self.has_type_get_subtypes_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::type_get_subtypes_req(v)) => v,
                _ => panic!(),
            }
        } else {
            Type_GetSubtypes_Req::new()
        }
    }

    // .typedb.protocol.RoleType.GetRelationTypes.Req role_type_get_relation_types_req = 200;


    pub fn get_role_type_get_relation_types_req(&self) -> &RoleType_GetRelationTypes_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::role_type_get_relation_types_req(ref v)) => v,
            _ => RoleType_GetRelationTypes_Req::default_instance(),
        }
    }
    pub fn clear_role_type_get_relation_types_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_role_type_get_relation_types_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::role_type_get_relation_types_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_role_type_get_relation_types_req(&mut self, v: RoleType_GetRelationTypes_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::role_type_get_relation_types_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_role_type_get_relation_types_req(&mut self) -> &mut RoleType_GetRelationTypes_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::role_type_get_relation_types_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::role_type_get_relation_types_req(RoleType_GetRelationTypes_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::role_type_get_relation_types_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_role_type_get_relation_types_req(&mut self) -> RoleType_GetRelationTypes_Req {
        if self.has_role_type_get_relation_types_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::role_type_get_relation_types_req(v)) => v,
                _ => panic!(),
            }
        } else {
            RoleType_GetRelationTypes_Req::new()
        }
    }

    // .typedb.protocol.RoleType.GetPlayers.Req role_type_get_players_req = 201;


    pub fn get_role_type_get_players_req(&self) -> &RoleType_GetPlayers_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::role_type_get_players_req(ref v)) => v,
            _ => RoleType_GetPlayers_Req::default_instance(),
        }
    }
    pub fn clear_role_type_get_players_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_role_type_get_players_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::role_type_get_players_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_role_type_get_players_req(&mut self, v: RoleType_GetPlayers_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::role_type_get_players_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_role_type_get_players_req(&mut self) -> &mut RoleType_GetPlayers_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::role_type_get_players_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::role_type_get_players_req(RoleType_GetPlayers_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::role_type_get_players_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_role_type_get_players_req(&mut self) -> RoleType_GetPlayers_Req {
        if self.has_role_type_get_players_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::role_type_get_players_req(v)) => v,
                _ => panic!(),
            }
        } else {
            RoleType_GetPlayers_Req::new()
        }
    }

    // .typedb.protocol.ThingType.GetInstances.Req thing_type_get_instances_req = 300;


    pub fn get_thing_type_get_instances_req(&self) -> &ThingType_GetInstances_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_get_instances_req(ref v)) => v,
            _ => ThingType_GetInstances_Req::default_instance(),
        }
    }
    pub fn clear_thing_type_get_instances_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_thing_type_get_instances_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_get_instances_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_type_get_instances_req(&mut self, v: ThingType_GetInstances_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_get_instances_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_type_get_instances_req(&mut self) -> &mut ThingType_GetInstances_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::thing_type_get_instances_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_get_instances_req(ThingType_GetInstances_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_get_instances_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_type_get_instances_req(&mut self) -> ThingType_GetInstances_Req {
        if self.has_thing_type_get_instances_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::thing_type_get_instances_req(v)) => v,
                _ => panic!(),
            }
        } else {
            ThingType_GetInstances_Req::new()
        }
    }

    // .typedb.protocol.ThingType.SetAbstract.Req thing_type_set_abstract_req = 301;


    pub fn get_thing_type_set_abstract_req(&self) -> &ThingType_SetAbstract_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_set_abstract_req(ref v)) => v,
            _ => ThingType_SetAbstract_Req::default_instance(),
        }
    }
    pub fn clear_thing_type_set_abstract_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_thing_type_set_abstract_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_set_abstract_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_type_set_abstract_req(&mut self, v: ThingType_SetAbstract_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_set_abstract_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_type_set_abstract_req(&mut self) -> &mut ThingType_SetAbstract_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::thing_type_set_abstract_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_set_abstract_req(ThingType_SetAbstract_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_set_abstract_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_type_set_abstract_req(&mut self) -> ThingType_SetAbstract_Req {
        if self.has_thing_type_set_abstract_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::thing_type_set_abstract_req(v)) => v,
                _ => panic!(),
            }
        } else {
            ThingType_SetAbstract_Req::new()
        }
    }

    // .typedb.protocol.ThingType.UnsetAbstract.Req thing_type_unset_abstract_req = 302;


    pub fn get_thing_type_unset_abstract_req(&self) -> &ThingType_UnsetAbstract_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_unset_abstract_req(ref v)) => v,
            _ => ThingType_UnsetAbstract_Req::default_instance(),
        }
    }
    pub fn clear_thing_type_unset_abstract_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_thing_type_unset_abstract_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_unset_abstract_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_type_unset_abstract_req(&mut self, v: ThingType_UnsetAbstract_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_unset_abstract_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_type_unset_abstract_req(&mut self) -> &mut ThingType_UnsetAbstract_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::thing_type_unset_abstract_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_unset_abstract_req(ThingType_UnsetAbstract_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_unset_abstract_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_type_unset_abstract_req(&mut self) -> ThingType_UnsetAbstract_Req {
        if self.has_thing_type_unset_abstract_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::thing_type_unset_abstract_req(v)) => v,
                _ => panic!(),
            }
        } else {
            ThingType_UnsetAbstract_Req::new()
        }
    }

    // .typedb.protocol.ThingType.GetOwns.Req thing_type_get_owns_req = 303;


    pub fn get_thing_type_get_owns_req(&self) -> &ThingType_GetOwns_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_get_owns_req(ref v)) => v,
            _ => ThingType_GetOwns_Req::default_instance(),
        }
    }
    pub fn clear_thing_type_get_owns_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_thing_type_get_owns_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_get_owns_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_type_get_owns_req(&mut self, v: ThingType_GetOwns_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_get_owns_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_type_get_owns_req(&mut self) -> &mut ThingType_GetOwns_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::thing_type_get_owns_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_get_owns_req(ThingType_GetOwns_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_get_owns_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_type_get_owns_req(&mut self) -> ThingType_GetOwns_Req {
        if self.has_thing_type_get_owns_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::thing_type_get_owns_req(v)) => v,
                _ => panic!(),
            }
        } else {
            ThingType_GetOwns_Req::new()
        }
    }

    // .typedb.protocol.ThingType.SetOwns.Req thing_type_set_owns_req = 304;


    pub fn get_thing_type_set_owns_req(&self) -> &ThingType_SetOwns_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_set_owns_req(ref v)) => v,
            _ => ThingType_SetOwns_Req::default_instance(),
        }
    }
    pub fn clear_thing_type_set_owns_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_thing_type_set_owns_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_set_owns_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_type_set_owns_req(&mut self, v: ThingType_SetOwns_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_set_owns_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_type_set_owns_req(&mut self) -> &mut ThingType_SetOwns_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::thing_type_set_owns_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_set_owns_req(ThingType_SetOwns_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_set_owns_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_type_set_owns_req(&mut self) -> ThingType_SetOwns_Req {
        if self.has_thing_type_set_owns_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::thing_type_set_owns_req(v)) => v,
                _ => panic!(),
            }
        } else {
            ThingType_SetOwns_Req::new()
        }
    }

    // .typedb.protocol.ThingType.UnsetOwns.Req thing_type_unset_owns_req = 305;


    pub fn get_thing_type_unset_owns_req(&self) -> &ThingType_UnsetOwns_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_unset_owns_req(ref v)) => v,
            _ => ThingType_UnsetOwns_Req::default_instance(),
        }
    }
    pub fn clear_thing_type_unset_owns_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_thing_type_unset_owns_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_unset_owns_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_type_unset_owns_req(&mut self, v: ThingType_UnsetOwns_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_unset_owns_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_type_unset_owns_req(&mut self) -> &mut ThingType_UnsetOwns_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::thing_type_unset_owns_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_unset_owns_req(ThingType_UnsetOwns_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_unset_owns_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_type_unset_owns_req(&mut self) -> ThingType_UnsetOwns_Req {
        if self.has_thing_type_unset_owns_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::thing_type_unset_owns_req(v)) => v,
                _ => panic!(),
            }
        } else {
            ThingType_UnsetOwns_Req::new()
        }
    }

    // .typedb.protocol.ThingType.GetPlays.Req thing_type_get_plays_req = 306;


    pub fn get_thing_type_get_plays_req(&self) -> &ThingType_GetPlays_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_get_plays_req(ref v)) => v,
            _ => ThingType_GetPlays_Req::default_instance(),
        }
    }
    pub fn clear_thing_type_get_plays_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_thing_type_get_plays_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_get_plays_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_type_get_plays_req(&mut self, v: ThingType_GetPlays_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_get_plays_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_type_get_plays_req(&mut self) -> &mut ThingType_GetPlays_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::thing_type_get_plays_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_get_plays_req(ThingType_GetPlays_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_get_plays_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_type_get_plays_req(&mut self) -> ThingType_GetPlays_Req {
        if self.has_thing_type_get_plays_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::thing_type_get_plays_req(v)) => v,
                _ => panic!(),
            }
        } else {
            ThingType_GetPlays_Req::new()
        }
    }

    // .typedb.protocol.ThingType.SetPlays.Req thing_type_set_plays_req = 307;


    pub fn get_thing_type_set_plays_req(&self) -> &ThingType_SetPlays_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_set_plays_req(ref v)) => v,
            _ => ThingType_SetPlays_Req::default_instance(),
        }
    }
    pub fn clear_thing_type_set_plays_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_thing_type_set_plays_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_set_plays_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_type_set_plays_req(&mut self, v: ThingType_SetPlays_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_set_plays_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_type_set_plays_req(&mut self) -> &mut ThingType_SetPlays_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::thing_type_set_plays_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_set_plays_req(ThingType_SetPlays_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_set_plays_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_type_set_plays_req(&mut self) -> ThingType_SetPlays_Req {
        if self.has_thing_type_set_plays_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::thing_type_set_plays_req(v)) => v,
                _ => panic!(),
            }
        } else {
            ThingType_SetPlays_Req::new()
        }
    }

    // .typedb.protocol.ThingType.UnsetPlays.Req thing_type_unset_plays_req = 308;


    pub fn get_thing_type_unset_plays_req(&self) -> &ThingType_UnsetPlays_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_unset_plays_req(ref v)) => v,
            _ => ThingType_UnsetPlays_Req::default_instance(),
        }
    }
    pub fn clear_thing_type_unset_plays_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_thing_type_unset_plays_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_unset_plays_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_type_unset_plays_req(&mut self, v: ThingType_UnsetPlays_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_unset_plays_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_type_unset_plays_req(&mut self) -> &mut ThingType_UnsetPlays_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::thing_type_unset_plays_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_unset_plays_req(ThingType_UnsetPlays_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::thing_type_unset_plays_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_type_unset_plays_req(&mut self) -> ThingType_UnsetPlays_Req {
        if self.has_thing_type_unset_plays_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::thing_type_unset_plays_req(v)) => v,
                _ => panic!(),
            }
        } else {
            ThingType_UnsetPlays_Req::new()
        }
    }

    // .typedb.protocol.EntityType.Create.Req entity_type_create_req = 400;


    pub fn get_entity_type_create_req(&self) -> &EntityType_Create_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::entity_type_create_req(ref v)) => v,
            _ => EntityType_Create_Req::default_instance(),
        }
    }
    pub fn clear_entity_type_create_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_entity_type_create_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::entity_type_create_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_entity_type_create_req(&mut self, v: EntityType_Create_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::entity_type_create_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_entity_type_create_req(&mut self) -> &mut EntityType_Create_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::entity_type_create_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::entity_type_create_req(EntityType_Create_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::entity_type_create_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_entity_type_create_req(&mut self) -> EntityType_Create_Req {
        if self.has_entity_type_create_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::entity_type_create_req(v)) => v,
                _ => panic!(),
            }
        } else {
            EntityType_Create_Req::new()
        }
    }

    // .typedb.protocol.RelationType.Create.Req relation_type_create_req = 500;


    pub fn get_relation_type_create_req(&self) -> &RelationType_Create_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::relation_type_create_req(ref v)) => v,
            _ => RelationType_Create_Req::default_instance(),
        }
    }
    pub fn clear_relation_type_create_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_relation_type_create_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::relation_type_create_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_relation_type_create_req(&mut self, v: RelationType_Create_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::relation_type_create_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_relation_type_create_req(&mut self) -> &mut RelationType_Create_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::relation_type_create_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::relation_type_create_req(RelationType_Create_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::relation_type_create_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_relation_type_create_req(&mut self) -> RelationType_Create_Req {
        if self.has_relation_type_create_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::relation_type_create_req(v)) => v,
                _ => panic!(),
            }
        } else {
            RelationType_Create_Req::new()
        }
    }

    // .typedb.protocol.RelationType.GetRelatesForRoleLabel.Req relation_type_get_relates_for_role_label_req = 501;


    pub fn get_relation_type_get_relates_for_role_label_req(&self) -> &RelationType_GetRelatesForRoleLabel_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::relation_type_get_relates_for_role_label_req(ref v)) => v,
            _ => RelationType_GetRelatesForRoleLabel_Req::default_instance(),
        }
    }
    pub fn clear_relation_type_get_relates_for_role_label_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_relation_type_get_relates_for_role_label_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::relation_type_get_relates_for_role_label_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_relation_type_get_relates_for_role_label_req(&mut self, v: RelationType_GetRelatesForRoleLabel_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::relation_type_get_relates_for_role_label_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_relation_type_get_relates_for_role_label_req(&mut self) -> &mut RelationType_GetRelatesForRoleLabel_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::relation_type_get_relates_for_role_label_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::relation_type_get_relates_for_role_label_req(RelationType_GetRelatesForRoleLabel_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::relation_type_get_relates_for_role_label_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_relation_type_get_relates_for_role_label_req(&mut self) -> RelationType_GetRelatesForRoleLabel_Req {
        if self.has_relation_type_get_relates_for_role_label_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::relation_type_get_relates_for_role_label_req(v)) => v,
                _ => panic!(),
            }
        } else {
            RelationType_GetRelatesForRoleLabel_Req::new()
        }
    }

    // .typedb.protocol.RelationType.GetRelates.Req relation_type_get_relates_req = 502;


    pub fn get_relation_type_get_relates_req(&self) -> &RelationType_GetRelates_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::relation_type_get_relates_req(ref v)) => v,
            _ => RelationType_GetRelates_Req::default_instance(),
        }
    }
    pub fn clear_relation_type_get_relates_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_relation_type_get_relates_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::relation_type_get_relates_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_relation_type_get_relates_req(&mut self, v: RelationType_GetRelates_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::relation_type_get_relates_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_relation_type_get_relates_req(&mut self) -> &mut RelationType_GetRelates_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::relation_type_get_relates_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::relation_type_get_relates_req(RelationType_GetRelates_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::relation_type_get_relates_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_relation_type_get_relates_req(&mut self) -> RelationType_GetRelates_Req {
        if self.has_relation_type_get_relates_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::relation_type_get_relates_req(v)) => v,
                _ => panic!(),
            }
        } else {
            RelationType_GetRelates_Req::new()
        }
    }

    // .typedb.protocol.RelationType.SetRelates.Req relation_type_set_relates_req = 503;


    pub fn get_relation_type_set_relates_req(&self) -> &RelationType_SetRelates_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::relation_type_set_relates_req(ref v)) => v,
            _ => RelationType_SetRelates_Req::default_instance(),
        }
    }
    pub fn clear_relation_type_set_relates_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_relation_type_set_relates_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::relation_type_set_relates_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_relation_type_set_relates_req(&mut self, v: RelationType_SetRelates_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::relation_type_set_relates_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_relation_type_set_relates_req(&mut self) -> &mut RelationType_SetRelates_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::relation_type_set_relates_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::relation_type_set_relates_req(RelationType_SetRelates_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::relation_type_set_relates_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_relation_type_set_relates_req(&mut self) -> RelationType_SetRelates_Req {
        if self.has_relation_type_set_relates_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::relation_type_set_relates_req(v)) => v,
                _ => panic!(),
            }
        } else {
            RelationType_SetRelates_Req::new()
        }
    }

    // .typedb.protocol.RelationType.UnsetRelates.Req relation_type_unset_relates_req = 504;


    pub fn get_relation_type_unset_relates_req(&self) -> &RelationType_UnsetRelates_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::relation_type_unset_relates_req(ref v)) => v,
            _ => RelationType_UnsetRelates_Req::default_instance(),
        }
    }
    pub fn clear_relation_type_unset_relates_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_relation_type_unset_relates_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::relation_type_unset_relates_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_relation_type_unset_relates_req(&mut self, v: RelationType_UnsetRelates_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::relation_type_unset_relates_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_relation_type_unset_relates_req(&mut self) -> &mut RelationType_UnsetRelates_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::relation_type_unset_relates_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::relation_type_unset_relates_req(RelationType_UnsetRelates_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::relation_type_unset_relates_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_relation_type_unset_relates_req(&mut self) -> RelationType_UnsetRelates_Req {
        if self.has_relation_type_unset_relates_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::relation_type_unset_relates_req(v)) => v,
                _ => panic!(),
            }
        } else {
            RelationType_UnsetRelates_Req::new()
        }
    }

    // .typedb.protocol.AttributeType.Put.Req attribute_type_put_req = 600;


    pub fn get_attribute_type_put_req(&self) -> &AttributeType_Put_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_put_req(ref v)) => v,
            _ => AttributeType_Put_Req::default_instance(),
        }
    }
    pub fn clear_attribute_type_put_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_attribute_type_put_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_put_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_attribute_type_put_req(&mut self, v: AttributeType_Put_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_put_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_attribute_type_put_req(&mut self) -> &mut AttributeType_Put_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_put_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_put_req(AttributeType_Put_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_put_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_attribute_type_put_req(&mut self) -> AttributeType_Put_Req {
        if self.has_attribute_type_put_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_put_req(v)) => v,
                _ => panic!(),
            }
        } else {
            AttributeType_Put_Req::new()
        }
    }

    // .typedb.protocol.AttributeType.Get.Req attribute_type_get_req = 601;


    pub fn get_attribute_type_get_req(&self) -> &AttributeType_Get_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_get_req(ref v)) => v,
            _ => AttributeType_Get_Req::default_instance(),
        }
    }
    pub fn clear_attribute_type_get_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_attribute_type_get_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_get_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_attribute_type_get_req(&mut self, v: AttributeType_Get_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_get_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_attribute_type_get_req(&mut self) -> &mut AttributeType_Get_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_get_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_get_req(AttributeType_Get_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_get_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_attribute_type_get_req(&mut self) -> AttributeType_Get_Req {
        if self.has_attribute_type_get_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_get_req(v)) => v,
                _ => panic!(),
            }
        } else {
            AttributeType_Get_Req::new()
        }
    }

    // .typedb.protocol.AttributeType.GetRegex.Req attribute_type_get_regex_req = 602;


    pub fn get_attribute_type_get_regex_req(&self) -> &AttributeType_GetRegex_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_get_regex_req(ref v)) => v,
            _ => AttributeType_GetRegex_Req::default_instance(),
        }
    }
    pub fn clear_attribute_type_get_regex_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_attribute_type_get_regex_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_get_regex_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_attribute_type_get_regex_req(&mut self, v: AttributeType_GetRegex_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_get_regex_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_attribute_type_get_regex_req(&mut self) -> &mut AttributeType_GetRegex_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_get_regex_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_get_regex_req(AttributeType_GetRegex_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_get_regex_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_attribute_type_get_regex_req(&mut self) -> AttributeType_GetRegex_Req {
        if self.has_attribute_type_get_regex_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_get_regex_req(v)) => v,
                _ => panic!(),
            }
        } else {
            AttributeType_GetRegex_Req::new()
        }
    }

    // .typedb.protocol.AttributeType.SetRegex.Req attribute_type_set_regex_req = 603;


    pub fn get_attribute_type_set_regex_req(&self) -> &AttributeType_SetRegex_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_set_regex_req(ref v)) => v,
            _ => AttributeType_SetRegex_Req::default_instance(),
        }
    }
    pub fn clear_attribute_type_set_regex_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_attribute_type_set_regex_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_set_regex_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_attribute_type_set_regex_req(&mut self, v: AttributeType_SetRegex_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_set_regex_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_attribute_type_set_regex_req(&mut self) -> &mut AttributeType_SetRegex_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_set_regex_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_set_regex_req(AttributeType_SetRegex_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_set_regex_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_attribute_type_set_regex_req(&mut self) -> AttributeType_SetRegex_Req {
        if self.has_attribute_type_set_regex_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_set_regex_req(v)) => v,
                _ => panic!(),
            }
        } else {
            AttributeType_SetRegex_Req::new()
        }
    }

    // .typedb.protocol.AttributeType.GetOwners.Req attribute_type_get_owners_req = 604;


    pub fn get_attribute_type_get_owners_req(&self) -> &AttributeType_GetOwners_Req {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_get_owners_req(ref v)) => v,
            _ => AttributeType_GetOwners_Req::default_instance(),
        }
    }
    pub fn clear_attribute_type_get_owners_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_attribute_type_get_owners_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_get_owners_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_attribute_type_get_owners_req(&mut self, v: AttributeType_GetOwners_Req) {
        self.req = ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_get_owners_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_attribute_type_get_owners_req(&mut self) -> &mut AttributeType_GetOwners_Req {
        if let ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_get_owners_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_get_owners_req(AttributeType_GetOwners_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_get_owners_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_attribute_type_get_owners_req(&mut self) -> AttributeType_GetOwners_Req {
        if self.has_attribute_type_get_owners_req() {
            match self.req.take() {
                ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_get_owners_req(v)) => v,
                _ => panic!(),
            }
        } else {
            AttributeType_GetOwners_Req::new()
        }
    }
}

impl ::protobuf::Message for Type_Req {
    fn is_initialized(&self) -> bool {
        if let Some(Type_Req_oneof_req::type_delete_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::type_set_label_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::type_is_abstract_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::type_get_supertype_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::type_set_supertype_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::type_get_supertypes_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::type_get_subtypes_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::role_type_get_relation_types_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::role_type_get_players_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::thing_type_get_instances_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::thing_type_set_abstract_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::thing_type_unset_abstract_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::thing_type_get_owns_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::thing_type_set_owns_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::thing_type_unset_owns_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::thing_type_get_plays_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::thing_type_set_plays_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::thing_type_unset_plays_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::entity_type_create_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::relation_type_create_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::relation_type_get_relates_for_role_label_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::relation_type_get_relates_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::relation_type_set_relates_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::relation_type_unset_relates_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::attribute_type_put_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::attribute_type_get_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::attribute_type_get_regex_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::attribute_type_set_regex_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Req_oneof_req::attribute_type_get_owners_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.scope)?;
                },
                100 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::type_delete_req(is.read_message()?));
                },
                101 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::type_set_label_req(is.read_message()?));
                },
                102 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::type_is_abstract_req(is.read_message()?));
                },
                103 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::type_get_supertype_req(is.read_message()?));
                },
                104 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::type_set_supertype_req(is.read_message()?));
                },
                105 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::type_get_supertypes_req(is.read_message()?));
                },
                106 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::type_get_subtypes_req(is.read_message()?));
                },
                200 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::role_type_get_relation_types_req(is.read_message()?));
                },
                201 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::role_type_get_players_req(is.read_message()?));
                },
                300 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_get_instances_req(is.read_message()?));
                },
                301 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_set_abstract_req(is.read_message()?));
                },
                302 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_unset_abstract_req(is.read_message()?));
                },
                303 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_get_owns_req(is.read_message()?));
                },
                304 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_set_owns_req(is.read_message()?));
                },
                305 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_unset_owns_req(is.read_message()?));
                },
                306 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_get_plays_req(is.read_message()?));
                },
                307 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_set_plays_req(is.read_message()?));
                },
                308 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::thing_type_unset_plays_req(is.read_message()?));
                },
                400 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::entity_type_create_req(is.read_message()?));
                },
                500 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::relation_type_create_req(is.read_message()?));
                },
                501 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::relation_type_get_relates_for_role_label_req(is.read_message()?));
                },
                502 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::relation_type_get_relates_req(is.read_message()?));
                },
                503 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::relation_type_set_relates_req(is.read_message()?));
                },
                504 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::relation_type_unset_relates_req(is.read_message()?));
                },
                600 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_put_req(is.read_message()?));
                },
                601 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_get_req(is.read_message()?));
                },
                602 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_get_regex_req(is.read_message()?));
                },
                603 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_set_regex_req(is.read_message()?));
                },
                604 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Type_Req_oneof_req::attribute_type_get_owners_req(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.label);
        }
        if !self.scope.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.scope);
        }
        if let ::std::option::Option::Some(ref v) = self.req {
            match v {
                &Type_Req_oneof_req::type_delete_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::type_set_label_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::type_is_abstract_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::type_get_supertype_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::type_set_supertype_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::type_get_supertypes_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::type_get_subtypes_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::role_type_get_relation_types_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::role_type_get_players_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::thing_type_get_instances_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::thing_type_set_abstract_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::thing_type_unset_abstract_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::thing_type_get_owns_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::thing_type_set_owns_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::thing_type_unset_owns_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::thing_type_get_plays_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::thing_type_set_plays_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::thing_type_unset_plays_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::entity_type_create_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::relation_type_create_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::relation_type_get_relates_for_role_label_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::relation_type_get_relates_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::relation_type_set_relates_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::relation_type_unset_relates_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::attribute_type_put_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::attribute_type_get_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::attribute_type_get_regex_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::attribute_type_set_regex_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Req_oneof_req::attribute_type_get_owners_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.label.is_empty() {
            os.write_string(1, &self.label)?;
        }
        if !self.scope.is_empty() {
            os.write_string(2, &self.scope)?;
        }
        if let ::std::option::Option::Some(ref v) = self.req {
            match v {
                &Type_Req_oneof_req::type_delete_req(ref v) => {
                    os.write_tag(100, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::type_set_label_req(ref v) => {
                    os.write_tag(101, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::type_is_abstract_req(ref v) => {
                    os.write_tag(102, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::type_get_supertype_req(ref v) => {
                    os.write_tag(103, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::type_set_supertype_req(ref v) => {
                    os.write_tag(104, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::type_get_supertypes_req(ref v) => {
                    os.write_tag(105, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::type_get_subtypes_req(ref v) => {
                    os.write_tag(106, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::role_type_get_relation_types_req(ref v) => {
                    os.write_tag(200, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::role_type_get_players_req(ref v) => {
                    os.write_tag(201, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::thing_type_get_instances_req(ref v) => {
                    os.write_tag(300, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::thing_type_set_abstract_req(ref v) => {
                    os.write_tag(301, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::thing_type_unset_abstract_req(ref v) => {
                    os.write_tag(302, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::thing_type_get_owns_req(ref v) => {
                    os.write_tag(303, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::thing_type_set_owns_req(ref v) => {
                    os.write_tag(304, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::thing_type_unset_owns_req(ref v) => {
                    os.write_tag(305, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::thing_type_get_plays_req(ref v) => {
                    os.write_tag(306, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::thing_type_set_plays_req(ref v) => {
                    os.write_tag(307, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::thing_type_unset_plays_req(ref v) => {
                    os.write_tag(308, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::entity_type_create_req(ref v) => {
                    os.write_tag(400, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::relation_type_create_req(ref v) => {
                    os.write_tag(500, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::relation_type_get_relates_for_role_label_req(ref v) => {
                    os.write_tag(501, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::relation_type_get_relates_req(ref v) => {
                    os.write_tag(502, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::relation_type_set_relates_req(ref v) => {
                    os.write_tag(503, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::relation_type_unset_relates_req(ref v) => {
                    os.write_tag(504, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::attribute_type_put_req(ref v) => {
                    os.write_tag(600, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::attribute_type_get_req(ref v) => {
                    os.write_tag(601, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::attribute_type_get_regex_req(ref v) => {
                    os.write_tag(602, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::attribute_type_set_regex_req(ref v) => {
                    os.write_tag(603, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Req_oneof_req::attribute_type_get_owners_req(ref v) => {
                    os.write_tag(604, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_Req {
        Type_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "label",
                    |m: &Type_Req| { &m.label },
                    |m: &mut Type_Req| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "scope",
                    |m: &Type_Req| { &m.scope },
                    |m: &mut Type_Req| { &mut m.scope },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type_Delete_Req>(
                    "type_delete_req",
                    Type_Req::has_type_delete_req,
                    Type_Req::get_type_delete_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type_SetLabel_Req>(
                    "type_set_label_req",
                    Type_Req::has_type_set_label_req,
                    Type_Req::get_type_set_label_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type_IsAbstract_Req>(
                    "type_is_abstract_req",
                    Type_Req::has_type_is_abstract_req,
                    Type_Req::get_type_is_abstract_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type_GetSupertype_Req>(
                    "type_get_supertype_req",
                    Type_Req::has_type_get_supertype_req,
                    Type_Req::get_type_get_supertype_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type_SetSupertype_Req>(
                    "type_set_supertype_req",
                    Type_Req::has_type_set_supertype_req,
                    Type_Req::get_type_set_supertype_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type_GetSupertypes_Req>(
                    "type_get_supertypes_req",
                    Type_Req::has_type_get_supertypes_req,
                    Type_Req::get_type_get_supertypes_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type_GetSubtypes_Req>(
                    "type_get_subtypes_req",
                    Type_Req::has_type_get_subtypes_req,
                    Type_Req::get_type_get_subtypes_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RoleType_GetRelationTypes_Req>(
                    "role_type_get_relation_types_req",
                    Type_Req::has_role_type_get_relation_types_req,
                    Type_Req::get_role_type_get_relation_types_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RoleType_GetPlayers_Req>(
                    "role_type_get_players_req",
                    Type_Req::has_role_type_get_players_req,
                    Type_Req::get_role_type_get_players_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ThingType_GetInstances_Req>(
                    "thing_type_get_instances_req",
                    Type_Req::has_thing_type_get_instances_req,
                    Type_Req::get_thing_type_get_instances_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ThingType_SetAbstract_Req>(
                    "thing_type_set_abstract_req",
                    Type_Req::has_thing_type_set_abstract_req,
                    Type_Req::get_thing_type_set_abstract_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ThingType_UnsetAbstract_Req>(
                    "thing_type_unset_abstract_req",
                    Type_Req::has_thing_type_unset_abstract_req,
                    Type_Req::get_thing_type_unset_abstract_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ThingType_GetOwns_Req>(
                    "thing_type_get_owns_req",
                    Type_Req::has_thing_type_get_owns_req,
                    Type_Req::get_thing_type_get_owns_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ThingType_SetOwns_Req>(
                    "thing_type_set_owns_req",
                    Type_Req::has_thing_type_set_owns_req,
                    Type_Req::get_thing_type_set_owns_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ThingType_UnsetOwns_Req>(
                    "thing_type_unset_owns_req",
                    Type_Req::has_thing_type_unset_owns_req,
                    Type_Req::get_thing_type_unset_owns_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ThingType_GetPlays_Req>(
                    "thing_type_get_plays_req",
                    Type_Req::has_thing_type_get_plays_req,
                    Type_Req::get_thing_type_get_plays_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ThingType_SetPlays_Req>(
                    "thing_type_set_plays_req",
                    Type_Req::has_thing_type_set_plays_req,
                    Type_Req::get_thing_type_set_plays_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ThingType_UnsetPlays_Req>(
                    "thing_type_unset_plays_req",
                    Type_Req::has_thing_type_unset_plays_req,
                    Type_Req::get_thing_type_unset_plays_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EntityType_Create_Req>(
                    "entity_type_create_req",
                    Type_Req::has_entity_type_create_req,
                    Type_Req::get_entity_type_create_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RelationType_Create_Req>(
                    "relation_type_create_req",
                    Type_Req::has_relation_type_create_req,
                    Type_Req::get_relation_type_create_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RelationType_GetRelatesForRoleLabel_Req>(
                    "relation_type_get_relates_for_role_label_req",
                    Type_Req::has_relation_type_get_relates_for_role_label_req,
                    Type_Req::get_relation_type_get_relates_for_role_label_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RelationType_GetRelates_Req>(
                    "relation_type_get_relates_req",
                    Type_Req::has_relation_type_get_relates_req,
                    Type_Req::get_relation_type_get_relates_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RelationType_SetRelates_Req>(
                    "relation_type_set_relates_req",
                    Type_Req::has_relation_type_set_relates_req,
                    Type_Req::get_relation_type_set_relates_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RelationType_UnsetRelates_Req>(
                    "relation_type_unset_relates_req",
                    Type_Req::has_relation_type_unset_relates_req,
                    Type_Req::get_relation_type_unset_relates_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AttributeType_Put_Req>(
                    "attribute_type_put_req",
                    Type_Req::has_attribute_type_put_req,
                    Type_Req::get_attribute_type_put_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AttributeType_Get_Req>(
                    "attribute_type_get_req",
                    Type_Req::has_attribute_type_get_req,
                    Type_Req::get_attribute_type_get_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AttributeType_GetRegex_Req>(
                    "attribute_type_get_regex_req",
                    Type_Req::has_attribute_type_get_regex_req,
                    Type_Req::get_attribute_type_get_regex_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AttributeType_SetRegex_Req>(
                    "attribute_type_set_regex_req",
                    Type_Req::has_attribute_type_set_regex_req,
                    Type_Req::get_attribute_type_set_regex_req,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AttributeType_GetOwners_Req>(
                    "attribute_type_get_owners_req",
                    Type_Req::has_attribute_type_get_owners_req,
                    Type_Req::get_attribute_type_get_owners_req,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Type_Req>(
                    "Type_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_Req {
        static mut instance: ::protobuf::lazy::Lazy<Type_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_Req,
        };
        unsafe {
            instance.get(Type_Req::new)
        }
    }
}

impl ::protobuf::Clear for Type_Req {
    fn clear(&mut self) {
        self.label.clear();
        self.scope.clear();
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_Res {
    // message oneof groups
    pub res: ::std::option::Option<Type_Res_oneof_res>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_Res {
    fn default() -> &'a Type_Res {
        <Type_Res as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Type_Res_oneof_res {
    type_delete_res(Type_Delete_Res),
    type_set_label_res(Type_SetLabel_Res),
    type_is_abstract_res(Type_IsAbstract_Res),
    type_get_supertype_res(Type_GetSupertype_Res),
    type_set_supertype_res(Type_SetSupertype_Res),
    thing_type_set_abstract_res(ThingType_SetAbstract_Res),
    thing_type_unset_abstract_res(ThingType_UnsetAbstract_Res),
    thing_type_set_owns_res(ThingType_SetOwns_Res),
    thing_type_unset_owns_res(ThingType_UnsetOwns_Res),
    thing_type_set_plays_res(ThingType_SetPlays_Res),
    thing_type_unset_plays_res(ThingType_UnsetPlays_Res),
    entity_type_create_res(EntityType_Create_Res),
    relation_type_create_res(RelationType_Create_Res),
    relation_type_get_relates_for_role_label_res(RelationType_GetRelatesForRoleLabel_Res),
    relation_type_set_relates_res(RelationType_SetRelates_Res),
    relation_type_unset_relates_res(RelationType_UnsetRelates_Res),
    attribute_type_put_res(AttributeType_Put_Res),
    attribute_type_get_res(AttributeType_Get_Res),
    attribute_type_get_regex_res(AttributeType_GetRegex_Res),
    attribute_type_set_regex_res(AttributeType_SetRegex_Res),
}

impl Type_Res {
    pub fn new() -> Type_Res {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Type.Delete.Res type_delete_res = 100;


    pub fn get_type_delete_res(&self) -> &Type_Delete_Res {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::type_delete_res(ref v)) => v,
            _ => Type_Delete_Res::default_instance(),
        }
    }
    pub fn clear_type_delete_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_type_delete_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::type_delete_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_type_delete_res(&mut self, v: Type_Delete_Res) {
        self.res = ::std::option::Option::Some(Type_Res_oneof_res::type_delete_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_type_delete_res(&mut self) -> &mut Type_Delete_Res {
        if let ::std::option::Option::Some(Type_Res_oneof_res::type_delete_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_Res_oneof_res::type_delete_res(Type_Delete_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::type_delete_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_type_delete_res(&mut self) -> Type_Delete_Res {
        if self.has_type_delete_res() {
            match self.res.take() {
                ::std::option::Option::Some(Type_Res_oneof_res::type_delete_res(v)) => v,
                _ => panic!(),
            }
        } else {
            Type_Delete_Res::new()
        }
    }

    // .typedb.protocol.Type.SetLabel.Res type_set_label_res = 101;


    pub fn get_type_set_label_res(&self) -> &Type_SetLabel_Res {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::type_set_label_res(ref v)) => v,
            _ => Type_SetLabel_Res::default_instance(),
        }
    }
    pub fn clear_type_set_label_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_type_set_label_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::type_set_label_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_type_set_label_res(&mut self, v: Type_SetLabel_Res) {
        self.res = ::std::option::Option::Some(Type_Res_oneof_res::type_set_label_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_type_set_label_res(&mut self) -> &mut Type_SetLabel_Res {
        if let ::std::option::Option::Some(Type_Res_oneof_res::type_set_label_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_Res_oneof_res::type_set_label_res(Type_SetLabel_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::type_set_label_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_type_set_label_res(&mut self) -> Type_SetLabel_Res {
        if self.has_type_set_label_res() {
            match self.res.take() {
                ::std::option::Option::Some(Type_Res_oneof_res::type_set_label_res(v)) => v,
                _ => panic!(),
            }
        } else {
            Type_SetLabel_Res::new()
        }
    }

    // .typedb.protocol.Type.IsAbstract.Res type_is_abstract_res = 102;


    pub fn get_type_is_abstract_res(&self) -> &Type_IsAbstract_Res {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::type_is_abstract_res(ref v)) => v,
            _ => Type_IsAbstract_Res::default_instance(),
        }
    }
    pub fn clear_type_is_abstract_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_type_is_abstract_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::type_is_abstract_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_type_is_abstract_res(&mut self, v: Type_IsAbstract_Res) {
        self.res = ::std::option::Option::Some(Type_Res_oneof_res::type_is_abstract_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_type_is_abstract_res(&mut self) -> &mut Type_IsAbstract_Res {
        if let ::std::option::Option::Some(Type_Res_oneof_res::type_is_abstract_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_Res_oneof_res::type_is_abstract_res(Type_IsAbstract_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::type_is_abstract_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_type_is_abstract_res(&mut self) -> Type_IsAbstract_Res {
        if self.has_type_is_abstract_res() {
            match self.res.take() {
                ::std::option::Option::Some(Type_Res_oneof_res::type_is_abstract_res(v)) => v,
                _ => panic!(),
            }
        } else {
            Type_IsAbstract_Res::new()
        }
    }

    // .typedb.protocol.Type.GetSupertype.Res type_get_supertype_res = 103;


    pub fn get_type_get_supertype_res(&self) -> &Type_GetSupertype_Res {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::type_get_supertype_res(ref v)) => v,
            _ => Type_GetSupertype_Res::default_instance(),
        }
    }
    pub fn clear_type_get_supertype_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_type_get_supertype_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::type_get_supertype_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_type_get_supertype_res(&mut self, v: Type_GetSupertype_Res) {
        self.res = ::std::option::Option::Some(Type_Res_oneof_res::type_get_supertype_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_type_get_supertype_res(&mut self) -> &mut Type_GetSupertype_Res {
        if let ::std::option::Option::Some(Type_Res_oneof_res::type_get_supertype_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_Res_oneof_res::type_get_supertype_res(Type_GetSupertype_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::type_get_supertype_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_type_get_supertype_res(&mut self) -> Type_GetSupertype_Res {
        if self.has_type_get_supertype_res() {
            match self.res.take() {
                ::std::option::Option::Some(Type_Res_oneof_res::type_get_supertype_res(v)) => v,
                _ => panic!(),
            }
        } else {
            Type_GetSupertype_Res::new()
        }
    }

    // .typedb.protocol.Type.SetSupertype.Res type_set_supertype_res = 104;


    pub fn get_type_set_supertype_res(&self) -> &Type_SetSupertype_Res {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::type_set_supertype_res(ref v)) => v,
            _ => Type_SetSupertype_Res::default_instance(),
        }
    }
    pub fn clear_type_set_supertype_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_type_set_supertype_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::type_set_supertype_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_type_set_supertype_res(&mut self, v: Type_SetSupertype_Res) {
        self.res = ::std::option::Option::Some(Type_Res_oneof_res::type_set_supertype_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_type_set_supertype_res(&mut self) -> &mut Type_SetSupertype_Res {
        if let ::std::option::Option::Some(Type_Res_oneof_res::type_set_supertype_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_Res_oneof_res::type_set_supertype_res(Type_SetSupertype_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::type_set_supertype_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_type_set_supertype_res(&mut self) -> Type_SetSupertype_Res {
        if self.has_type_set_supertype_res() {
            match self.res.take() {
                ::std::option::Option::Some(Type_Res_oneof_res::type_set_supertype_res(v)) => v,
                _ => panic!(),
            }
        } else {
            Type_SetSupertype_Res::new()
        }
    }

    // .typedb.protocol.ThingType.SetAbstract.Res thing_type_set_abstract_res = 300;


    pub fn get_thing_type_set_abstract_res(&self) -> &ThingType_SetAbstract_Res {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::thing_type_set_abstract_res(ref v)) => v,
            _ => ThingType_SetAbstract_Res::default_instance(),
        }
    }
    pub fn clear_thing_type_set_abstract_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_thing_type_set_abstract_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::thing_type_set_abstract_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_type_set_abstract_res(&mut self, v: ThingType_SetAbstract_Res) {
        self.res = ::std::option::Option::Some(Type_Res_oneof_res::thing_type_set_abstract_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_type_set_abstract_res(&mut self) -> &mut ThingType_SetAbstract_Res {
        if let ::std::option::Option::Some(Type_Res_oneof_res::thing_type_set_abstract_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_Res_oneof_res::thing_type_set_abstract_res(ThingType_SetAbstract_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::thing_type_set_abstract_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_type_set_abstract_res(&mut self) -> ThingType_SetAbstract_Res {
        if self.has_thing_type_set_abstract_res() {
            match self.res.take() {
                ::std::option::Option::Some(Type_Res_oneof_res::thing_type_set_abstract_res(v)) => v,
                _ => panic!(),
            }
        } else {
            ThingType_SetAbstract_Res::new()
        }
    }

    // .typedb.protocol.ThingType.UnsetAbstract.Res thing_type_unset_abstract_res = 301;


    pub fn get_thing_type_unset_abstract_res(&self) -> &ThingType_UnsetAbstract_Res {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::thing_type_unset_abstract_res(ref v)) => v,
            _ => ThingType_UnsetAbstract_Res::default_instance(),
        }
    }
    pub fn clear_thing_type_unset_abstract_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_thing_type_unset_abstract_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::thing_type_unset_abstract_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_type_unset_abstract_res(&mut self, v: ThingType_UnsetAbstract_Res) {
        self.res = ::std::option::Option::Some(Type_Res_oneof_res::thing_type_unset_abstract_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_type_unset_abstract_res(&mut self) -> &mut ThingType_UnsetAbstract_Res {
        if let ::std::option::Option::Some(Type_Res_oneof_res::thing_type_unset_abstract_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_Res_oneof_res::thing_type_unset_abstract_res(ThingType_UnsetAbstract_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::thing_type_unset_abstract_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_type_unset_abstract_res(&mut self) -> ThingType_UnsetAbstract_Res {
        if self.has_thing_type_unset_abstract_res() {
            match self.res.take() {
                ::std::option::Option::Some(Type_Res_oneof_res::thing_type_unset_abstract_res(v)) => v,
                _ => panic!(),
            }
        } else {
            ThingType_UnsetAbstract_Res::new()
        }
    }

    // .typedb.protocol.ThingType.SetOwns.Res thing_type_set_owns_res = 302;


    pub fn get_thing_type_set_owns_res(&self) -> &ThingType_SetOwns_Res {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::thing_type_set_owns_res(ref v)) => v,
            _ => ThingType_SetOwns_Res::default_instance(),
        }
    }
    pub fn clear_thing_type_set_owns_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_thing_type_set_owns_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::thing_type_set_owns_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_type_set_owns_res(&mut self, v: ThingType_SetOwns_Res) {
        self.res = ::std::option::Option::Some(Type_Res_oneof_res::thing_type_set_owns_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_type_set_owns_res(&mut self) -> &mut ThingType_SetOwns_Res {
        if let ::std::option::Option::Some(Type_Res_oneof_res::thing_type_set_owns_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_Res_oneof_res::thing_type_set_owns_res(ThingType_SetOwns_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::thing_type_set_owns_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_type_set_owns_res(&mut self) -> ThingType_SetOwns_Res {
        if self.has_thing_type_set_owns_res() {
            match self.res.take() {
                ::std::option::Option::Some(Type_Res_oneof_res::thing_type_set_owns_res(v)) => v,
                _ => panic!(),
            }
        } else {
            ThingType_SetOwns_Res::new()
        }
    }

    // .typedb.protocol.ThingType.UnsetOwns.Res thing_type_unset_owns_res = 303;


    pub fn get_thing_type_unset_owns_res(&self) -> &ThingType_UnsetOwns_Res {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::thing_type_unset_owns_res(ref v)) => v,
            _ => ThingType_UnsetOwns_Res::default_instance(),
        }
    }
    pub fn clear_thing_type_unset_owns_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_thing_type_unset_owns_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::thing_type_unset_owns_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_type_unset_owns_res(&mut self, v: ThingType_UnsetOwns_Res) {
        self.res = ::std::option::Option::Some(Type_Res_oneof_res::thing_type_unset_owns_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_type_unset_owns_res(&mut self) -> &mut ThingType_UnsetOwns_Res {
        if let ::std::option::Option::Some(Type_Res_oneof_res::thing_type_unset_owns_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_Res_oneof_res::thing_type_unset_owns_res(ThingType_UnsetOwns_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::thing_type_unset_owns_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_type_unset_owns_res(&mut self) -> ThingType_UnsetOwns_Res {
        if self.has_thing_type_unset_owns_res() {
            match self.res.take() {
                ::std::option::Option::Some(Type_Res_oneof_res::thing_type_unset_owns_res(v)) => v,
                _ => panic!(),
            }
        } else {
            ThingType_UnsetOwns_Res::new()
        }
    }

    // .typedb.protocol.ThingType.SetPlays.Res thing_type_set_plays_res = 304;


    pub fn get_thing_type_set_plays_res(&self) -> &ThingType_SetPlays_Res {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::thing_type_set_plays_res(ref v)) => v,
            _ => ThingType_SetPlays_Res::default_instance(),
        }
    }
    pub fn clear_thing_type_set_plays_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_thing_type_set_plays_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::thing_type_set_plays_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_type_set_plays_res(&mut self, v: ThingType_SetPlays_Res) {
        self.res = ::std::option::Option::Some(Type_Res_oneof_res::thing_type_set_plays_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_type_set_plays_res(&mut self) -> &mut ThingType_SetPlays_Res {
        if let ::std::option::Option::Some(Type_Res_oneof_res::thing_type_set_plays_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_Res_oneof_res::thing_type_set_plays_res(ThingType_SetPlays_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::thing_type_set_plays_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_type_set_plays_res(&mut self) -> ThingType_SetPlays_Res {
        if self.has_thing_type_set_plays_res() {
            match self.res.take() {
                ::std::option::Option::Some(Type_Res_oneof_res::thing_type_set_plays_res(v)) => v,
                _ => panic!(),
            }
        } else {
            ThingType_SetPlays_Res::new()
        }
    }

    // .typedb.protocol.ThingType.UnsetPlays.Res thing_type_unset_plays_res = 305;


    pub fn get_thing_type_unset_plays_res(&self) -> &ThingType_UnsetPlays_Res {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::thing_type_unset_plays_res(ref v)) => v,
            _ => ThingType_UnsetPlays_Res::default_instance(),
        }
    }
    pub fn clear_thing_type_unset_plays_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_thing_type_unset_plays_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::thing_type_unset_plays_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_type_unset_plays_res(&mut self, v: ThingType_UnsetPlays_Res) {
        self.res = ::std::option::Option::Some(Type_Res_oneof_res::thing_type_unset_plays_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_type_unset_plays_res(&mut self) -> &mut ThingType_UnsetPlays_Res {
        if let ::std::option::Option::Some(Type_Res_oneof_res::thing_type_unset_plays_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_Res_oneof_res::thing_type_unset_plays_res(ThingType_UnsetPlays_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::thing_type_unset_plays_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_type_unset_plays_res(&mut self) -> ThingType_UnsetPlays_Res {
        if self.has_thing_type_unset_plays_res() {
            match self.res.take() {
                ::std::option::Option::Some(Type_Res_oneof_res::thing_type_unset_plays_res(v)) => v,
                _ => panic!(),
            }
        } else {
            ThingType_UnsetPlays_Res::new()
        }
    }

    // .typedb.protocol.EntityType.Create.Res entity_type_create_res = 400;


    pub fn get_entity_type_create_res(&self) -> &EntityType_Create_Res {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::entity_type_create_res(ref v)) => v,
            _ => EntityType_Create_Res::default_instance(),
        }
    }
    pub fn clear_entity_type_create_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_entity_type_create_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::entity_type_create_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_entity_type_create_res(&mut self, v: EntityType_Create_Res) {
        self.res = ::std::option::Option::Some(Type_Res_oneof_res::entity_type_create_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_entity_type_create_res(&mut self) -> &mut EntityType_Create_Res {
        if let ::std::option::Option::Some(Type_Res_oneof_res::entity_type_create_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_Res_oneof_res::entity_type_create_res(EntityType_Create_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::entity_type_create_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_entity_type_create_res(&mut self) -> EntityType_Create_Res {
        if self.has_entity_type_create_res() {
            match self.res.take() {
                ::std::option::Option::Some(Type_Res_oneof_res::entity_type_create_res(v)) => v,
                _ => panic!(),
            }
        } else {
            EntityType_Create_Res::new()
        }
    }

    // .typedb.protocol.RelationType.Create.Res relation_type_create_res = 500;


    pub fn get_relation_type_create_res(&self) -> &RelationType_Create_Res {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::relation_type_create_res(ref v)) => v,
            _ => RelationType_Create_Res::default_instance(),
        }
    }
    pub fn clear_relation_type_create_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_relation_type_create_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::relation_type_create_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_relation_type_create_res(&mut self, v: RelationType_Create_Res) {
        self.res = ::std::option::Option::Some(Type_Res_oneof_res::relation_type_create_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_relation_type_create_res(&mut self) -> &mut RelationType_Create_Res {
        if let ::std::option::Option::Some(Type_Res_oneof_res::relation_type_create_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_Res_oneof_res::relation_type_create_res(RelationType_Create_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::relation_type_create_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_relation_type_create_res(&mut self) -> RelationType_Create_Res {
        if self.has_relation_type_create_res() {
            match self.res.take() {
                ::std::option::Option::Some(Type_Res_oneof_res::relation_type_create_res(v)) => v,
                _ => panic!(),
            }
        } else {
            RelationType_Create_Res::new()
        }
    }

    // .typedb.protocol.RelationType.GetRelatesForRoleLabel.Res relation_type_get_relates_for_role_label_res = 501;


    pub fn get_relation_type_get_relates_for_role_label_res(&self) -> &RelationType_GetRelatesForRoleLabel_Res {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::relation_type_get_relates_for_role_label_res(ref v)) => v,
            _ => RelationType_GetRelatesForRoleLabel_Res::default_instance(),
        }
    }
    pub fn clear_relation_type_get_relates_for_role_label_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_relation_type_get_relates_for_role_label_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::relation_type_get_relates_for_role_label_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_relation_type_get_relates_for_role_label_res(&mut self, v: RelationType_GetRelatesForRoleLabel_Res) {
        self.res = ::std::option::Option::Some(Type_Res_oneof_res::relation_type_get_relates_for_role_label_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_relation_type_get_relates_for_role_label_res(&mut self) -> &mut RelationType_GetRelatesForRoleLabel_Res {
        if let ::std::option::Option::Some(Type_Res_oneof_res::relation_type_get_relates_for_role_label_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_Res_oneof_res::relation_type_get_relates_for_role_label_res(RelationType_GetRelatesForRoleLabel_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::relation_type_get_relates_for_role_label_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_relation_type_get_relates_for_role_label_res(&mut self) -> RelationType_GetRelatesForRoleLabel_Res {
        if self.has_relation_type_get_relates_for_role_label_res() {
            match self.res.take() {
                ::std::option::Option::Some(Type_Res_oneof_res::relation_type_get_relates_for_role_label_res(v)) => v,
                _ => panic!(),
            }
        } else {
            RelationType_GetRelatesForRoleLabel_Res::new()
        }
    }

    // .typedb.protocol.RelationType.SetRelates.Res relation_type_set_relates_res = 502;


    pub fn get_relation_type_set_relates_res(&self) -> &RelationType_SetRelates_Res {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::relation_type_set_relates_res(ref v)) => v,
            _ => RelationType_SetRelates_Res::default_instance(),
        }
    }
    pub fn clear_relation_type_set_relates_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_relation_type_set_relates_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::relation_type_set_relates_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_relation_type_set_relates_res(&mut self, v: RelationType_SetRelates_Res) {
        self.res = ::std::option::Option::Some(Type_Res_oneof_res::relation_type_set_relates_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_relation_type_set_relates_res(&mut self) -> &mut RelationType_SetRelates_Res {
        if let ::std::option::Option::Some(Type_Res_oneof_res::relation_type_set_relates_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_Res_oneof_res::relation_type_set_relates_res(RelationType_SetRelates_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::relation_type_set_relates_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_relation_type_set_relates_res(&mut self) -> RelationType_SetRelates_Res {
        if self.has_relation_type_set_relates_res() {
            match self.res.take() {
                ::std::option::Option::Some(Type_Res_oneof_res::relation_type_set_relates_res(v)) => v,
                _ => panic!(),
            }
        } else {
            RelationType_SetRelates_Res::new()
        }
    }

    // .typedb.protocol.RelationType.UnsetRelates.Res relation_type_unset_relates_res = 503;


    pub fn get_relation_type_unset_relates_res(&self) -> &RelationType_UnsetRelates_Res {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::relation_type_unset_relates_res(ref v)) => v,
            _ => RelationType_UnsetRelates_Res::default_instance(),
        }
    }
    pub fn clear_relation_type_unset_relates_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_relation_type_unset_relates_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::relation_type_unset_relates_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_relation_type_unset_relates_res(&mut self, v: RelationType_UnsetRelates_Res) {
        self.res = ::std::option::Option::Some(Type_Res_oneof_res::relation_type_unset_relates_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_relation_type_unset_relates_res(&mut self) -> &mut RelationType_UnsetRelates_Res {
        if let ::std::option::Option::Some(Type_Res_oneof_res::relation_type_unset_relates_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_Res_oneof_res::relation_type_unset_relates_res(RelationType_UnsetRelates_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::relation_type_unset_relates_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_relation_type_unset_relates_res(&mut self) -> RelationType_UnsetRelates_Res {
        if self.has_relation_type_unset_relates_res() {
            match self.res.take() {
                ::std::option::Option::Some(Type_Res_oneof_res::relation_type_unset_relates_res(v)) => v,
                _ => panic!(),
            }
        } else {
            RelationType_UnsetRelates_Res::new()
        }
    }

    // .typedb.protocol.AttributeType.Put.Res attribute_type_put_res = 600;


    pub fn get_attribute_type_put_res(&self) -> &AttributeType_Put_Res {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_put_res(ref v)) => v,
            _ => AttributeType_Put_Res::default_instance(),
        }
    }
    pub fn clear_attribute_type_put_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_attribute_type_put_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_put_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_attribute_type_put_res(&mut self, v: AttributeType_Put_Res) {
        self.res = ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_put_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_attribute_type_put_res(&mut self) -> &mut AttributeType_Put_Res {
        if let ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_put_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_put_res(AttributeType_Put_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_put_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_attribute_type_put_res(&mut self) -> AttributeType_Put_Res {
        if self.has_attribute_type_put_res() {
            match self.res.take() {
                ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_put_res(v)) => v,
                _ => panic!(),
            }
        } else {
            AttributeType_Put_Res::new()
        }
    }

    // .typedb.protocol.AttributeType.Get.Res attribute_type_get_res = 601;


    pub fn get_attribute_type_get_res(&self) -> &AttributeType_Get_Res {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_get_res(ref v)) => v,
            _ => AttributeType_Get_Res::default_instance(),
        }
    }
    pub fn clear_attribute_type_get_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_attribute_type_get_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_get_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_attribute_type_get_res(&mut self, v: AttributeType_Get_Res) {
        self.res = ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_get_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_attribute_type_get_res(&mut self) -> &mut AttributeType_Get_Res {
        if let ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_get_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_get_res(AttributeType_Get_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_get_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_attribute_type_get_res(&mut self) -> AttributeType_Get_Res {
        if self.has_attribute_type_get_res() {
            match self.res.take() {
                ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_get_res(v)) => v,
                _ => panic!(),
            }
        } else {
            AttributeType_Get_Res::new()
        }
    }

    // .typedb.protocol.AttributeType.GetRegex.Res attribute_type_get_regex_res = 602;


    pub fn get_attribute_type_get_regex_res(&self) -> &AttributeType_GetRegex_Res {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_get_regex_res(ref v)) => v,
            _ => AttributeType_GetRegex_Res::default_instance(),
        }
    }
    pub fn clear_attribute_type_get_regex_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_attribute_type_get_regex_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_get_regex_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_attribute_type_get_regex_res(&mut self, v: AttributeType_GetRegex_Res) {
        self.res = ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_get_regex_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_attribute_type_get_regex_res(&mut self) -> &mut AttributeType_GetRegex_Res {
        if let ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_get_regex_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_get_regex_res(AttributeType_GetRegex_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_get_regex_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_attribute_type_get_regex_res(&mut self) -> AttributeType_GetRegex_Res {
        if self.has_attribute_type_get_regex_res() {
            match self.res.take() {
                ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_get_regex_res(v)) => v,
                _ => panic!(),
            }
        } else {
            AttributeType_GetRegex_Res::new()
        }
    }

    // .typedb.protocol.AttributeType.SetRegex.Res attribute_type_set_regex_res = 603;


    pub fn get_attribute_type_set_regex_res(&self) -> &AttributeType_SetRegex_Res {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_set_regex_res(ref v)) => v,
            _ => AttributeType_SetRegex_Res::default_instance(),
        }
    }
    pub fn clear_attribute_type_set_regex_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_attribute_type_set_regex_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_set_regex_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_attribute_type_set_regex_res(&mut self, v: AttributeType_SetRegex_Res) {
        self.res = ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_set_regex_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_attribute_type_set_regex_res(&mut self) -> &mut AttributeType_SetRegex_Res {
        if let ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_set_regex_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_set_regex_res(AttributeType_SetRegex_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_set_regex_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_attribute_type_set_regex_res(&mut self) -> AttributeType_SetRegex_Res {
        if self.has_attribute_type_set_regex_res() {
            match self.res.take() {
                ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_set_regex_res(v)) => v,
                _ => panic!(),
            }
        } else {
            AttributeType_SetRegex_Res::new()
        }
    }
}

impl ::protobuf::Message for Type_Res {
    fn is_initialized(&self) -> bool {
        if let Some(Type_Res_oneof_res::type_delete_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Res_oneof_res::type_set_label_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Res_oneof_res::type_is_abstract_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Res_oneof_res::type_get_supertype_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Res_oneof_res::type_set_supertype_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Res_oneof_res::thing_type_set_abstract_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Res_oneof_res::thing_type_unset_abstract_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Res_oneof_res::thing_type_set_owns_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Res_oneof_res::thing_type_unset_owns_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Res_oneof_res::thing_type_set_plays_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Res_oneof_res::thing_type_unset_plays_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Res_oneof_res::entity_type_create_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Res_oneof_res::relation_type_create_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Res_oneof_res::relation_type_get_relates_for_role_label_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Res_oneof_res::relation_type_set_relates_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Res_oneof_res::relation_type_unset_relates_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Res_oneof_res::attribute_type_put_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Res_oneof_res::attribute_type_get_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Res_oneof_res::attribute_type_get_regex_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_Res_oneof_res::attribute_type_set_regex_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                100 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_Res_oneof_res::type_delete_res(is.read_message()?));
                },
                101 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_Res_oneof_res::type_set_label_res(is.read_message()?));
                },
                102 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_Res_oneof_res::type_is_abstract_res(is.read_message()?));
                },
                103 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_Res_oneof_res::type_get_supertype_res(is.read_message()?));
                },
                104 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_Res_oneof_res::type_set_supertype_res(is.read_message()?));
                },
                300 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_Res_oneof_res::thing_type_set_abstract_res(is.read_message()?));
                },
                301 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_Res_oneof_res::thing_type_unset_abstract_res(is.read_message()?));
                },
                302 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_Res_oneof_res::thing_type_set_owns_res(is.read_message()?));
                },
                303 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_Res_oneof_res::thing_type_unset_owns_res(is.read_message()?));
                },
                304 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_Res_oneof_res::thing_type_set_plays_res(is.read_message()?));
                },
                305 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_Res_oneof_res::thing_type_unset_plays_res(is.read_message()?));
                },
                400 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_Res_oneof_res::entity_type_create_res(is.read_message()?));
                },
                500 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_Res_oneof_res::relation_type_create_res(is.read_message()?));
                },
                501 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_Res_oneof_res::relation_type_get_relates_for_role_label_res(is.read_message()?));
                },
                502 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_Res_oneof_res::relation_type_set_relates_res(is.read_message()?));
                },
                503 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_Res_oneof_res::relation_type_unset_relates_res(is.read_message()?));
                },
                600 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_put_res(is.read_message()?));
                },
                601 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_get_res(is.read_message()?));
                },
                602 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_get_regex_res(is.read_message()?));
                },
                603 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_Res_oneof_res::attribute_type_set_regex_res(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &Type_Res_oneof_res::type_delete_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Res_oneof_res::type_set_label_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Res_oneof_res::type_is_abstract_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Res_oneof_res::type_get_supertype_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Res_oneof_res::type_set_supertype_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Res_oneof_res::thing_type_set_abstract_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Res_oneof_res::thing_type_unset_abstract_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Res_oneof_res::thing_type_set_owns_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Res_oneof_res::thing_type_unset_owns_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Res_oneof_res::thing_type_set_plays_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Res_oneof_res::thing_type_unset_plays_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Res_oneof_res::entity_type_create_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Res_oneof_res::relation_type_create_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Res_oneof_res::relation_type_get_relates_for_role_label_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Res_oneof_res::relation_type_set_relates_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Res_oneof_res::relation_type_unset_relates_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Res_oneof_res::attribute_type_put_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Res_oneof_res::attribute_type_get_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Res_oneof_res::attribute_type_get_regex_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_Res_oneof_res::attribute_type_set_regex_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &Type_Res_oneof_res::type_delete_res(ref v) => {
                    os.write_tag(100, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Res_oneof_res::type_set_label_res(ref v) => {
                    os.write_tag(101, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Res_oneof_res::type_is_abstract_res(ref v) => {
                    os.write_tag(102, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Res_oneof_res::type_get_supertype_res(ref v) => {
                    os.write_tag(103, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Res_oneof_res::type_set_supertype_res(ref v) => {
                    os.write_tag(104, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Res_oneof_res::thing_type_set_abstract_res(ref v) => {
                    os.write_tag(300, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Res_oneof_res::thing_type_unset_abstract_res(ref v) => {
                    os.write_tag(301, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Res_oneof_res::thing_type_set_owns_res(ref v) => {
                    os.write_tag(302, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Res_oneof_res::thing_type_unset_owns_res(ref v) => {
                    os.write_tag(303, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Res_oneof_res::thing_type_set_plays_res(ref v) => {
                    os.write_tag(304, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Res_oneof_res::thing_type_unset_plays_res(ref v) => {
                    os.write_tag(305, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Res_oneof_res::entity_type_create_res(ref v) => {
                    os.write_tag(400, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Res_oneof_res::relation_type_create_res(ref v) => {
                    os.write_tag(500, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Res_oneof_res::relation_type_get_relates_for_role_label_res(ref v) => {
                    os.write_tag(501, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Res_oneof_res::relation_type_set_relates_res(ref v) => {
                    os.write_tag(502, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Res_oneof_res::relation_type_unset_relates_res(ref v) => {
                    os.write_tag(503, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Res_oneof_res::attribute_type_put_res(ref v) => {
                    os.write_tag(600, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Res_oneof_res::attribute_type_get_res(ref v) => {
                    os.write_tag(601, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Res_oneof_res::attribute_type_get_regex_res(ref v) => {
                    os.write_tag(602, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_Res_oneof_res::attribute_type_set_regex_res(ref v) => {
                    os.write_tag(603, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_Res {
        Type_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type_Delete_Res>(
                    "type_delete_res",
                    Type_Res::has_type_delete_res,
                    Type_Res::get_type_delete_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type_SetLabel_Res>(
                    "type_set_label_res",
                    Type_Res::has_type_set_label_res,
                    Type_Res::get_type_set_label_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type_IsAbstract_Res>(
                    "type_is_abstract_res",
                    Type_Res::has_type_is_abstract_res,
                    Type_Res::get_type_is_abstract_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type_GetSupertype_Res>(
                    "type_get_supertype_res",
                    Type_Res::has_type_get_supertype_res,
                    Type_Res::get_type_get_supertype_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type_SetSupertype_Res>(
                    "type_set_supertype_res",
                    Type_Res::has_type_set_supertype_res,
                    Type_Res::get_type_set_supertype_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ThingType_SetAbstract_Res>(
                    "thing_type_set_abstract_res",
                    Type_Res::has_thing_type_set_abstract_res,
                    Type_Res::get_thing_type_set_abstract_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ThingType_UnsetAbstract_Res>(
                    "thing_type_unset_abstract_res",
                    Type_Res::has_thing_type_unset_abstract_res,
                    Type_Res::get_thing_type_unset_abstract_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ThingType_SetOwns_Res>(
                    "thing_type_set_owns_res",
                    Type_Res::has_thing_type_set_owns_res,
                    Type_Res::get_thing_type_set_owns_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ThingType_UnsetOwns_Res>(
                    "thing_type_unset_owns_res",
                    Type_Res::has_thing_type_unset_owns_res,
                    Type_Res::get_thing_type_unset_owns_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ThingType_SetPlays_Res>(
                    "thing_type_set_plays_res",
                    Type_Res::has_thing_type_set_plays_res,
                    Type_Res::get_thing_type_set_plays_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ThingType_UnsetPlays_Res>(
                    "thing_type_unset_plays_res",
                    Type_Res::has_thing_type_unset_plays_res,
                    Type_Res::get_thing_type_unset_plays_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EntityType_Create_Res>(
                    "entity_type_create_res",
                    Type_Res::has_entity_type_create_res,
                    Type_Res::get_entity_type_create_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RelationType_Create_Res>(
                    "relation_type_create_res",
                    Type_Res::has_relation_type_create_res,
                    Type_Res::get_relation_type_create_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RelationType_GetRelatesForRoleLabel_Res>(
                    "relation_type_get_relates_for_role_label_res",
                    Type_Res::has_relation_type_get_relates_for_role_label_res,
                    Type_Res::get_relation_type_get_relates_for_role_label_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RelationType_SetRelates_Res>(
                    "relation_type_set_relates_res",
                    Type_Res::has_relation_type_set_relates_res,
                    Type_Res::get_relation_type_set_relates_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RelationType_UnsetRelates_Res>(
                    "relation_type_unset_relates_res",
                    Type_Res::has_relation_type_unset_relates_res,
                    Type_Res::get_relation_type_unset_relates_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AttributeType_Put_Res>(
                    "attribute_type_put_res",
                    Type_Res::has_attribute_type_put_res,
                    Type_Res::get_attribute_type_put_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AttributeType_Get_Res>(
                    "attribute_type_get_res",
                    Type_Res::has_attribute_type_get_res,
                    Type_Res::get_attribute_type_get_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AttributeType_GetRegex_Res>(
                    "attribute_type_get_regex_res",
                    Type_Res::has_attribute_type_get_regex_res,
                    Type_Res::get_attribute_type_get_regex_res,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AttributeType_SetRegex_Res>(
                    "attribute_type_set_regex_res",
                    Type_Res::has_attribute_type_set_regex_res,
                    Type_Res::get_attribute_type_set_regex_res,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Type_Res>(
                    "Type_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_Res {
        static mut instance: ::protobuf::lazy::Lazy<Type_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_Res,
        };
        unsafe {
            instance.get(Type_Res::new)
        }
    }
}

impl ::protobuf::Clear for Type_Res {
    fn clear(&mut self) {
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_ResPart {
    // message oneof groups
    pub res: ::std::option::Option<Type_ResPart_oneof_res>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_ResPart {
    fn default() -> &'a Type_ResPart {
        <Type_ResPart as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Type_ResPart_oneof_res {
    type_get_supertypes_res_part(Type_GetSupertypes_ResPart),
    type_get_subtypes_res_part(Type_GetSubtypes_ResPart),
    role_type_get_relation_types_res_part(RoleType_GetRelationTypes_ResPart),
    role_type_get_players_res_part(RoleType_GetPlayers_ResPart),
    thing_type_get_instances_res_part(ThingType_GetInstances_ResPart),
    thing_type_get_owns_res_part(ThingType_GetOwns_ResPart),
    thing_type_get_plays_res_part(ThingType_GetPlays_ResPart),
    relation_type_get_relates_res_part(RelationType_GetRelates_ResPart),
    attribute_type_get_owners_res_part(AttributeType_GetOwners_ResPart),
}

impl Type_ResPart {
    pub fn new() -> Type_ResPart {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Type.GetSupertypes.ResPart type_get_supertypes_res_part = 100;


    pub fn get_type_get_supertypes_res_part(&self) -> &Type_GetSupertypes_ResPart {
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::type_get_supertypes_res_part(ref v)) => v,
            _ => Type_GetSupertypes_ResPart::default_instance(),
        }
    }
    pub fn clear_type_get_supertypes_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_type_get_supertypes_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::type_get_supertypes_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_type_get_supertypes_res_part(&mut self, v: Type_GetSupertypes_ResPart) {
        self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::type_get_supertypes_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_type_get_supertypes_res_part(&mut self) -> &mut Type_GetSupertypes_ResPart {
        if let ::std::option::Option::Some(Type_ResPart_oneof_res::type_get_supertypes_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::type_get_supertypes_res_part(Type_GetSupertypes_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::type_get_supertypes_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_type_get_supertypes_res_part(&mut self) -> Type_GetSupertypes_ResPart {
        if self.has_type_get_supertypes_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(Type_ResPart_oneof_res::type_get_supertypes_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            Type_GetSupertypes_ResPart::new()
        }
    }

    // .typedb.protocol.Type.GetSubtypes.ResPart type_get_subtypes_res_part = 101;


    pub fn get_type_get_subtypes_res_part(&self) -> &Type_GetSubtypes_ResPart {
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::type_get_subtypes_res_part(ref v)) => v,
            _ => Type_GetSubtypes_ResPart::default_instance(),
        }
    }
    pub fn clear_type_get_subtypes_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_type_get_subtypes_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::type_get_subtypes_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_type_get_subtypes_res_part(&mut self, v: Type_GetSubtypes_ResPart) {
        self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::type_get_subtypes_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_type_get_subtypes_res_part(&mut self) -> &mut Type_GetSubtypes_ResPart {
        if let ::std::option::Option::Some(Type_ResPart_oneof_res::type_get_subtypes_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::type_get_subtypes_res_part(Type_GetSubtypes_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::type_get_subtypes_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_type_get_subtypes_res_part(&mut self) -> Type_GetSubtypes_ResPart {
        if self.has_type_get_subtypes_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(Type_ResPart_oneof_res::type_get_subtypes_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            Type_GetSubtypes_ResPart::new()
        }
    }

    // .typedb.protocol.RoleType.GetRelationTypes.ResPart role_type_get_relation_types_res_part = 200;


    pub fn get_role_type_get_relation_types_res_part(&self) -> &RoleType_GetRelationTypes_ResPart {
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::role_type_get_relation_types_res_part(ref v)) => v,
            _ => RoleType_GetRelationTypes_ResPart::default_instance(),
        }
    }
    pub fn clear_role_type_get_relation_types_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_role_type_get_relation_types_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::role_type_get_relation_types_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_role_type_get_relation_types_res_part(&mut self, v: RoleType_GetRelationTypes_ResPart) {
        self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::role_type_get_relation_types_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_role_type_get_relation_types_res_part(&mut self) -> &mut RoleType_GetRelationTypes_ResPart {
        if let ::std::option::Option::Some(Type_ResPart_oneof_res::role_type_get_relation_types_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::role_type_get_relation_types_res_part(RoleType_GetRelationTypes_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::role_type_get_relation_types_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_role_type_get_relation_types_res_part(&mut self) -> RoleType_GetRelationTypes_ResPart {
        if self.has_role_type_get_relation_types_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(Type_ResPart_oneof_res::role_type_get_relation_types_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            RoleType_GetRelationTypes_ResPart::new()
        }
    }

    // .typedb.protocol.RoleType.GetPlayers.ResPart role_type_get_players_res_part = 201;


    pub fn get_role_type_get_players_res_part(&self) -> &RoleType_GetPlayers_ResPart {
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::role_type_get_players_res_part(ref v)) => v,
            _ => RoleType_GetPlayers_ResPart::default_instance(),
        }
    }
    pub fn clear_role_type_get_players_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_role_type_get_players_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::role_type_get_players_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_role_type_get_players_res_part(&mut self, v: RoleType_GetPlayers_ResPart) {
        self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::role_type_get_players_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_role_type_get_players_res_part(&mut self) -> &mut RoleType_GetPlayers_ResPart {
        if let ::std::option::Option::Some(Type_ResPart_oneof_res::role_type_get_players_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::role_type_get_players_res_part(RoleType_GetPlayers_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::role_type_get_players_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_role_type_get_players_res_part(&mut self) -> RoleType_GetPlayers_ResPart {
        if self.has_role_type_get_players_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(Type_ResPart_oneof_res::role_type_get_players_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            RoleType_GetPlayers_ResPart::new()
        }
    }

    // .typedb.protocol.ThingType.GetInstances.ResPart thing_type_get_instances_res_part = 300;


    pub fn get_thing_type_get_instances_res_part(&self) -> &ThingType_GetInstances_ResPart {
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::thing_type_get_instances_res_part(ref v)) => v,
            _ => ThingType_GetInstances_ResPart::default_instance(),
        }
    }
    pub fn clear_thing_type_get_instances_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_thing_type_get_instances_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::thing_type_get_instances_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_type_get_instances_res_part(&mut self, v: ThingType_GetInstances_ResPart) {
        self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::thing_type_get_instances_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_type_get_instances_res_part(&mut self) -> &mut ThingType_GetInstances_ResPart {
        if let ::std::option::Option::Some(Type_ResPart_oneof_res::thing_type_get_instances_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::thing_type_get_instances_res_part(ThingType_GetInstances_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::thing_type_get_instances_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_type_get_instances_res_part(&mut self) -> ThingType_GetInstances_ResPart {
        if self.has_thing_type_get_instances_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(Type_ResPart_oneof_res::thing_type_get_instances_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            ThingType_GetInstances_ResPart::new()
        }
    }

    // .typedb.protocol.ThingType.GetOwns.ResPart thing_type_get_owns_res_part = 301;


    pub fn get_thing_type_get_owns_res_part(&self) -> &ThingType_GetOwns_ResPart {
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::thing_type_get_owns_res_part(ref v)) => v,
            _ => ThingType_GetOwns_ResPart::default_instance(),
        }
    }
    pub fn clear_thing_type_get_owns_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_thing_type_get_owns_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::thing_type_get_owns_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_type_get_owns_res_part(&mut self, v: ThingType_GetOwns_ResPart) {
        self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::thing_type_get_owns_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_type_get_owns_res_part(&mut self) -> &mut ThingType_GetOwns_ResPart {
        if let ::std::option::Option::Some(Type_ResPart_oneof_res::thing_type_get_owns_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::thing_type_get_owns_res_part(ThingType_GetOwns_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::thing_type_get_owns_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_type_get_owns_res_part(&mut self) -> ThingType_GetOwns_ResPart {
        if self.has_thing_type_get_owns_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(Type_ResPart_oneof_res::thing_type_get_owns_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            ThingType_GetOwns_ResPart::new()
        }
    }

    // .typedb.protocol.ThingType.GetPlays.ResPart thing_type_get_plays_res_part = 302;


    pub fn get_thing_type_get_plays_res_part(&self) -> &ThingType_GetPlays_ResPart {
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::thing_type_get_plays_res_part(ref v)) => v,
            _ => ThingType_GetPlays_ResPart::default_instance(),
        }
    }
    pub fn clear_thing_type_get_plays_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_thing_type_get_plays_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::thing_type_get_plays_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_type_get_plays_res_part(&mut self, v: ThingType_GetPlays_ResPart) {
        self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::thing_type_get_plays_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_type_get_plays_res_part(&mut self) -> &mut ThingType_GetPlays_ResPart {
        if let ::std::option::Option::Some(Type_ResPart_oneof_res::thing_type_get_plays_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::thing_type_get_plays_res_part(ThingType_GetPlays_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::thing_type_get_plays_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_type_get_plays_res_part(&mut self) -> ThingType_GetPlays_ResPart {
        if self.has_thing_type_get_plays_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(Type_ResPart_oneof_res::thing_type_get_plays_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            ThingType_GetPlays_ResPart::new()
        }
    }

    // .typedb.protocol.RelationType.GetRelates.ResPart relation_type_get_relates_res_part = 500;


    pub fn get_relation_type_get_relates_res_part(&self) -> &RelationType_GetRelates_ResPart {
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::relation_type_get_relates_res_part(ref v)) => v,
            _ => RelationType_GetRelates_ResPart::default_instance(),
        }
    }
    pub fn clear_relation_type_get_relates_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_relation_type_get_relates_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::relation_type_get_relates_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_relation_type_get_relates_res_part(&mut self, v: RelationType_GetRelates_ResPart) {
        self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::relation_type_get_relates_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_relation_type_get_relates_res_part(&mut self) -> &mut RelationType_GetRelates_ResPart {
        if let ::std::option::Option::Some(Type_ResPart_oneof_res::relation_type_get_relates_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::relation_type_get_relates_res_part(RelationType_GetRelates_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::relation_type_get_relates_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_relation_type_get_relates_res_part(&mut self) -> RelationType_GetRelates_ResPart {
        if self.has_relation_type_get_relates_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(Type_ResPart_oneof_res::relation_type_get_relates_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            RelationType_GetRelates_ResPart::new()
        }
    }

    // .typedb.protocol.AttributeType.GetOwners.ResPart attribute_type_get_owners_res_part = 600;


    pub fn get_attribute_type_get_owners_res_part(&self) -> &AttributeType_GetOwners_ResPart {
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::attribute_type_get_owners_res_part(ref v)) => v,
            _ => AttributeType_GetOwners_ResPart::default_instance(),
        }
    }
    pub fn clear_attribute_type_get_owners_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_attribute_type_get_owners_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::attribute_type_get_owners_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_attribute_type_get_owners_res_part(&mut self, v: AttributeType_GetOwners_ResPart) {
        self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::attribute_type_get_owners_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_attribute_type_get_owners_res_part(&mut self) -> &mut AttributeType_GetOwners_ResPart {
        if let ::std::option::Option::Some(Type_ResPart_oneof_res::attribute_type_get_owners_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::attribute_type_get_owners_res_part(AttributeType_GetOwners_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_ResPart_oneof_res::attribute_type_get_owners_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_attribute_type_get_owners_res_part(&mut self) -> AttributeType_GetOwners_ResPart {
        if self.has_attribute_type_get_owners_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(Type_ResPart_oneof_res::attribute_type_get_owners_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            AttributeType_GetOwners_ResPart::new()
        }
    }
}

impl ::protobuf::Message for Type_ResPart {
    fn is_initialized(&self) -> bool {
        if let Some(Type_ResPart_oneof_res::type_get_supertypes_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_ResPart_oneof_res::type_get_subtypes_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_ResPart_oneof_res::role_type_get_relation_types_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_ResPart_oneof_res::role_type_get_players_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_ResPart_oneof_res::thing_type_get_instances_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_ResPart_oneof_res::thing_type_get_owns_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_ResPart_oneof_res::thing_type_get_plays_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_ResPart_oneof_res::relation_type_get_relates_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_ResPart_oneof_res::attribute_type_get_owners_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                100 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::type_get_supertypes_res_part(is.read_message()?));
                },
                101 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::type_get_subtypes_res_part(is.read_message()?));
                },
                200 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::role_type_get_relation_types_res_part(is.read_message()?));
                },
                201 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::role_type_get_players_res_part(is.read_message()?));
                },
                300 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::thing_type_get_instances_res_part(is.read_message()?));
                },
                301 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::thing_type_get_owns_res_part(is.read_message()?));
                },
                302 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::thing_type_get_plays_res_part(is.read_message()?));
                },
                500 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::relation_type_get_relates_res_part(is.read_message()?));
                },
                600 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_ResPart_oneof_res::attribute_type_get_owners_res_part(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &Type_ResPart_oneof_res::type_get_supertypes_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_ResPart_oneof_res::type_get_subtypes_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_ResPart_oneof_res::role_type_get_relation_types_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_ResPart_oneof_res::role_type_get_players_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_ResPart_oneof_res::thing_type_get_instances_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_ResPart_oneof_res::thing_type_get_owns_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_ResPart_oneof_res::thing_type_get_plays_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_ResPart_oneof_res::relation_type_get_relates_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_ResPart_oneof_res::attribute_type_get_owners_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &Type_ResPart_oneof_res::type_get_supertypes_res_part(ref v) => {
                    os.write_tag(100, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_ResPart_oneof_res::type_get_subtypes_res_part(ref v) => {
                    os.write_tag(101, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_ResPart_oneof_res::role_type_get_relation_types_res_part(ref v) => {
                    os.write_tag(200, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_ResPart_oneof_res::role_type_get_players_res_part(ref v) => {
                    os.write_tag(201, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_ResPart_oneof_res::thing_type_get_instances_res_part(ref v) => {
                    os.write_tag(300, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_ResPart_oneof_res::thing_type_get_owns_res_part(ref v) => {
                    os.write_tag(301, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_ResPart_oneof_res::thing_type_get_plays_res_part(ref v) => {
                    os.write_tag(302, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_ResPart_oneof_res::relation_type_get_relates_res_part(ref v) => {
                    os.write_tag(500, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_ResPart_oneof_res::attribute_type_get_owners_res_part(ref v) => {
                    os.write_tag(600, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_ResPart {
        Type_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type_GetSupertypes_ResPart>(
                    "type_get_supertypes_res_part",
                    Type_ResPart::has_type_get_supertypes_res_part,
                    Type_ResPart::get_type_get_supertypes_res_part,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type_GetSubtypes_ResPart>(
                    "type_get_subtypes_res_part",
                    Type_ResPart::has_type_get_subtypes_res_part,
                    Type_ResPart::get_type_get_subtypes_res_part,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RoleType_GetRelationTypes_ResPart>(
                    "role_type_get_relation_types_res_part",
                    Type_ResPart::has_role_type_get_relation_types_res_part,
                    Type_ResPart::get_role_type_get_relation_types_res_part,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RoleType_GetPlayers_ResPart>(
                    "role_type_get_players_res_part",
                    Type_ResPart::has_role_type_get_players_res_part,
                    Type_ResPart::get_role_type_get_players_res_part,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ThingType_GetInstances_ResPart>(
                    "thing_type_get_instances_res_part",
                    Type_ResPart::has_thing_type_get_instances_res_part,
                    Type_ResPart::get_thing_type_get_instances_res_part,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ThingType_GetOwns_ResPart>(
                    "thing_type_get_owns_res_part",
                    Type_ResPart::has_thing_type_get_owns_res_part,
                    Type_ResPart::get_thing_type_get_owns_res_part,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ThingType_GetPlays_ResPart>(
                    "thing_type_get_plays_res_part",
                    Type_ResPart::has_thing_type_get_plays_res_part,
                    Type_ResPart::get_thing_type_get_plays_res_part,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RelationType_GetRelates_ResPart>(
                    "relation_type_get_relates_res_part",
                    Type_ResPart::has_relation_type_get_relates_res_part,
                    Type_ResPart::get_relation_type_get_relates_res_part,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AttributeType_GetOwners_ResPart>(
                    "attribute_type_get_owners_res_part",
                    Type_ResPart::has_attribute_type_get_owners_res_part,
                    Type_ResPart::get_attribute_type_get_owners_res_part,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Type_ResPart>(
                    "Type_ResPart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_ResPart {
        static mut instance: ::protobuf::lazy::Lazy<Type_ResPart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_ResPart,
        };
        unsafe {
            instance.get(Type_ResPart::new)
        }
    }
}

impl ::protobuf::Clear for Type_ResPart {
    fn clear(&mut self) {
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_Delete {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_Delete {
    fn default() -> &'a Type_Delete {
        <Type_Delete as ::protobuf::Message>::default_instance()
    }
}

impl Type_Delete {
    pub fn new() -> Type_Delete {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Type_Delete {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_Delete {
        Type_Delete::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Type_Delete>(
                    "Type_Delete",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_Delete {
        static mut instance: ::protobuf::lazy::Lazy<Type_Delete> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_Delete,
        };
        unsafe {
            instance.get(Type_Delete::new)
        }
    }
}

impl ::protobuf::Clear for Type_Delete {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_Delete {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_Delete {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_Delete_Req {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_Delete_Req {
    fn default() -> &'a Type_Delete_Req {
        <Type_Delete_Req as ::protobuf::Message>::default_instance()
    }
}

impl Type_Delete_Req {
    pub fn new() -> Type_Delete_Req {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Type_Delete_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_Delete_Req {
        Type_Delete_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Type_Delete_Req>(
                    "Type_Delete_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_Delete_Req {
        static mut instance: ::protobuf::lazy::Lazy<Type_Delete_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_Delete_Req,
        };
        unsafe {
            instance.get(Type_Delete_Req::new)
        }
    }
}

impl ::protobuf::Clear for Type_Delete_Req {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_Delete_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_Delete_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_Delete_Res {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_Delete_Res {
    fn default() -> &'a Type_Delete_Res {
        <Type_Delete_Res as ::protobuf::Message>::default_instance()
    }
}

impl Type_Delete_Res {
    pub fn new() -> Type_Delete_Res {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Type_Delete_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_Delete_Res {
        Type_Delete_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Type_Delete_Res>(
                    "Type_Delete_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_Delete_Res {
        static mut instance: ::protobuf::lazy::Lazy<Type_Delete_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_Delete_Res,
        };
        unsafe {
            instance.get(Type_Delete_Res::new)
        }
    }
}

impl ::protobuf::Clear for Type_Delete_Res {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_Delete_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_Delete_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_SetLabel {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_SetLabel {
    fn default() -> &'a Type_SetLabel {
        <Type_SetLabel as ::protobuf::Message>::default_instance()
    }
}

impl Type_SetLabel {
    pub fn new() -> Type_SetLabel {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Type_SetLabel {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_SetLabel {
        Type_SetLabel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Type_SetLabel>(
                    "Type_SetLabel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_SetLabel {
        static mut instance: ::protobuf::lazy::Lazy<Type_SetLabel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_SetLabel,
        };
        unsafe {
            instance.get(Type_SetLabel::new)
        }
    }
}

impl ::protobuf::Clear for Type_SetLabel {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_SetLabel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_SetLabel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_SetLabel_Req {
    // message fields
    pub label: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_SetLabel_Req {
    fn default() -> &'a Type_SetLabel_Req {
        <Type_SetLabel_Req as ::protobuf::Message>::default_instance()
    }
}

impl Type_SetLabel_Req {
    pub fn new() -> Type_SetLabel_Req {
        ::std::default::Default::default()
    }

    // string label = 1;


    pub fn get_label(&self) -> &str {
        &self.label
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        &mut self.label
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Type_SetLabel_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.label);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.label.is_empty() {
            os.write_string(1, &self.label)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_SetLabel_Req {
        Type_SetLabel_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "label",
                    |m: &Type_SetLabel_Req| { &m.label },
                    |m: &mut Type_SetLabel_Req| { &mut m.label },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Type_SetLabel_Req>(
                    "Type_SetLabel_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_SetLabel_Req {
        static mut instance: ::protobuf::lazy::Lazy<Type_SetLabel_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_SetLabel_Req,
        };
        unsafe {
            instance.get(Type_SetLabel_Req::new)
        }
    }
}

impl ::protobuf::Clear for Type_SetLabel_Req {
    fn clear(&mut self) {
        self.label.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_SetLabel_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_SetLabel_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_SetLabel_Res {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_SetLabel_Res {
    fn default() -> &'a Type_SetLabel_Res {
        <Type_SetLabel_Res as ::protobuf::Message>::default_instance()
    }
}

impl Type_SetLabel_Res {
    pub fn new() -> Type_SetLabel_Res {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Type_SetLabel_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_SetLabel_Res {
        Type_SetLabel_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Type_SetLabel_Res>(
                    "Type_SetLabel_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_SetLabel_Res {
        static mut instance: ::protobuf::lazy::Lazy<Type_SetLabel_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_SetLabel_Res,
        };
        unsafe {
            instance.get(Type_SetLabel_Res::new)
        }
    }
}

impl ::protobuf::Clear for Type_SetLabel_Res {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_SetLabel_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_SetLabel_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_IsAbstract {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_IsAbstract {
    fn default() -> &'a Type_IsAbstract {
        <Type_IsAbstract as ::protobuf::Message>::default_instance()
    }
}

impl Type_IsAbstract {
    pub fn new() -> Type_IsAbstract {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Type_IsAbstract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_IsAbstract {
        Type_IsAbstract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Type_IsAbstract>(
                    "Type_IsAbstract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_IsAbstract {
        static mut instance: ::protobuf::lazy::Lazy<Type_IsAbstract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_IsAbstract,
        };
        unsafe {
            instance.get(Type_IsAbstract::new)
        }
    }
}

impl ::protobuf::Clear for Type_IsAbstract {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_IsAbstract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_IsAbstract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_IsAbstract_Req {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_IsAbstract_Req {
    fn default() -> &'a Type_IsAbstract_Req {
        <Type_IsAbstract_Req as ::protobuf::Message>::default_instance()
    }
}

impl Type_IsAbstract_Req {
    pub fn new() -> Type_IsAbstract_Req {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Type_IsAbstract_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_IsAbstract_Req {
        Type_IsAbstract_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Type_IsAbstract_Req>(
                    "Type_IsAbstract_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_IsAbstract_Req {
        static mut instance: ::protobuf::lazy::Lazy<Type_IsAbstract_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_IsAbstract_Req,
        };
        unsafe {
            instance.get(Type_IsAbstract_Req::new)
        }
    }
}

impl ::protobuf::Clear for Type_IsAbstract_Req {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_IsAbstract_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_IsAbstract_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_IsAbstract_Res {
    // message fields
    pub field_abstract: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_IsAbstract_Res {
    fn default() -> &'a Type_IsAbstract_Res {
        <Type_IsAbstract_Res as ::protobuf::Message>::default_instance()
    }
}

impl Type_IsAbstract_Res {
    pub fn new() -> Type_IsAbstract_Res {
        ::std::default::Default::default()
    }

    // bool abstract = 1;


    pub fn get_field_abstract(&self) -> bool {
        self.field_abstract
    }
    pub fn clear_field_abstract(&mut self) {
        self.field_abstract = false;
    }

    // Param is passed by value, moved
    pub fn set_field_abstract(&mut self, v: bool) {
        self.field_abstract = v;
    }
}

impl ::protobuf::Message for Type_IsAbstract_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.field_abstract = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_abstract != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_abstract != false {
            os.write_bool(1, self.field_abstract)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_IsAbstract_Res {
        Type_IsAbstract_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "abstract",
                    |m: &Type_IsAbstract_Res| { &m.field_abstract },
                    |m: &mut Type_IsAbstract_Res| { &mut m.field_abstract },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Type_IsAbstract_Res>(
                    "Type_IsAbstract_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_IsAbstract_Res {
        static mut instance: ::protobuf::lazy::Lazy<Type_IsAbstract_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_IsAbstract_Res,
        };
        unsafe {
            instance.get(Type_IsAbstract_Res::new)
        }
    }
}

impl ::protobuf::Clear for Type_IsAbstract_Res {
    fn clear(&mut self) {
        self.field_abstract = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_IsAbstract_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_IsAbstract_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_GetSupertype {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_GetSupertype {
    fn default() -> &'a Type_GetSupertype {
        <Type_GetSupertype as ::protobuf::Message>::default_instance()
    }
}

impl Type_GetSupertype {
    pub fn new() -> Type_GetSupertype {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Type_GetSupertype {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_GetSupertype {
        Type_GetSupertype::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Type_GetSupertype>(
                    "Type_GetSupertype",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_GetSupertype {
        static mut instance: ::protobuf::lazy::Lazy<Type_GetSupertype> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_GetSupertype,
        };
        unsafe {
            instance.get(Type_GetSupertype::new)
        }
    }
}

impl ::protobuf::Clear for Type_GetSupertype {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_GetSupertype {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_GetSupertype {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_GetSupertype_Req {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_GetSupertype_Req {
    fn default() -> &'a Type_GetSupertype_Req {
        <Type_GetSupertype_Req as ::protobuf::Message>::default_instance()
    }
}

impl Type_GetSupertype_Req {
    pub fn new() -> Type_GetSupertype_Req {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Type_GetSupertype_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_GetSupertype_Req {
        Type_GetSupertype_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Type_GetSupertype_Req>(
                    "Type_GetSupertype_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_GetSupertype_Req {
        static mut instance: ::protobuf::lazy::Lazy<Type_GetSupertype_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_GetSupertype_Req,
        };
        unsafe {
            instance.get(Type_GetSupertype_Req::new)
        }
    }
}

impl ::protobuf::Clear for Type_GetSupertype_Req {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_GetSupertype_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_GetSupertype_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_GetSupertype_Res {
    // message oneof groups
    pub res: ::std::option::Option<Type_GetSupertype_Res_oneof_res>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_GetSupertype_Res {
    fn default() -> &'a Type_GetSupertype_Res {
        <Type_GetSupertype_Res as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Type_GetSupertype_Res_oneof_res {
    field_type(Type),
}

impl Type_GetSupertype_Res {
    pub fn new() -> Type_GetSupertype_Res {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Type type = 1;


    pub fn get_field_type(&self) -> &Type {
        match self.res {
            ::std::option::Option::Some(Type_GetSupertype_Res_oneof_res::field_type(ref v)) => v,
            _ => Type::default_instance(),
        }
    }
    pub fn clear_field_type(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Type_GetSupertype_Res_oneof_res::field_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Type) {
        self.res = ::std::option::Option::Some(Type_GetSupertype_Res_oneof_res::field_type(v))
    }

    // Mutable pointer to the field.
    pub fn mut_field_type(&mut self) -> &mut Type {
        if let ::std::option::Option::Some(Type_GetSupertype_Res_oneof_res::field_type(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Type_GetSupertype_Res_oneof_res::field_type(Type::new()));
        }
        match self.res {
            ::std::option::Option::Some(Type_GetSupertype_Res_oneof_res::field_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_field_type(&mut self) -> Type {
        if self.has_field_type() {
            match self.res.take() {
                ::std::option::Option::Some(Type_GetSupertype_Res_oneof_res::field_type(v)) => v,
                _ => panic!(),
            }
        } else {
            Type::new()
        }
    }
}

impl ::protobuf::Message for Type_GetSupertype_Res {
    fn is_initialized(&self) -> bool {
        if let Some(Type_GetSupertype_Res_oneof_res::field_type(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Type_GetSupertype_Res_oneof_res::field_type(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &Type_GetSupertype_Res_oneof_res::field_type(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &Type_GetSupertype_Res_oneof_res::field_type(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_GetSupertype_Res {
        Type_GetSupertype_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type>(
                    "type",
                    Type_GetSupertype_Res::has_field_type,
                    Type_GetSupertype_Res::get_field_type,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Type_GetSupertype_Res>(
                    "Type_GetSupertype_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_GetSupertype_Res {
        static mut instance: ::protobuf::lazy::Lazy<Type_GetSupertype_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_GetSupertype_Res,
        };
        unsafe {
            instance.get(Type_GetSupertype_Res::new)
        }
    }
}

impl ::protobuf::Clear for Type_GetSupertype_Res {
    fn clear(&mut self) {
        self.res = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_GetSupertype_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_GetSupertype_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_SetSupertype {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_SetSupertype {
    fn default() -> &'a Type_SetSupertype {
        <Type_SetSupertype as ::protobuf::Message>::default_instance()
    }
}

impl Type_SetSupertype {
    pub fn new() -> Type_SetSupertype {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Type_SetSupertype {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_SetSupertype {
        Type_SetSupertype::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Type_SetSupertype>(
                    "Type_SetSupertype",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_SetSupertype {
        static mut instance: ::protobuf::lazy::Lazy<Type_SetSupertype> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_SetSupertype,
        };
        unsafe {
            instance.get(Type_SetSupertype::new)
        }
    }
}

impl ::protobuf::Clear for Type_SetSupertype {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_SetSupertype {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_SetSupertype {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_SetSupertype_Req {
    // message fields
    pub field_type: ::protobuf::SingularPtrField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_SetSupertype_Req {
    fn default() -> &'a Type_SetSupertype_Req {
        <Type_SetSupertype_Req as ::protobuf::Message>::default_instance()
    }
}

impl Type_SetSupertype_Req {
    pub fn new() -> Type_SetSupertype_Req {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Type type = 1;


    pub fn get_field_type(&self) -> &Type {
        self.field_type.as_ref().unwrap_or_else(|| Type::default_instance())
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Type) {
        self.field_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut Type {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> Type {
        self.field_type.take().unwrap_or_else(|| Type::new())
    }
}

impl ::protobuf::Message for Type_SetSupertype_Req {
    fn is_initialized(&self) -> bool {
        for v in &self.field_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_SetSupertype_Req {
        Type_SetSupertype_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "type",
                    |m: &Type_SetSupertype_Req| { &m.field_type },
                    |m: &mut Type_SetSupertype_Req| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Type_SetSupertype_Req>(
                    "Type_SetSupertype_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_SetSupertype_Req {
        static mut instance: ::protobuf::lazy::Lazy<Type_SetSupertype_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_SetSupertype_Req,
        };
        unsafe {
            instance.get(Type_SetSupertype_Req::new)
        }
    }
}

impl ::protobuf::Clear for Type_SetSupertype_Req {
    fn clear(&mut self) {
        self.field_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_SetSupertype_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_SetSupertype_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_SetSupertype_Res {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_SetSupertype_Res {
    fn default() -> &'a Type_SetSupertype_Res {
        <Type_SetSupertype_Res as ::protobuf::Message>::default_instance()
    }
}

impl Type_SetSupertype_Res {
    pub fn new() -> Type_SetSupertype_Res {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Type_SetSupertype_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_SetSupertype_Res {
        Type_SetSupertype_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Type_SetSupertype_Res>(
                    "Type_SetSupertype_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_SetSupertype_Res {
        static mut instance: ::protobuf::lazy::Lazy<Type_SetSupertype_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_SetSupertype_Res,
        };
        unsafe {
            instance.get(Type_SetSupertype_Res::new)
        }
    }
}

impl ::protobuf::Clear for Type_SetSupertype_Res {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_SetSupertype_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_SetSupertype_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_GetSupertypes {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_GetSupertypes {
    fn default() -> &'a Type_GetSupertypes {
        <Type_GetSupertypes as ::protobuf::Message>::default_instance()
    }
}

impl Type_GetSupertypes {
    pub fn new() -> Type_GetSupertypes {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Type_GetSupertypes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_GetSupertypes {
        Type_GetSupertypes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Type_GetSupertypes>(
                    "Type_GetSupertypes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_GetSupertypes {
        static mut instance: ::protobuf::lazy::Lazy<Type_GetSupertypes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_GetSupertypes,
        };
        unsafe {
            instance.get(Type_GetSupertypes::new)
        }
    }
}

impl ::protobuf::Clear for Type_GetSupertypes {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_GetSupertypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_GetSupertypes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_GetSupertypes_Req {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_GetSupertypes_Req {
    fn default() -> &'a Type_GetSupertypes_Req {
        <Type_GetSupertypes_Req as ::protobuf::Message>::default_instance()
    }
}

impl Type_GetSupertypes_Req {
    pub fn new() -> Type_GetSupertypes_Req {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Type_GetSupertypes_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_GetSupertypes_Req {
        Type_GetSupertypes_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Type_GetSupertypes_Req>(
                    "Type_GetSupertypes_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_GetSupertypes_Req {
        static mut instance: ::protobuf::lazy::Lazy<Type_GetSupertypes_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_GetSupertypes_Req,
        };
        unsafe {
            instance.get(Type_GetSupertypes_Req::new)
        }
    }
}

impl ::protobuf::Clear for Type_GetSupertypes_Req {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_GetSupertypes_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_GetSupertypes_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_GetSupertypes_ResPart {
    // message fields
    pub types: ::protobuf::RepeatedField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_GetSupertypes_ResPart {
    fn default() -> &'a Type_GetSupertypes_ResPart {
        <Type_GetSupertypes_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl Type_GetSupertypes_ResPart {
    pub fn new() -> Type_GetSupertypes_ResPart {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.Type types = 1;


    pub fn get_types(&self) -> &[Type] {
        &self.types
    }
    pub fn clear_types(&mut self) {
        self.types.clear();
    }

    // Param is passed by value, moved
    pub fn set_types(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_types(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.types
    }

    // Take field
    pub fn take_types(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.types, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Type_GetSupertypes_ResPart {
    fn is_initialized(&self) -> bool {
        for v in &self.types {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.types {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_GetSupertypes_ResPart {
        Type_GetSupertypes_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "types",
                    |m: &Type_GetSupertypes_ResPart| { &m.types },
                    |m: &mut Type_GetSupertypes_ResPart| { &mut m.types },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Type_GetSupertypes_ResPart>(
                    "Type_GetSupertypes_ResPart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_GetSupertypes_ResPart {
        static mut instance: ::protobuf::lazy::Lazy<Type_GetSupertypes_ResPart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_GetSupertypes_ResPart,
        };
        unsafe {
            instance.get(Type_GetSupertypes_ResPart::new)
        }
    }
}

impl ::protobuf::Clear for Type_GetSupertypes_ResPart {
    fn clear(&mut self) {
        self.types.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_GetSupertypes_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_GetSupertypes_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_GetSubtypes {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_GetSubtypes {
    fn default() -> &'a Type_GetSubtypes {
        <Type_GetSubtypes as ::protobuf::Message>::default_instance()
    }
}

impl Type_GetSubtypes {
    pub fn new() -> Type_GetSubtypes {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Type_GetSubtypes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_GetSubtypes {
        Type_GetSubtypes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Type_GetSubtypes>(
                    "Type_GetSubtypes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_GetSubtypes {
        static mut instance: ::protobuf::lazy::Lazy<Type_GetSubtypes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_GetSubtypes,
        };
        unsafe {
            instance.get(Type_GetSubtypes::new)
        }
    }
}

impl ::protobuf::Clear for Type_GetSubtypes {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_GetSubtypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_GetSubtypes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_GetSubtypes_Req {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_GetSubtypes_Req {
    fn default() -> &'a Type_GetSubtypes_Req {
        <Type_GetSubtypes_Req as ::protobuf::Message>::default_instance()
    }
}

impl Type_GetSubtypes_Req {
    pub fn new() -> Type_GetSubtypes_Req {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Type_GetSubtypes_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_GetSubtypes_Req {
        Type_GetSubtypes_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Type_GetSubtypes_Req>(
                    "Type_GetSubtypes_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_GetSubtypes_Req {
        static mut instance: ::protobuf::lazy::Lazy<Type_GetSubtypes_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_GetSubtypes_Req,
        };
        unsafe {
            instance.get(Type_GetSubtypes_Req::new)
        }
    }
}

impl ::protobuf::Clear for Type_GetSubtypes_Req {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_GetSubtypes_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_GetSubtypes_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_GetSubtypes_ResPart {
    // message fields
    pub types: ::protobuf::RepeatedField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_GetSubtypes_ResPart {
    fn default() -> &'a Type_GetSubtypes_ResPart {
        <Type_GetSubtypes_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl Type_GetSubtypes_ResPart {
    pub fn new() -> Type_GetSubtypes_ResPart {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.Type types = 1;


    pub fn get_types(&self) -> &[Type] {
        &self.types
    }
    pub fn clear_types(&mut self) {
        self.types.clear();
    }

    // Param is passed by value, moved
    pub fn set_types(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_types(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.types
    }

    // Take field
    pub fn take_types(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.types, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Type_GetSubtypes_ResPart {
    fn is_initialized(&self) -> bool {
        for v in &self.types {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.types {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_GetSubtypes_ResPart {
        Type_GetSubtypes_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "types",
                    |m: &Type_GetSubtypes_ResPart| { &m.types },
                    |m: &mut Type_GetSubtypes_ResPart| { &mut m.types },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Type_GetSubtypes_ResPart>(
                    "Type_GetSubtypes_ResPart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type_GetSubtypes_ResPart {
        static mut instance: ::protobuf::lazy::Lazy<Type_GetSubtypes_ResPart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type_GetSubtypes_ResPart,
        };
        unsafe {
            instance.get(Type_GetSubtypes_ResPart::new)
        }
    }
}

impl ::protobuf::Clear for Type_GetSubtypes_ResPart {
    fn clear(&mut self) {
        self.types.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_GetSubtypes_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_GetSubtypes_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Type_Encoding {
    THING_TYPE = 0,
    ENTITY_TYPE = 1,
    RELATION_TYPE = 2,
    ATTRIBUTE_TYPE = 3,
    ROLE_TYPE = 4,
}

impl ::protobuf::ProtobufEnum for Type_Encoding {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Type_Encoding> {
        match value {
            0 => ::std::option::Option::Some(Type_Encoding::THING_TYPE),
            1 => ::std::option::Option::Some(Type_Encoding::ENTITY_TYPE),
            2 => ::std::option::Option::Some(Type_Encoding::RELATION_TYPE),
            3 => ::std::option::Option::Some(Type_Encoding::ATTRIBUTE_TYPE),
            4 => ::std::option::Option::Some(Type_Encoding::ROLE_TYPE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Type_Encoding] = &[
            Type_Encoding::THING_TYPE,
            Type_Encoding::ENTITY_TYPE,
            Type_Encoding::RELATION_TYPE,
            Type_Encoding::ATTRIBUTE_TYPE,
            Type_Encoding::ROLE_TYPE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Type_Encoding", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Type_Encoding {
}

impl ::std::default::Default for Type_Encoding {
    fn default() -> Self {
        Type_Encoding::THING_TYPE
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_Encoding {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoleType {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoleType {
    fn default() -> &'a RoleType {
        <RoleType as ::protobuf::Message>::default_instance()
    }
}

impl RoleType {
    pub fn new() -> RoleType {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RoleType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoleType {
        RoleType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RoleType>(
                    "RoleType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RoleType {
        static mut instance: ::protobuf::lazy::Lazy<RoleType> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RoleType,
        };
        unsafe {
            instance.get(RoleType::new)
        }
    }
}

impl ::protobuf::Clear for RoleType {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoleType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoleType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoleType_GetRelationTypes {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoleType_GetRelationTypes {
    fn default() -> &'a RoleType_GetRelationTypes {
        <RoleType_GetRelationTypes as ::protobuf::Message>::default_instance()
    }
}

impl RoleType_GetRelationTypes {
    pub fn new() -> RoleType_GetRelationTypes {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RoleType_GetRelationTypes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoleType_GetRelationTypes {
        RoleType_GetRelationTypes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RoleType_GetRelationTypes>(
                    "RoleType_GetRelationTypes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RoleType_GetRelationTypes {
        static mut instance: ::protobuf::lazy::Lazy<RoleType_GetRelationTypes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RoleType_GetRelationTypes,
        };
        unsafe {
            instance.get(RoleType_GetRelationTypes::new)
        }
    }
}

impl ::protobuf::Clear for RoleType_GetRelationTypes {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoleType_GetRelationTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoleType_GetRelationTypes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoleType_GetRelationTypes_Req {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoleType_GetRelationTypes_Req {
    fn default() -> &'a RoleType_GetRelationTypes_Req {
        <RoleType_GetRelationTypes_Req as ::protobuf::Message>::default_instance()
    }
}

impl RoleType_GetRelationTypes_Req {
    pub fn new() -> RoleType_GetRelationTypes_Req {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RoleType_GetRelationTypes_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoleType_GetRelationTypes_Req {
        RoleType_GetRelationTypes_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RoleType_GetRelationTypes_Req>(
                    "RoleType_GetRelationTypes_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RoleType_GetRelationTypes_Req {
        static mut instance: ::protobuf::lazy::Lazy<RoleType_GetRelationTypes_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RoleType_GetRelationTypes_Req,
        };
        unsafe {
            instance.get(RoleType_GetRelationTypes_Req::new)
        }
    }
}

impl ::protobuf::Clear for RoleType_GetRelationTypes_Req {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoleType_GetRelationTypes_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoleType_GetRelationTypes_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoleType_GetRelationTypes_ResPart {
    // message fields
    pub relation_types: ::protobuf::RepeatedField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoleType_GetRelationTypes_ResPart {
    fn default() -> &'a RoleType_GetRelationTypes_ResPart {
        <RoleType_GetRelationTypes_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl RoleType_GetRelationTypes_ResPart {
    pub fn new() -> RoleType_GetRelationTypes_ResPart {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.Type relation_types = 1;


    pub fn get_relation_types(&self) -> &[Type] {
        &self.relation_types
    }
    pub fn clear_relation_types(&mut self) {
        self.relation_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_relation_types(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.relation_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_relation_types(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.relation_types
    }

    // Take field
    pub fn take_relation_types(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.relation_types, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RoleType_GetRelationTypes_ResPart {
    fn is_initialized(&self) -> bool {
        for v in &self.relation_types {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.relation_types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.relation_types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.relation_types {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoleType_GetRelationTypes_ResPart {
        RoleType_GetRelationTypes_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "relation_types",
                    |m: &RoleType_GetRelationTypes_ResPart| { &m.relation_types },
                    |m: &mut RoleType_GetRelationTypes_ResPart| { &mut m.relation_types },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RoleType_GetRelationTypes_ResPart>(
                    "RoleType_GetRelationTypes_ResPart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RoleType_GetRelationTypes_ResPart {
        static mut instance: ::protobuf::lazy::Lazy<RoleType_GetRelationTypes_ResPart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RoleType_GetRelationTypes_ResPart,
        };
        unsafe {
            instance.get(RoleType_GetRelationTypes_ResPart::new)
        }
    }
}

impl ::protobuf::Clear for RoleType_GetRelationTypes_ResPart {
    fn clear(&mut self) {
        self.relation_types.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoleType_GetRelationTypes_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoleType_GetRelationTypes_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoleType_GetPlayers {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoleType_GetPlayers {
    fn default() -> &'a RoleType_GetPlayers {
        <RoleType_GetPlayers as ::protobuf::Message>::default_instance()
    }
}

impl RoleType_GetPlayers {
    pub fn new() -> RoleType_GetPlayers {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RoleType_GetPlayers {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoleType_GetPlayers {
        RoleType_GetPlayers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RoleType_GetPlayers>(
                    "RoleType_GetPlayers",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RoleType_GetPlayers {
        static mut instance: ::protobuf::lazy::Lazy<RoleType_GetPlayers> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RoleType_GetPlayers,
        };
        unsafe {
            instance.get(RoleType_GetPlayers::new)
        }
    }
}

impl ::protobuf::Clear for RoleType_GetPlayers {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoleType_GetPlayers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoleType_GetPlayers {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoleType_GetPlayers_Req {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoleType_GetPlayers_Req {
    fn default() -> &'a RoleType_GetPlayers_Req {
        <RoleType_GetPlayers_Req as ::protobuf::Message>::default_instance()
    }
}

impl RoleType_GetPlayers_Req {
    pub fn new() -> RoleType_GetPlayers_Req {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RoleType_GetPlayers_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoleType_GetPlayers_Req {
        RoleType_GetPlayers_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RoleType_GetPlayers_Req>(
                    "RoleType_GetPlayers_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RoleType_GetPlayers_Req {
        static mut instance: ::protobuf::lazy::Lazy<RoleType_GetPlayers_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RoleType_GetPlayers_Req,
        };
        unsafe {
            instance.get(RoleType_GetPlayers_Req::new)
        }
    }
}

impl ::protobuf::Clear for RoleType_GetPlayers_Req {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoleType_GetPlayers_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoleType_GetPlayers_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoleType_GetPlayers_ResPart {
    // message fields
    pub thing_types: ::protobuf::RepeatedField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoleType_GetPlayers_ResPart {
    fn default() -> &'a RoleType_GetPlayers_ResPart {
        <RoleType_GetPlayers_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl RoleType_GetPlayers_ResPart {
    pub fn new() -> RoleType_GetPlayers_ResPart {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.Type thing_types = 1;


    pub fn get_thing_types(&self) -> &[Type] {
        &self.thing_types
    }
    pub fn clear_thing_types(&mut self) {
        self.thing_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_thing_types(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.thing_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_thing_types(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.thing_types
    }

    // Take field
    pub fn take_thing_types(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.thing_types, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RoleType_GetPlayers_ResPart {
    fn is_initialized(&self) -> bool {
        for v in &self.thing_types {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.thing_types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.thing_types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.thing_types {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoleType_GetPlayers_ResPart {
        RoleType_GetPlayers_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "thing_types",
                    |m: &RoleType_GetPlayers_ResPart| { &m.thing_types },
                    |m: &mut RoleType_GetPlayers_ResPart| { &mut m.thing_types },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RoleType_GetPlayers_ResPart>(
                    "RoleType_GetPlayers_ResPart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RoleType_GetPlayers_ResPart {
        static mut instance: ::protobuf::lazy::Lazy<RoleType_GetPlayers_ResPart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RoleType_GetPlayers_ResPart,
        };
        unsafe {
            instance.get(RoleType_GetPlayers_ResPart::new)
        }
    }
}

impl ::protobuf::Clear for RoleType_GetPlayers_ResPart {
    fn clear(&mut self) {
        self.thing_types.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoleType_GetPlayers_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoleType_GetPlayers_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType {
    fn default() -> &'a ThingType {
        <ThingType as ::protobuf::Message>::default_instance()
    }
}

impl ThingType {
    pub fn new() -> ThingType {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ThingType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType {
        ThingType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ThingType>(
                    "ThingType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType {
        static mut instance: ::protobuf::lazy::Lazy<ThingType> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType,
        };
        unsafe {
            instance.get(ThingType::new)
        }
    }
}

impl ::protobuf::Clear for ThingType {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_SetAbstract {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_SetAbstract {
    fn default() -> &'a ThingType_SetAbstract {
        <ThingType_SetAbstract as ::protobuf::Message>::default_instance()
    }
}

impl ThingType_SetAbstract {
    pub fn new() -> ThingType_SetAbstract {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ThingType_SetAbstract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_SetAbstract {
        ThingType_SetAbstract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_SetAbstract>(
                    "ThingType_SetAbstract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_SetAbstract {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_SetAbstract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_SetAbstract,
        };
        unsafe {
            instance.get(ThingType_SetAbstract::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_SetAbstract {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_SetAbstract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_SetAbstract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_SetAbstract_Req {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_SetAbstract_Req {
    fn default() -> &'a ThingType_SetAbstract_Req {
        <ThingType_SetAbstract_Req as ::protobuf::Message>::default_instance()
    }
}

impl ThingType_SetAbstract_Req {
    pub fn new() -> ThingType_SetAbstract_Req {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ThingType_SetAbstract_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_SetAbstract_Req {
        ThingType_SetAbstract_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_SetAbstract_Req>(
                    "ThingType_SetAbstract_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_SetAbstract_Req {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_SetAbstract_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_SetAbstract_Req,
        };
        unsafe {
            instance.get(ThingType_SetAbstract_Req::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_SetAbstract_Req {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_SetAbstract_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_SetAbstract_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_SetAbstract_Res {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_SetAbstract_Res {
    fn default() -> &'a ThingType_SetAbstract_Res {
        <ThingType_SetAbstract_Res as ::protobuf::Message>::default_instance()
    }
}

impl ThingType_SetAbstract_Res {
    pub fn new() -> ThingType_SetAbstract_Res {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ThingType_SetAbstract_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_SetAbstract_Res {
        ThingType_SetAbstract_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_SetAbstract_Res>(
                    "ThingType_SetAbstract_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_SetAbstract_Res {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_SetAbstract_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_SetAbstract_Res,
        };
        unsafe {
            instance.get(ThingType_SetAbstract_Res::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_SetAbstract_Res {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_SetAbstract_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_SetAbstract_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_UnsetAbstract {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_UnsetAbstract {
    fn default() -> &'a ThingType_UnsetAbstract {
        <ThingType_UnsetAbstract as ::protobuf::Message>::default_instance()
    }
}

impl ThingType_UnsetAbstract {
    pub fn new() -> ThingType_UnsetAbstract {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ThingType_UnsetAbstract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_UnsetAbstract {
        ThingType_UnsetAbstract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_UnsetAbstract>(
                    "ThingType_UnsetAbstract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_UnsetAbstract {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_UnsetAbstract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_UnsetAbstract,
        };
        unsafe {
            instance.get(ThingType_UnsetAbstract::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_UnsetAbstract {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_UnsetAbstract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_UnsetAbstract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_UnsetAbstract_Req {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_UnsetAbstract_Req {
    fn default() -> &'a ThingType_UnsetAbstract_Req {
        <ThingType_UnsetAbstract_Req as ::protobuf::Message>::default_instance()
    }
}

impl ThingType_UnsetAbstract_Req {
    pub fn new() -> ThingType_UnsetAbstract_Req {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ThingType_UnsetAbstract_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_UnsetAbstract_Req {
        ThingType_UnsetAbstract_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_UnsetAbstract_Req>(
                    "ThingType_UnsetAbstract_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_UnsetAbstract_Req {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_UnsetAbstract_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_UnsetAbstract_Req,
        };
        unsafe {
            instance.get(ThingType_UnsetAbstract_Req::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_UnsetAbstract_Req {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_UnsetAbstract_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_UnsetAbstract_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_UnsetAbstract_Res {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_UnsetAbstract_Res {
    fn default() -> &'a ThingType_UnsetAbstract_Res {
        <ThingType_UnsetAbstract_Res as ::protobuf::Message>::default_instance()
    }
}

impl ThingType_UnsetAbstract_Res {
    pub fn new() -> ThingType_UnsetAbstract_Res {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ThingType_UnsetAbstract_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_UnsetAbstract_Res {
        ThingType_UnsetAbstract_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_UnsetAbstract_Res>(
                    "ThingType_UnsetAbstract_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_UnsetAbstract_Res {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_UnsetAbstract_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_UnsetAbstract_Res,
        };
        unsafe {
            instance.get(ThingType_UnsetAbstract_Res::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_UnsetAbstract_Res {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_UnsetAbstract_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_UnsetAbstract_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_GetInstances {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_GetInstances {
    fn default() -> &'a ThingType_GetInstances {
        <ThingType_GetInstances as ::protobuf::Message>::default_instance()
    }
}

impl ThingType_GetInstances {
    pub fn new() -> ThingType_GetInstances {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ThingType_GetInstances {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_GetInstances {
        ThingType_GetInstances::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_GetInstances>(
                    "ThingType_GetInstances",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_GetInstances {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_GetInstances> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_GetInstances,
        };
        unsafe {
            instance.get(ThingType_GetInstances::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_GetInstances {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_GetInstances {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_GetInstances {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_GetInstances_Req {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_GetInstances_Req {
    fn default() -> &'a ThingType_GetInstances_Req {
        <ThingType_GetInstances_Req as ::protobuf::Message>::default_instance()
    }
}

impl ThingType_GetInstances_Req {
    pub fn new() -> ThingType_GetInstances_Req {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ThingType_GetInstances_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_GetInstances_Req {
        ThingType_GetInstances_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_GetInstances_Req>(
                    "ThingType_GetInstances_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_GetInstances_Req {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_GetInstances_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_GetInstances_Req,
        };
        unsafe {
            instance.get(ThingType_GetInstances_Req::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_GetInstances_Req {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_GetInstances_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_GetInstances_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_GetInstances_ResPart {
    // message fields
    pub things: ::protobuf::RepeatedField<Thing>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_GetInstances_ResPart {
    fn default() -> &'a ThingType_GetInstances_ResPart {
        <ThingType_GetInstances_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl ThingType_GetInstances_ResPart {
    pub fn new() -> ThingType_GetInstances_ResPart {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.Thing things = 1;


    pub fn get_things(&self) -> &[Thing] {
        &self.things
    }
    pub fn clear_things(&mut self) {
        self.things.clear();
    }

    // Param is passed by value, moved
    pub fn set_things(&mut self, v: ::protobuf::RepeatedField<Thing>) {
        self.things = v;
    }

    // Mutable pointer to the field.
    pub fn mut_things(&mut self) -> &mut ::protobuf::RepeatedField<Thing> {
        &mut self.things
    }

    // Take field
    pub fn take_things(&mut self) -> ::protobuf::RepeatedField<Thing> {
        ::std::mem::replace(&mut self.things, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ThingType_GetInstances_ResPart {
    fn is_initialized(&self) -> bool {
        for v in &self.things {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.things)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.things {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.things {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_GetInstances_ResPart {
        ThingType_GetInstances_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Thing>>(
                    "things",
                    |m: &ThingType_GetInstances_ResPart| { &m.things },
                    |m: &mut ThingType_GetInstances_ResPart| { &mut m.things },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_GetInstances_ResPart>(
                    "ThingType_GetInstances_ResPart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_GetInstances_ResPart {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_GetInstances_ResPart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_GetInstances_ResPart,
        };
        unsafe {
            instance.get(ThingType_GetInstances_ResPart::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_GetInstances_ResPart {
    fn clear(&mut self) {
        self.things.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_GetInstances_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_GetInstances_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_GetOwns {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_GetOwns {
    fn default() -> &'a ThingType_GetOwns {
        <ThingType_GetOwns as ::protobuf::Message>::default_instance()
    }
}

impl ThingType_GetOwns {
    pub fn new() -> ThingType_GetOwns {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ThingType_GetOwns {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_GetOwns {
        ThingType_GetOwns::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_GetOwns>(
                    "ThingType_GetOwns",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_GetOwns {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_GetOwns> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_GetOwns,
        };
        unsafe {
            instance.get(ThingType_GetOwns::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_GetOwns {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_GetOwns {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_GetOwns {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_GetOwns_Req {
    // message fields
    pub keys_only: bool,
    // message oneof groups
    pub filter: ::std::option::Option<ThingType_GetOwns_Req_oneof_filter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_GetOwns_Req {
    fn default() -> &'a ThingType_GetOwns_Req {
        <ThingType_GetOwns_Req as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ThingType_GetOwns_Req_oneof_filter {
    value_type(AttributeType_ValueType),
}

impl ThingType_GetOwns_Req {
    pub fn new() -> ThingType_GetOwns_Req {
        ::std::default::Default::default()
    }

    // .typedb.protocol.AttributeType.ValueType value_type = 1;


    pub fn get_value_type(&self) -> AttributeType_ValueType {
        match self.filter {
            ::std::option::Option::Some(ThingType_GetOwns_Req_oneof_filter::value_type(v)) => v,
            _ => AttributeType_ValueType::OBJECT,
        }
    }
    pub fn clear_value_type(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_value_type(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(ThingType_GetOwns_Req_oneof_filter::value_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_value_type(&mut self, v: AttributeType_ValueType) {
        self.filter = ::std::option::Option::Some(ThingType_GetOwns_Req_oneof_filter::value_type(v))
    }

    // bool keys_only = 3;


    pub fn get_keys_only(&self) -> bool {
        self.keys_only
    }
    pub fn clear_keys_only(&mut self) {
        self.keys_only = false;
    }

    // Param is passed by value, moved
    pub fn set_keys_only(&mut self, v: bool) {
        self.keys_only = v;
    }
}

impl ::protobuf::Message for ThingType_GetOwns_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(ThingType_GetOwns_Req_oneof_filter::value_type(is.read_enum()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.keys_only = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.keys_only != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.filter {
            match v {
                &ThingType_GetOwns_Req_oneof_filter::value_type(v) => {
                    my_size += ::protobuf::rt::enum_size(1, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.keys_only != false {
            os.write_bool(3, self.keys_only)?;
        }
        if let ::std::option::Option::Some(ref v) = self.filter {
            match v {
                &ThingType_GetOwns_Req_oneof_filter::value_type(v) => {
                    os.write_enum(1, v.value())?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_GetOwns_Req {
        ThingType_GetOwns_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, AttributeType_ValueType>(
                    "value_type",
                    ThingType_GetOwns_Req::has_value_type,
                    ThingType_GetOwns_Req::get_value_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "keys_only",
                    |m: &ThingType_GetOwns_Req| { &m.keys_only },
                    |m: &mut ThingType_GetOwns_Req| { &mut m.keys_only },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_GetOwns_Req>(
                    "ThingType_GetOwns_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_GetOwns_Req {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_GetOwns_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_GetOwns_Req,
        };
        unsafe {
            instance.get(ThingType_GetOwns_Req::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_GetOwns_Req {
    fn clear(&mut self) {
        self.filter = ::std::option::Option::None;
        self.keys_only = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_GetOwns_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_GetOwns_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_GetOwns_ResPart {
    // message fields
    pub attribute_types: ::protobuf::RepeatedField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_GetOwns_ResPart {
    fn default() -> &'a ThingType_GetOwns_ResPart {
        <ThingType_GetOwns_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl ThingType_GetOwns_ResPart {
    pub fn new() -> ThingType_GetOwns_ResPart {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.Type attribute_types = 1;


    pub fn get_attribute_types(&self) -> &[Type] {
        &self.attribute_types
    }
    pub fn clear_attribute_types(&mut self) {
        self.attribute_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_attribute_types(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.attribute_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attribute_types(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.attribute_types
    }

    // Take field
    pub fn take_attribute_types(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.attribute_types, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ThingType_GetOwns_ResPart {
    fn is_initialized(&self) -> bool {
        for v in &self.attribute_types {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attribute_types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.attribute_types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.attribute_types {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_GetOwns_ResPart {
        ThingType_GetOwns_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "attribute_types",
                    |m: &ThingType_GetOwns_ResPart| { &m.attribute_types },
                    |m: &mut ThingType_GetOwns_ResPart| { &mut m.attribute_types },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_GetOwns_ResPart>(
                    "ThingType_GetOwns_ResPart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_GetOwns_ResPart {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_GetOwns_ResPart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_GetOwns_ResPart,
        };
        unsafe {
            instance.get(ThingType_GetOwns_ResPart::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_GetOwns_ResPart {
    fn clear(&mut self) {
        self.attribute_types.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_GetOwns_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_GetOwns_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_GetPlays {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_GetPlays {
    fn default() -> &'a ThingType_GetPlays {
        <ThingType_GetPlays as ::protobuf::Message>::default_instance()
    }
}

impl ThingType_GetPlays {
    pub fn new() -> ThingType_GetPlays {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ThingType_GetPlays {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_GetPlays {
        ThingType_GetPlays::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_GetPlays>(
                    "ThingType_GetPlays",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_GetPlays {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_GetPlays> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_GetPlays,
        };
        unsafe {
            instance.get(ThingType_GetPlays::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_GetPlays {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_GetPlays {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_GetPlays {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_GetPlays_Req {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_GetPlays_Req {
    fn default() -> &'a ThingType_GetPlays_Req {
        <ThingType_GetPlays_Req as ::protobuf::Message>::default_instance()
    }
}

impl ThingType_GetPlays_Req {
    pub fn new() -> ThingType_GetPlays_Req {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ThingType_GetPlays_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_GetPlays_Req {
        ThingType_GetPlays_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_GetPlays_Req>(
                    "ThingType_GetPlays_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_GetPlays_Req {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_GetPlays_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_GetPlays_Req,
        };
        unsafe {
            instance.get(ThingType_GetPlays_Req::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_GetPlays_Req {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_GetPlays_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_GetPlays_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_GetPlays_ResPart {
    // message fields
    pub roles: ::protobuf::RepeatedField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_GetPlays_ResPart {
    fn default() -> &'a ThingType_GetPlays_ResPart {
        <ThingType_GetPlays_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl ThingType_GetPlays_ResPart {
    pub fn new() -> ThingType_GetPlays_ResPart {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.Type roles = 1;


    pub fn get_roles(&self) -> &[Type] {
        &self.roles
    }
    pub fn clear_roles(&mut self) {
        self.roles.clear();
    }

    // Param is passed by value, moved
    pub fn set_roles(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.roles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_roles(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.roles
    }

    // Take field
    pub fn take_roles(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.roles, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ThingType_GetPlays_ResPart {
    fn is_initialized(&self) -> bool {
        for v in &self.roles {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.roles)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.roles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.roles {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_GetPlays_ResPart {
        ThingType_GetPlays_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "roles",
                    |m: &ThingType_GetPlays_ResPart| { &m.roles },
                    |m: &mut ThingType_GetPlays_ResPart| { &mut m.roles },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_GetPlays_ResPart>(
                    "ThingType_GetPlays_ResPart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_GetPlays_ResPart {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_GetPlays_ResPart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_GetPlays_ResPart,
        };
        unsafe {
            instance.get(ThingType_GetPlays_ResPart::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_GetPlays_ResPart {
    fn clear(&mut self) {
        self.roles.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_GetPlays_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_GetPlays_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_SetOwns {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_SetOwns {
    fn default() -> &'a ThingType_SetOwns {
        <ThingType_SetOwns as ::protobuf::Message>::default_instance()
    }
}

impl ThingType_SetOwns {
    pub fn new() -> ThingType_SetOwns {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ThingType_SetOwns {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_SetOwns {
        ThingType_SetOwns::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_SetOwns>(
                    "ThingType_SetOwns",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_SetOwns {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_SetOwns> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_SetOwns,
        };
        unsafe {
            instance.get(ThingType_SetOwns::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_SetOwns {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_SetOwns {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_SetOwns {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_SetOwns_Req {
    // message fields
    pub attribute_type: ::protobuf::SingularPtrField<Type>,
    pub is_key: bool,
    // message oneof groups
    pub overridden: ::std::option::Option<ThingType_SetOwns_Req_oneof_overridden>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_SetOwns_Req {
    fn default() -> &'a ThingType_SetOwns_Req {
        <ThingType_SetOwns_Req as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ThingType_SetOwns_Req_oneof_overridden {
    overridden_type(Type),
}

impl ThingType_SetOwns_Req {
    pub fn new() -> ThingType_SetOwns_Req {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Type attribute_type = 1;


    pub fn get_attribute_type(&self) -> &Type {
        self.attribute_type.as_ref().unwrap_or_else(|| Type::default_instance())
    }
    pub fn clear_attribute_type(&mut self) {
        self.attribute_type.clear();
    }

    pub fn has_attribute_type(&self) -> bool {
        self.attribute_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attribute_type(&mut self, v: Type) {
        self.attribute_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attribute_type(&mut self) -> &mut Type {
        if self.attribute_type.is_none() {
            self.attribute_type.set_default();
        }
        self.attribute_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_attribute_type(&mut self) -> Type {
        self.attribute_type.take().unwrap_or_else(|| Type::new())
    }

    // .typedb.protocol.Type overridden_type = 2;


    pub fn get_overridden_type(&self) -> &Type {
        match self.overridden {
            ::std::option::Option::Some(ThingType_SetOwns_Req_oneof_overridden::overridden_type(ref v)) => v,
            _ => Type::default_instance(),
        }
    }
    pub fn clear_overridden_type(&mut self) {
        self.overridden = ::std::option::Option::None;
    }

    pub fn has_overridden_type(&self) -> bool {
        match self.overridden {
            ::std::option::Option::Some(ThingType_SetOwns_Req_oneof_overridden::overridden_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_overridden_type(&mut self, v: Type) {
        self.overridden = ::std::option::Option::Some(ThingType_SetOwns_Req_oneof_overridden::overridden_type(v))
    }

    // Mutable pointer to the field.
    pub fn mut_overridden_type(&mut self) -> &mut Type {
        if let ::std::option::Option::Some(ThingType_SetOwns_Req_oneof_overridden::overridden_type(_)) = self.overridden {
        } else {
            self.overridden = ::std::option::Option::Some(ThingType_SetOwns_Req_oneof_overridden::overridden_type(Type::new()));
        }
        match self.overridden {
            ::std::option::Option::Some(ThingType_SetOwns_Req_oneof_overridden::overridden_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_overridden_type(&mut self) -> Type {
        if self.has_overridden_type() {
            match self.overridden.take() {
                ::std::option::Option::Some(ThingType_SetOwns_Req_oneof_overridden::overridden_type(v)) => v,
                _ => panic!(),
            }
        } else {
            Type::new()
        }
    }

    // bool is_key = 3;


    pub fn get_is_key(&self) -> bool {
        self.is_key
    }
    pub fn clear_is_key(&mut self) {
        self.is_key = false;
    }

    // Param is passed by value, moved
    pub fn set_is_key(&mut self, v: bool) {
        self.is_key = v;
    }
}

impl ::protobuf::Message for ThingType_SetOwns_Req {
    fn is_initialized(&self) -> bool {
        for v in &self.attribute_type {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(ThingType_SetOwns_Req_oneof_overridden::overridden_type(ref v)) = self.overridden {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attribute_type)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.overridden = ::std::option::Option::Some(ThingType_SetOwns_Req_oneof_overridden::overridden_type(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_key = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.attribute_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.is_key != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.overridden {
            match v {
                &ThingType_SetOwns_Req_oneof_overridden::overridden_type(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.attribute_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.is_key != false {
            os.write_bool(3, self.is_key)?;
        }
        if let ::std::option::Option::Some(ref v) = self.overridden {
            match v {
                &ThingType_SetOwns_Req_oneof_overridden::overridden_type(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_SetOwns_Req {
        ThingType_SetOwns_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "attribute_type",
                    |m: &ThingType_SetOwns_Req| { &m.attribute_type },
                    |m: &mut ThingType_SetOwns_Req| { &mut m.attribute_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type>(
                    "overridden_type",
                    ThingType_SetOwns_Req::has_overridden_type,
                    ThingType_SetOwns_Req::get_overridden_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_key",
                    |m: &ThingType_SetOwns_Req| { &m.is_key },
                    |m: &mut ThingType_SetOwns_Req| { &mut m.is_key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_SetOwns_Req>(
                    "ThingType_SetOwns_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_SetOwns_Req {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_SetOwns_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_SetOwns_Req,
        };
        unsafe {
            instance.get(ThingType_SetOwns_Req::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_SetOwns_Req {
    fn clear(&mut self) {
        self.attribute_type.clear();
        self.overridden = ::std::option::Option::None;
        self.is_key = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_SetOwns_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_SetOwns_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_SetOwns_Res {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_SetOwns_Res {
    fn default() -> &'a ThingType_SetOwns_Res {
        <ThingType_SetOwns_Res as ::protobuf::Message>::default_instance()
    }
}

impl ThingType_SetOwns_Res {
    pub fn new() -> ThingType_SetOwns_Res {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ThingType_SetOwns_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_SetOwns_Res {
        ThingType_SetOwns_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_SetOwns_Res>(
                    "ThingType_SetOwns_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_SetOwns_Res {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_SetOwns_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_SetOwns_Res,
        };
        unsafe {
            instance.get(ThingType_SetOwns_Res::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_SetOwns_Res {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_SetOwns_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_SetOwns_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_SetPlays {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_SetPlays {
    fn default() -> &'a ThingType_SetPlays {
        <ThingType_SetPlays as ::protobuf::Message>::default_instance()
    }
}

impl ThingType_SetPlays {
    pub fn new() -> ThingType_SetPlays {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ThingType_SetPlays {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_SetPlays {
        ThingType_SetPlays::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_SetPlays>(
                    "ThingType_SetPlays",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_SetPlays {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_SetPlays> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_SetPlays,
        };
        unsafe {
            instance.get(ThingType_SetPlays::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_SetPlays {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_SetPlays {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_SetPlays {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_SetPlays_Req {
    // message fields
    pub role: ::protobuf::SingularPtrField<Type>,
    // message oneof groups
    pub overridden: ::std::option::Option<ThingType_SetPlays_Req_oneof_overridden>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_SetPlays_Req {
    fn default() -> &'a ThingType_SetPlays_Req {
        <ThingType_SetPlays_Req as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ThingType_SetPlays_Req_oneof_overridden {
    overridden_role(Type),
}

impl ThingType_SetPlays_Req {
    pub fn new() -> ThingType_SetPlays_Req {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Type role = 1;


    pub fn get_role(&self) -> &Type {
        self.role.as_ref().unwrap_or_else(|| Type::default_instance())
    }
    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: Type) {
        self.role = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut Type {
        if self.role.is_none() {
            self.role.set_default();
        }
        self.role.as_mut().unwrap()
    }

    // Take field
    pub fn take_role(&mut self) -> Type {
        self.role.take().unwrap_or_else(|| Type::new())
    }

    // .typedb.protocol.Type overridden_role = 2;


    pub fn get_overridden_role(&self) -> &Type {
        match self.overridden {
            ::std::option::Option::Some(ThingType_SetPlays_Req_oneof_overridden::overridden_role(ref v)) => v,
            _ => Type::default_instance(),
        }
    }
    pub fn clear_overridden_role(&mut self) {
        self.overridden = ::std::option::Option::None;
    }

    pub fn has_overridden_role(&self) -> bool {
        match self.overridden {
            ::std::option::Option::Some(ThingType_SetPlays_Req_oneof_overridden::overridden_role(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_overridden_role(&mut self, v: Type) {
        self.overridden = ::std::option::Option::Some(ThingType_SetPlays_Req_oneof_overridden::overridden_role(v))
    }

    // Mutable pointer to the field.
    pub fn mut_overridden_role(&mut self) -> &mut Type {
        if let ::std::option::Option::Some(ThingType_SetPlays_Req_oneof_overridden::overridden_role(_)) = self.overridden {
        } else {
            self.overridden = ::std::option::Option::Some(ThingType_SetPlays_Req_oneof_overridden::overridden_role(Type::new()));
        }
        match self.overridden {
            ::std::option::Option::Some(ThingType_SetPlays_Req_oneof_overridden::overridden_role(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_overridden_role(&mut self) -> Type {
        if self.has_overridden_role() {
            match self.overridden.take() {
                ::std::option::Option::Some(ThingType_SetPlays_Req_oneof_overridden::overridden_role(v)) => v,
                _ => panic!(),
            }
        } else {
            Type::new()
        }
    }
}

impl ::protobuf::Message for ThingType_SetPlays_Req {
    fn is_initialized(&self) -> bool {
        for v in &self.role {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(ThingType_SetPlays_Req_oneof_overridden::overridden_role(ref v)) = self.overridden {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.role)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.overridden = ::std::option::Option::Some(ThingType_SetPlays_Req_oneof_overridden::overridden_role(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.role.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.overridden {
            match v {
                &ThingType_SetPlays_Req_oneof_overridden::overridden_role(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.role.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.overridden {
            match v {
                &ThingType_SetPlays_Req_oneof_overridden::overridden_role(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_SetPlays_Req {
        ThingType_SetPlays_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "role",
                    |m: &ThingType_SetPlays_Req| { &m.role },
                    |m: &mut ThingType_SetPlays_Req| { &mut m.role },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type>(
                    "overridden_role",
                    ThingType_SetPlays_Req::has_overridden_role,
                    ThingType_SetPlays_Req::get_overridden_role,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_SetPlays_Req>(
                    "ThingType_SetPlays_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_SetPlays_Req {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_SetPlays_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_SetPlays_Req,
        };
        unsafe {
            instance.get(ThingType_SetPlays_Req::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_SetPlays_Req {
    fn clear(&mut self) {
        self.role.clear();
        self.overridden = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_SetPlays_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_SetPlays_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_SetPlays_Res {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_SetPlays_Res {
    fn default() -> &'a ThingType_SetPlays_Res {
        <ThingType_SetPlays_Res as ::protobuf::Message>::default_instance()
    }
}

impl ThingType_SetPlays_Res {
    pub fn new() -> ThingType_SetPlays_Res {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ThingType_SetPlays_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_SetPlays_Res {
        ThingType_SetPlays_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_SetPlays_Res>(
                    "ThingType_SetPlays_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_SetPlays_Res {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_SetPlays_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_SetPlays_Res,
        };
        unsafe {
            instance.get(ThingType_SetPlays_Res::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_SetPlays_Res {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_SetPlays_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_SetPlays_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_UnsetOwns {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_UnsetOwns {
    fn default() -> &'a ThingType_UnsetOwns {
        <ThingType_UnsetOwns as ::protobuf::Message>::default_instance()
    }
}

impl ThingType_UnsetOwns {
    pub fn new() -> ThingType_UnsetOwns {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ThingType_UnsetOwns {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_UnsetOwns {
        ThingType_UnsetOwns::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_UnsetOwns>(
                    "ThingType_UnsetOwns",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_UnsetOwns {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_UnsetOwns> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_UnsetOwns,
        };
        unsafe {
            instance.get(ThingType_UnsetOwns::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_UnsetOwns {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_UnsetOwns {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_UnsetOwns {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_UnsetOwns_Req {
    // message fields
    pub attribute_type: ::protobuf::SingularPtrField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_UnsetOwns_Req {
    fn default() -> &'a ThingType_UnsetOwns_Req {
        <ThingType_UnsetOwns_Req as ::protobuf::Message>::default_instance()
    }
}

impl ThingType_UnsetOwns_Req {
    pub fn new() -> ThingType_UnsetOwns_Req {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Type attribute_type = 1;


    pub fn get_attribute_type(&self) -> &Type {
        self.attribute_type.as_ref().unwrap_or_else(|| Type::default_instance())
    }
    pub fn clear_attribute_type(&mut self) {
        self.attribute_type.clear();
    }

    pub fn has_attribute_type(&self) -> bool {
        self.attribute_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attribute_type(&mut self, v: Type) {
        self.attribute_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attribute_type(&mut self) -> &mut Type {
        if self.attribute_type.is_none() {
            self.attribute_type.set_default();
        }
        self.attribute_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_attribute_type(&mut self) -> Type {
        self.attribute_type.take().unwrap_or_else(|| Type::new())
    }
}

impl ::protobuf::Message for ThingType_UnsetOwns_Req {
    fn is_initialized(&self) -> bool {
        for v in &self.attribute_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attribute_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.attribute_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.attribute_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_UnsetOwns_Req {
        ThingType_UnsetOwns_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "attribute_type",
                    |m: &ThingType_UnsetOwns_Req| { &m.attribute_type },
                    |m: &mut ThingType_UnsetOwns_Req| { &mut m.attribute_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_UnsetOwns_Req>(
                    "ThingType_UnsetOwns_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_UnsetOwns_Req {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_UnsetOwns_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_UnsetOwns_Req,
        };
        unsafe {
            instance.get(ThingType_UnsetOwns_Req::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_UnsetOwns_Req {
    fn clear(&mut self) {
        self.attribute_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_UnsetOwns_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_UnsetOwns_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_UnsetOwns_Res {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_UnsetOwns_Res {
    fn default() -> &'a ThingType_UnsetOwns_Res {
        <ThingType_UnsetOwns_Res as ::protobuf::Message>::default_instance()
    }
}

impl ThingType_UnsetOwns_Res {
    pub fn new() -> ThingType_UnsetOwns_Res {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ThingType_UnsetOwns_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_UnsetOwns_Res {
        ThingType_UnsetOwns_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_UnsetOwns_Res>(
                    "ThingType_UnsetOwns_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_UnsetOwns_Res {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_UnsetOwns_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_UnsetOwns_Res,
        };
        unsafe {
            instance.get(ThingType_UnsetOwns_Res::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_UnsetOwns_Res {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_UnsetOwns_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_UnsetOwns_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_UnsetPlays {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_UnsetPlays {
    fn default() -> &'a ThingType_UnsetPlays {
        <ThingType_UnsetPlays as ::protobuf::Message>::default_instance()
    }
}

impl ThingType_UnsetPlays {
    pub fn new() -> ThingType_UnsetPlays {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ThingType_UnsetPlays {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_UnsetPlays {
        ThingType_UnsetPlays::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_UnsetPlays>(
                    "ThingType_UnsetPlays",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_UnsetPlays {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_UnsetPlays> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_UnsetPlays,
        };
        unsafe {
            instance.get(ThingType_UnsetPlays::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_UnsetPlays {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_UnsetPlays {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_UnsetPlays {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_UnsetPlays_Req {
    // message fields
    pub role: ::protobuf::SingularPtrField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_UnsetPlays_Req {
    fn default() -> &'a ThingType_UnsetPlays_Req {
        <ThingType_UnsetPlays_Req as ::protobuf::Message>::default_instance()
    }
}

impl ThingType_UnsetPlays_Req {
    pub fn new() -> ThingType_UnsetPlays_Req {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Type role = 1;


    pub fn get_role(&self) -> &Type {
        self.role.as_ref().unwrap_or_else(|| Type::default_instance())
    }
    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: Type) {
        self.role = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut Type {
        if self.role.is_none() {
            self.role.set_default();
        }
        self.role.as_mut().unwrap()
    }

    // Take field
    pub fn take_role(&mut self) -> Type {
        self.role.take().unwrap_or_else(|| Type::new())
    }
}

impl ::protobuf::Message for ThingType_UnsetPlays_Req {
    fn is_initialized(&self) -> bool {
        for v in &self.role {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.role)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.role.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.role.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_UnsetPlays_Req {
        ThingType_UnsetPlays_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "role",
                    |m: &ThingType_UnsetPlays_Req| { &m.role },
                    |m: &mut ThingType_UnsetPlays_Req| { &mut m.role },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_UnsetPlays_Req>(
                    "ThingType_UnsetPlays_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_UnsetPlays_Req {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_UnsetPlays_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_UnsetPlays_Req,
        };
        unsafe {
            instance.get(ThingType_UnsetPlays_Req::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_UnsetPlays_Req {
    fn clear(&mut self) {
        self.role.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_UnsetPlays_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_UnsetPlays_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingType_UnsetPlays_Res {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingType_UnsetPlays_Res {
    fn default() -> &'a ThingType_UnsetPlays_Res {
        <ThingType_UnsetPlays_Res as ::protobuf::Message>::default_instance()
    }
}

impl ThingType_UnsetPlays_Res {
    pub fn new() -> ThingType_UnsetPlays_Res {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ThingType_UnsetPlays_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingType_UnsetPlays_Res {
        ThingType_UnsetPlays_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ThingType_UnsetPlays_Res>(
                    "ThingType_UnsetPlays_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingType_UnsetPlays_Res {
        static mut instance: ::protobuf::lazy::Lazy<ThingType_UnsetPlays_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingType_UnsetPlays_Res,
        };
        unsafe {
            instance.get(ThingType_UnsetPlays_Res::new)
        }
    }
}

impl ::protobuf::Clear for ThingType_UnsetPlays_Res {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingType_UnsetPlays_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingType_UnsetPlays_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EntityType {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EntityType {
    fn default() -> &'a EntityType {
        <EntityType as ::protobuf::Message>::default_instance()
    }
}

impl EntityType {
    pub fn new() -> EntityType {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EntityType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EntityType {
        EntityType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<EntityType>(
                    "EntityType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EntityType {
        static mut instance: ::protobuf::lazy::Lazy<EntityType> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EntityType,
        };
        unsafe {
            instance.get(EntityType::new)
        }
    }
}

impl ::protobuf::Clear for EntityType {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EntityType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntityType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EntityType_Create {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EntityType_Create {
    fn default() -> &'a EntityType_Create {
        <EntityType_Create as ::protobuf::Message>::default_instance()
    }
}

impl EntityType_Create {
    pub fn new() -> EntityType_Create {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EntityType_Create {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EntityType_Create {
        EntityType_Create::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<EntityType_Create>(
                    "EntityType_Create",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EntityType_Create {
        static mut instance: ::protobuf::lazy::Lazy<EntityType_Create> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EntityType_Create,
        };
        unsafe {
            instance.get(EntityType_Create::new)
        }
    }
}

impl ::protobuf::Clear for EntityType_Create {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EntityType_Create {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntityType_Create {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EntityType_Create_Req {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EntityType_Create_Req {
    fn default() -> &'a EntityType_Create_Req {
        <EntityType_Create_Req as ::protobuf::Message>::default_instance()
    }
}

impl EntityType_Create_Req {
    pub fn new() -> EntityType_Create_Req {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EntityType_Create_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EntityType_Create_Req {
        EntityType_Create_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<EntityType_Create_Req>(
                    "EntityType_Create_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EntityType_Create_Req {
        static mut instance: ::protobuf::lazy::Lazy<EntityType_Create_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EntityType_Create_Req,
        };
        unsafe {
            instance.get(EntityType_Create_Req::new)
        }
    }
}

impl ::protobuf::Clear for EntityType_Create_Req {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EntityType_Create_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntityType_Create_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EntityType_Create_Res {
    // message fields
    pub entity: ::protobuf::SingularPtrField<Thing>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EntityType_Create_Res {
    fn default() -> &'a EntityType_Create_Res {
        <EntityType_Create_Res as ::protobuf::Message>::default_instance()
    }
}

impl EntityType_Create_Res {
    pub fn new() -> EntityType_Create_Res {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Thing entity = 1;


    pub fn get_entity(&self) -> &Thing {
        self.entity.as_ref().unwrap_or_else(|| Thing::default_instance())
    }
    pub fn clear_entity(&mut self) {
        self.entity.clear();
    }

    pub fn has_entity(&self) -> bool {
        self.entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: Thing) {
        self.entity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity(&mut self) -> &mut Thing {
        if self.entity.is_none() {
            self.entity.set_default();
        }
        self.entity.as_mut().unwrap()
    }

    // Take field
    pub fn take_entity(&mut self) -> Thing {
        self.entity.take().unwrap_or_else(|| Thing::new())
    }
}

impl ::protobuf::Message for EntityType_Create_Res {
    fn is_initialized(&self) -> bool {
        for v in &self.entity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.entity)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.entity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.entity.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EntityType_Create_Res {
        EntityType_Create_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Thing>>(
                    "entity",
                    |m: &EntityType_Create_Res| { &m.entity },
                    |m: &mut EntityType_Create_Res| { &mut m.entity },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EntityType_Create_Res>(
                    "EntityType_Create_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EntityType_Create_Res {
        static mut instance: ::protobuf::lazy::Lazy<EntityType_Create_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EntityType_Create_Res,
        };
        unsafe {
            instance.get(EntityType_Create_Res::new)
        }
    }
}

impl ::protobuf::Clear for EntityType_Create_Res {
    fn clear(&mut self) {
        self.entity.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EntityType_Create_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntityType_Create_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelationType {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelationType {
    fn default() -> &'a RelationType {
        <RelationType as ::protobuf::Message>::default_instance()
    }
}

impl RelationType {
    pub fn new() -> RelationType {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RelationType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelationType {
        RelationType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RelationType>(
                    "RelationType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RelationType {
        static mut instance: ::protobuf::lazy::Lazy<RelationType> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RelationType,
        };
        unsafe {
            instance.get(RelationType::new)
        }
    }
}

impl ::protobuf::Clear for RelationType {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelationType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelationType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelationType_Create {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelationType_Create {
    fn default() -> &'a RelationType_Create {
        <RelationType_Create as ::protobuf::Message>::default_instance()
    }
}

impl RelationType_Create {
    pub fn new() -> RelationType_Create {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RelationType_Create {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelationType_Create {
        RelationType_Create::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RelationType_Create>(
                    "RelationType_Create",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RelationType_Create {
        static mut instance: ::protobuf::lazy::Lazy<RelationType_Create> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RelationType_Create,
        };
        unsafe {
            instance.get(RelationType_Create::new)
        }
    }
}

impl ::protobuf::Clear for RelationType_Create {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelationType_Create {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelationType_Create {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelationType_Create_Req {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelationType_Create_Req {
    fn default() -> &'a RelationType_Create_Req {
        <RelationType_Create_Req as ::protobuf::Message>::default_instance()
    }
}

impl RelationType_Create_Req {
    pub fn new() -> RelationType_Create_Req {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RelationType_Create_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelationType_Create_Req {
        RelationType_Create_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RelationType_Create_Req>(
                    "RelationType_Create_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RelationType_Create_Req {
        static mut instance: ::protobuf::lazy::Lazy<RelationType_Create_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RelationType_Create_Req,
        };
        unsafe {
            instance.get(RelationType_Create_Req::new)
        }
    }
}

impl ::protobuf::Clear for RelationType_Create_Req {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelationType_Create_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelationType_Create_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelationType_Create_Res {
    // message fields
    pub relation: ::protobuf::SingularPtrField<Thing>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelationType_Create_Res {
    fn default() -> &'a RelationType_Create_Res {
        <RelationType_Create_Res as ::protobuf::Message>::default_instance()
    }
}

impl RelationType_Create_Res {
    pub fn new() -> RelationType_Create_Res {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Thing relation = 1;


    pub fn get_relation(&self) -> &Thing {
        self.relation.as_ref().unwrap_or_else(|| Thing::default_instance())
    }
    pub fn clear_relation(&mut self) {
        self.relation.clear();
    }

    pub fn has_relation(&self) -> bool {
        self.relation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relation(&mut self, v: Thing) {
        self.relation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relation(&mut self) -> &mut Thing {
        if self.relation.is_none() {
            self.relation.set_default();
        }
        self.relation.as_mut().unwrap()
    }

    // Take field
    pub fn take_relation(&mut self) -> Thing {
        self.relation.take().unwrap_or_else(|| Thing::new())
    }
}

impl ::protobuf::Message for RelationType_Create_Res {
    fn is_initialized(&self) -> bool {
        for v in &self.relation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.relation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.relation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.relation.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelationType_Create_Res {
        RelationType_Create_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Thing>>(
                    "relation",
                    |m: &RelationType_Create_Res| { &m.relation },
                    |m: &mut RelationType_Create_Res| { &mut m.relation },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RelationType_Create_Res>(
                    "RelationType_Create_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RelationType_Create_Res {
        static mut instance: ::protobuf::lazy::Lazy<RelationType_Create_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RelationType_Create_Res,
        };
        unsafe {
            instance.get(RelationType_Create_Res::new)
        }
    }
}

impl ::protobuf::Clear for RelationType_Create_Res {
    fn clear(&mut self) {
        self.relation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelationType_Create_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelationType_Create_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelationType_GetRelates {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelationType_GetRelates {
    fn default() -> &'a RelationType_GetRelates {
        <RelationType_GetRelates as ::protobuf::Message>::default_instance()
    }
}

impl RelationType_GetRelates {
    pub fn new() -> RelationType_GetRelates {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RelationType_GetRelates {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelationType_GetRelates {
        RelationType_GetRelates::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RelationType_GetRelates>(
                    "RelationType_GetRelates",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RelationType_GetRelates {
        static mut instance: ::protobuf::lazy::Lazy<RelationType_GetRelates> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RelationType_GetRelates,
        };
        unsafe {
            instance.get(RelationType_GetRelates::new)
        }
    }
}

impl ::protobuf::Clear for RelationType_GetRelates {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelationType_GetRelates {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelationType_GetRelates {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelationType_GetRelates_Req {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelationType_GetRelates_Req {
    fn default() -> &'a RelationType_GetRelates_Req {
        <RelationType_GetRelates_Req as ::protobuf::Message>::default_instance()
    }
}

impl RelationType_GetRelates_Req {
    pub fn new() -> RelationType_GetRelates_Req {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RelationType_GetRelates_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelationType_GetRelates_Req {
        RelationType_GetRelates_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RelationType_GetRelates_Req>(
                    "RelationType_GetRelates_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RelationType_GetRelates_Req {
        static mut instance: ::protobuf::lazy::Lazy<RelationType_GetRelates_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RelationType_GetRelates_Req,
        };
        unsafe {
            instance.get(RelationType_GetRelates_Req::new)
        }
    }
}

impl ::protobuf::Clear for RelationType_GetRelates_Req {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelationType_GetRelates_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelationType_GetRelates_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelationType_GetRelates_ResPart {
    // message fields
    pub roles: ::protobuf::RepeatedField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelationType_GetRelates_ResPart {
    fn default() -> &'a RelationType_GetRelates_ResPart {
        <RelationType_GetRelates_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl RelationType_GetRelates_ResPart {
    pub fn new() -> RelationType_GetRelates_ResPart {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.Type roles = 1;


    pub fn get_roles(&self) -> &[Type] {
        &self.roles
    }
    pub fn clear_roles(&mut self) {
        self.roles.clear();
    }

    // Param is passed by value, moved
    pub fn set_roles(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.roles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_roles(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.roles
    }

    // Take field
    pub fn take_roles(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.roles, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RelationType_GetRelates_ResPart {
    fn is_initialized(&self) -> bool {
        for v in &self.roles {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.roles)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.roles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.roles {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelationType_GetRelates_ResPart {
        RelationType_GetRelates_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "roles",
                    |m: &RelationType_GetRelates_ResPart| { &m.roles },
                    |m: &mut RelationType_GetRelates_ResPart| { &mut m.roles },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RelationType_GetRelates_ResPart>(
                    "RelationType_GetRelates_ResPart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RelationType_GetRelates_ResPart {
        static mut instance: ::protobuf::lazy::Lazy<RelationType_GetRelates_ResPart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RelationType_GetRelates_ResPart,
        };
        unsafe {
            instance.get(RelationType_GetRelates_ResPart::new)
        }
    }
}

impl ::protobuf::Clear for RelationType_GetRelates_ResPart {
    fn clear(&mut self) {
        self.roles.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelationType_GetRelates_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelationType_GetRelates_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelationType_GetRelatesForRoleLabel {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelationType_GetRelatesForRoleLabel {
    fn default() -> &'a RelationType_GetRelatesForRoleLabel {
        <RelationType_GetRelatesForRoleLabel as ::protobuf::Message>::default_instance()
    }
}

impl RelationType_GetRelatesForRoleLabel {
    pub fn new() -> RelationType_GetRelatesForRoleLabel {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RelationType_GetRelatesForRoleLabel {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelationType_GetRelatesForRoleLabel {
        RelationType_GetRelatesForRoleLabel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RelationType_GetRelatesForRoleLabel>(
                    "RelationType_GetRelatesForRoleLabel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RelationType_GetRelatesForRoleLabel {
        static mut instance: ::protobuf::lazy::Lazy<RelationType_GetRelatesForRoleLabel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RelationType_GetRelatesForRoleLabel,
        };
        unsafe {
            instance.get(RelationType_GetRelatesForRoleLabel::new)
        }
    }
}

impl ::protobuf::Clear for RelationType_GetRelatesForRoleLabel {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelationType_GetRelatesForRoleLabel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelationType_GetRelatesForRoleLabel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelationType_GetRelatesForRoleLabel_Req {
    // message fields
    pub label: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelationType_GetRelatesForRoleLabel_Req {
    fn default() -> &'a RelationType_GetRelatesForRoleLabel_Req {
        <RelationType_GetRelatesForRoleLabel_Req as ::protobuf::Message>::default_instance()
    }
}

impl RelationType_GetRelatesForRoleLabel_Req {
    pub fn new() -> RelationType_GetRelatesForRoleLabel_Req {
        ::std::default::Default::default()
    }

    // string label = 1;


    pub fn get_label(&self) -> &str {
        &self.label
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        &mut self.label
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RelationType_GetRelatesForRoleLabel_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.label);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.label.is_empty() {
            os.write_string(1, &self.label)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelationType_GetRelatesForRoleLabel_Req {
        RelationType_GetRelatesForRoleLabel_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "label",
                    |m: &RelationType_GetRelatesForRoleLabel_Req| { &m.label },
                    |m: &mut RelationType_GetRelatesForRoleLabel_Req| { &mut m.label },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RelationType_GetRelatesForRoleLabel_Req>(
                    "RelationType_GetRelatesForRoleLabel_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RelationType_GetRelatesForRoleLabel_Req {
        static mut instance: ::protobuf::lazy::Lazy<RelationType_GetRelatesForRoleLabel_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RelationType_GetRelatesForRoleLabel_Req,
        };
        unsafe {
            instance.get(RelationType_GetRelatesForRoleLabel_Req::new)
        }
    }
}

impl ::protobuf::Clear for RelationType_GetRelatesForRoleLabel_Req {
    fn clear(&mut self) {
        self.label.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelationType_GetRelatesForRoleLabel_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelationType_GetRelatesForRoleLabel_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelationType_GetRelatesForRoleLabel_Res {
    // message oneof groups
    pub role: ::std::option::Option<RelationType_GetRelatesForRoleLabel_Res_oneof_role>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelationType_GetRelatesForRoleLabel_Res {
    fn default() -> &'a RelationType_GetRelatesForRoleLabel_Res {
        <RelationType_GetRelatesForRoleLabel_Res as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RelationType_GetRelatesForRoleLabel_Res_oneof_role {
    role_type(Type),
}

impl RelationType_GetRelatesForRoleLabel_Res {
    pub fn new() -> RelationType_GetRelatesForRoleLabel_Res {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Type role_type = 1;


    pub fn get_role_type(&self) -> &Type {
        match self.role {
            ::std::option::Option::Some(RelationType_GetRelatesForRoleLabel_Res_oneof_role::role_type(ref v)) => v,
            _ => Type::default_instance(),
        }
    }
    pub fn clear_role_type(&mut self) {
        self.role = ::std::option::Option::None;
    }

    pub fn has_role_type(&self) -> bool {
        match self.role {
            ::std::option::Option::Some(RelationType_GetRelatesForRoleLabel_Res_oneof_role::role_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_role_type(&mut self, v: Type) {
        self.role = ::std::option::Option::Some(RelationType_GetRelatesForRoleLabel_Res_oneof_role::role_type(v))
    }

    // Mutable pointer to the field.
    pub fn mut_role_type(&mut self) -> &mut Type {
        if let ::std::option::Option::Some(RelationType_GetRelatesForRoleLabel_Res_oneof_role::role_type(_)) = self.role {
        } else {
            self.role = ::std::option::Option::Some(RelationType_GetRelatesForRoleLabel_Res_oneof_role::role_type(Type::new()));
        }
        match self.role {
            ::std::option::Option::Some(RelationType_GetRelatesForRoleLabel_Res_oneof_role::role_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_role_type(&mut self) -> Type {
        if self.has_role_type() {
            match self.role.take() {
                ::std::option::Option::Some(RelationType_GetRelatesForRoleLabel_Res_oneof_role::role_type(v)) => v,
                _ => panic!(),
            }
        } else {
            Type::new()
        }
    }
}

impl ::protobuf::Message for RelationType_GetRelatesForRoleLabel_Res {
    fn is_initialized(&self) -> bool {
        if let Some(RelationType_GetRelatesForRoleLabel_Res_oneof_role::role_type(ref v)) = self.role {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.role = ::std::option::Option::Some(RelationType_GetRelatesForRoleLabel_Res_oneof_role::role_type(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.role {
            match v {
                &RelationType_GetRelatesForRoleLabel_Res_oneof_role::role_type(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.role {
            match v {
                &RelationType_GetRelatesForRoleLabel_Res_oneof_role::role_type(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelationType_GetRelatesForRoleLabel_Res {
        RelationType_GetRelatesForRoleLabel_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type>(
                    "role_type",
                    RelationType_GetRelatesForRoleLabel_Res::has_role_type,
                    RelationType_GetRelatesForRoleLabel_Res::get_role_type,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RelationType_GetRelatesForRoleLabel_Res>(
                    "RelationType_GetRelatesForRoleLabel_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RelationType_GetRelatesForRoleLabel_Res {
        static mut instance: ::protobuf::lazy::Lazy<RelationType_GetRelatesForRoleLabel_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RelationType_GetRelatesForRoleLabel_Res,
        };
        unsafe {
            instance.get(RelationType_GetRelatesForRoleLabel_Res::new)
        }
    }
}

impl ::protobuf::Clear for RelationType_GetRelatesForRoleLabel_Res {
    fn clear(&mut self) {
        self.role = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelationType_GetRelatesForRoleLabel_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelationType_GetRelatesForRoleLabel_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelationType_SetRelates {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelationType_SetRelates {
    fn default() -> &'a RelationType_SetRelates {
        <RelationType_SetRelates as ::protobuf::Message>::default_instance()
    }
}

impl RelationType_SetRelates {
    pub fn new() -> RelationType_SetRelates {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RelationType_SetRelates {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelationType_SetRelates {
        RelationType_SetRelates::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RelationType_SetRelates>(
                    "RelationType_SetRelates",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RelationType_SetRelates {
        static mut instance: ::protobuf::lazy::Lazy<RelationType_SetRelates> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RelationType_SetRelates,
        };
        unsafe {
            instance.get(RelationType_SetRelates::new)
        }
    }
}

impl ::protobuf::Clear for RelationType_SetRelates {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelationType_SetRelates {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelationType_SetRelates {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelationType_SetRelates_Req {
    // message fields
    pub label: ::std::string::String,
    // message oneof groups
    pub overridden: ::std::option::Option<RelationType_SetRelates_Req_oneof_overridden>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelationType_SetRelates_Req {
    fn default() -> &'a RelationType_SetRelates_Req {
        <RelationType_SetRelates_Req as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RelationType_SetRelates_Req_oneof_overridden {
    overridden_label(::std::string::String),
}

impl RelationType_SetRelates_Req {
    pub fn new() -> RelationType_SetRelates_Req {
        ::std::default::Default::default()
    }

    // string label = 1;


    pub fn get_label(&self) -> &str {
        &self.label
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        &mut self.label
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label, ::std::string::String::new())
    }

    // string overridden_label = 2;


    pub fn get_overridden_label(&self) -> &str {
        match self.overridden {
            ::std::option::Option::Some(RelationType_SetRelates_Req_oneof_overridden::overridden_label(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_overridden_label(&mut self) {
        self.overridden = ::std::option::Option::None;
    }

    pub fn has_overridden_label(&self) -> bool {
        match self.overridden {
            ::std::option::Option::Some(RelationType_SetRelates_Req_oneof_overridden::overridden_label(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_overridden_label(&mut self, v: ::std::string::String) {
        self.overridden = ::std::option::Option::Some(RelationType_SetRelates_Req_oneof_overridden::overridden_label(v))
    }

    // Mutable pointer to the field.
    pub fn mut_overridden_label(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RelationType_SetRelates_Req_oneof_overridden::overridden_label(_)) = self.overridden {
        } else {
            self.overridden = ::std::option::Option::Some(RelationType_SetRelates_Req_oneof_overridden::overridden_label(::std::string::String::new()));
        }
        match self.overridden {
            ::std::option::Option::Some(RelationType_SetRelates_Req_oneof_overridden::overridden_label(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_overridden_label(&mut self) -> ::std::string::String {
        if self.has_overridden_label() {
            match self.overridden.take() {
                ::std::option::Option::Some(RelationType_SetRelates_Req_oneof_overridden::overridden_label(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for RelationType_SetRelates_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.overridden = ::std::option::Option::Some(RelationType_SetRelates_Req_oneof_overridden::overridden_label(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.label);
        }
        if let ::std::option::Option::Some(ref v) = self.overridden {
            match v {
                &RelationType_SetRelates_Req_oneof_overridden::overridden_label(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.label.is_empty() {
            os.write_string(1, &self.label)?;
        }
        if let ::std::option::Option::Some(ref v) = self.overridden {
            match v {
                &RelationType_SetRelates_Req_oneof_overridden::overridden_label(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelationType_SetRelates_Req {
        RelationType_SetRelates_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "label",
                    |m: &RelationType_SetRelates_Req| { &m.label },
                    |m: &mut RelationType_SetRelates_Req| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "overridden_label",
                    RelationType_SetRelates_Req::has_overridden_label,
                    RelationType_SetRelates_Req::get_overridden_label,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RelationType_SetRelates_Req>(
                    "RelationType_SetRelates_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RelationType_SetRelates_Req {
        static mut instance: ::protobuf::lazy::Lazy<RelationType_SetRelates_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RelationType_SetRelates_Req,
        };
        unsafe {
            instance.get(RelationType_SetRelates_Req::new)
        }
    }
}

impl ::protobuf::Clear for RelationType_SetRelates_Req {
    fn clear(&mut self) {
        self.label.clear();
        self.overridden = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelationType_SetRelates_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelationType_SetRelates_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelationType_SetRelates_Res {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelationType_SetRelates_Res {
    fn default() -> &'a RelationType_SetRelates_Res {
        <RelationType_SetRelates_Res as ::protobuf::Message>::default_instance()
    }
}

impl RelationType_SetRelates_Res {
    pub fn new() -> RelationType_SetRelates_Res {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RelationType_SetRelates_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelationType_SetRelates_Res {
        RelationType_SetRelates_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RelationType_SetRelates_Res>(
                    "RelationType_SetRelates_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RelationType_SetRelates_Res {
        static mut instance: ::protobuf::lazy::Lazy<RelationType_SetRelates_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RelationType_SetRelates_Res,
        };
        unsafe {
            instance.get(RelationType_SetRelates_Res::new)
        }
    }
}

impl ::protobuf::Clear for RelationType_SetRelates_Res {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelationType_SetRelates_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelationType_SetRelates_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelationType_UnsetRelates {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelationType_UnsetRelates {
    fn default() -> &'a RelationType_UnsetRelates {
        <RelationType_UnsetRelates as ::protobuf::Message>::default_instance()
    }
}

impl RelationType_UnsetRelates {
    pub fn new() -> RelationType_UnsetRelates {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RelationType_UnsetRelates {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelationType_UnsetRelates {
        RelationType_UnsetRelates::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RelationType_UnsetRelates>(
                    "RelationType_UnsetRelates",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RelationType_UnsetRelates {
        static mut instance: ::protobuf::lazy::Lazy<RelationType_UnsetRelates> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RelationType_UnsetRelates,
        };
        unsafe {
            instance.get(RelationType_UnsetRelates::new)
        }
    }
}

impl ::protobuf::Clear for RelationType_UnsetRelates {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelationType_UnsetRelates {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelationType_UnsetRelates {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelationType_UnsetRelates_Req {
    // message fields
    pub label: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelationType_UnsetRelates_Req {
    fn default() -> &'a RelationType_UnsetRelates_Req {
        <RelationType_UnsetRelates_Req as ::protobuf::Message>::default_instance()
    }
}

impl RelationType_UnsetRelates_Req {
    pub fn new() -> RelationType_UnsetRelates_Req {
        ::std::default::Default::default()
    }

    // string label = 1;


    pub fn get_label(&self) -> &str {
        &self.label
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        &mut self.label
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RelationType_UnsetRelates_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.label);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.label.is_empty() {
            os.write_string(1, &self.label)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelationType_UnsetRelates_Req {
        RelationType_UnsetRelates_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "label",
                    |m: &RelationType_UnsetRelates_Req| { &m.label },
                    |m: &mut RelationType_UnsetRelates_Req| { &mut m.label },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RelationType_UnsetRelates_Req>(
                    "RelationType_UnsetRelates_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RelationType_UnsetRelates_Req {
        static mut instance: ::protobuf::lazy::Lazy<RelationType_UnsetRelates_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RelationType_UnsetRelates_Req,
        };
        unsafe {
            instance.get(RelationType_UnsetRelates_Req::new)
        }
    }
}

impl ::protobuf::Clear for RelationType_UnsetRelates_Req {
    fn clear(&mut self) {
        self.label.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelationType_UnsetRelates_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelationType_UnsetRelates_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelationType_UnsetRelates_Res {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelationType_UnsetRelates_Res {
    fn default() -> &'a RelationType_UnsetRelates_Res {
        <RelationType_UnsetRelates_Res as ::protobuf::Message>::default_instance()
    }
}

impl RelationType_UnsetRelates_Res {
    pub fn new() -> RelationType_UnsetRelates_Res {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RelationType_UnsetRelates_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelationType_UnsetRelates_Res {
        RelationType_UnsetRelates_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RelationType_UnsetRelates_Res>(
                    "RelationType_UnsetRelates_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RelationType_UnsetRelates_Res {
        static mut instance: ::protobuf::lazy::Lazy<RelationType_UnsetRelates_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RelationType_UnsetRelates_Res,
        };
        unsafe {
            instance.get(RelationType_UnsetRelates_Res::new)
        }
    }
}

impl ::protobuf::Clear for RelationType_UnsetRelates_Res {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelationType_UnsetRelates_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelationType_UnsetRelates_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeType {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeType {
    fn default() -> &'a AttributeType {
        <AttributeType as ::protobuf::Message>::default_instance()
    }
}

impl AttributeType {
    pub fn new() -> AttributeType {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AttributeType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeType {
        AttributeType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AttributeType>(
                    "AttributeType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttributeType {
        static mut instance: ::protobuf::lazy::Lazy<AttributeType> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttributeType,
        };
        unsafe {
            instance.get(AttributeType::new)
        }
    }
}

impl ::protobuf::Clear for AttributeType {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeType_Put {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeType_Put {
    fn default() -> &'a AttributeType_Put {
        <AttributeType_Put as ::protobuf::Message>::default_instance()
    }
}

impl AttributeType_Put {
    pub fn new() -> AttributeType_Put {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AttributeType_Put {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeType_Put {
        AttributeType_Put::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AttributeType_Put>(
                    "AttributeType_Put",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttributeType_Put {
        static mut instance: ::protobuf::lazy::Lazy<AttributeType_Put> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttributeType_Put,
        };
        unsafe {
            instance.get(AttributeType_Put::new)
        }
    }
}

impl ::protobuf::Clear for AttributeType_Put {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeType_Put {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeType_Put {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeType_Put_Req {
    // message fields
    pub value: ::protobuf::SingularPtrField<Attribute_Value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeType_Put_Req {
    fn default() -> &'a AttributeType_Put_Req {
        <AttributeType_Put_Req as ::protobuf::Message>::default_instance()
    }
}

impl AttributeType_Put_Req {
    pub fn new() -> AttributeType_Put_Req {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Attribute.Value value = 1;


    pub fn get_value(&self) -> &Attribute_Value {
        self.value.as_ref().unwrap_or_else(|| Attribute_Value::default_instance())
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: Attribute_Value) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut Attribute_Value {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> Attribute_Value {
        self.value.take().unwrap_or_else(|| Attribute_Value::new())
    }
}

impl ::protobuf::Message for AttributeType_Put_Req {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeType_Put_Req {
        AttributeType_Put_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Attribute_Value>>(
                    "value",
                    |m: &AttributeType_Put_Req| { &m.value },
                    |m: &mut AttributeType_Put_Req| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AttributeType_Put_Req>(
                    "AttributeType_Put_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttributeType_Put_Req {
        static mut instance: ::protobuf::lazy::Lazy<AttributeType_Put_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttributeType_Put_Req,
        };
        unsafe {
            instance.get(AttributeType_Put_Req::new)
        }
    }
}

impl ::protobuf::Clear for AttributeType_Put_Req {
    fn clear(&mut self) {
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeType_Put_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeType_Put_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeType_Put_Res {
    // message fields
    pub attribute: ::protobuf::SingularPtrField<Thing>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeType_Put_Res {
    fn default() -> &'a AttributeType_Put_Res {
        <AttributeType_Put_Res as ::protobuf::Message>::default_instance()
    }
}

impl AttributeType_Put_Res {
    pub fn new() -> AttributeType_Put_Res {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Thing attribute = 1;


    pub fn get_attribute(&self) -> &Thing {
        self.attribute.as_ref().unwrap_or_else(|| Thing::default_instance())
    }
    pub fn clear_attribute(&mut self) {
        self.attribute.clear();
    }

    pub fn has_attribute(&self) -> bool {
        self.attribute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attribute(&mut self, v: Thing) {
        self.attribute = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attribute(&mut self) -> &mut Thing {
        if self.attribute.is_none() {
            self.attribute.set_default();
        }
        self.attribute.as_mut().unwrap()
    }

    // Take field
    pub fn take_attribute(&mut self) -> Thing {
        self.attribute.take().unwrap_or_else(|| Thing::new())
    }
}

impl ::protobuf::Message for AttributeType_Put_Res {
    fn is_initialized(&self) -> bool {
        for v in &self.attribute {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attribute)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.attribute.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.attribute.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeType_Put_Res {
        AttributeType_Put_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Thing>>(
                    "attribute",
                    |m: &AttributeType_Put_Res| { &m.attribute },
                    |m: &mut AttributeType_Put_Res| { &mut m.attribute },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AttributeType_Put_Res>(
                    "AttributeType_Put_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttributeType_Put_Res {
        static mut instance: ::protobuf::lazy::Lazy<AttributeType_Put_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttributeType_Put_Res,
        };
        unsafe {
            instance.get(AttributeType_Put_Res::new)
        }
    }
}

impl ::protobuf::Clear for AttributeType_Put_Res {
    fn clear(&mut self) {
        self.attribute.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeType_Put_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeType_Put_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeType_Get {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeType_Get {
    fn default() -> &'a AttributeType_Get {
        <AttributeType_Get as ::protobuf::Message>::default_instance()
    }
}

impl AttributeType_Get {
    pub fn new() -> AttributeType_Get {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AttributeType_Get {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeType_Get {
        AttributeType_Get::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AttributeType_Get>(
                    "AttributeType_Get",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttributeType_Get {
        static mut instance: ::protobuf::lazy::Lazy<AttributeType_Get> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttributeType_Get,
        };
        unsafe {
            instance.get(AttributeType_Get::new)
        }
    }
}

impl ::protobuf::Clear for AttributeType_Get {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeType_Get {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeType_Get {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeType_Get_Req {
    // message fields
    pub value: ::protobuf::SingularPtrField<Attribute_Value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeType_Get_Req {
    fn default() -> &'a AttributeType_Get_Req {
        <AttributeType_Get_Req as ::protobuf::Message>::default_instance()
    }
}

impl AttributeType_Get_Req {
    pub fn new() -> AttributeType_Get_Req {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Attribute.Value value = 1;


    pub fn get_value(&self) -> &Attribute_Value {
        self.value.as_ref().unwrap_or_else(|| Attribute_Value::default_instance())
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: Attribute_Value) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut Attribute_Value {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> Attribute_Value {
        self.value.take().unwrap_or_else(|| Attribute_Value::new())
    }
}

impl ::protobuf::Message for AttributeType_Get_Req {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeType_Get_Req {
        AttributeType_Get_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Attribute_Value>>(
                    "value",
                    |m: &AttributeType_Get_Req| { &m.value },
                    |m: &mut AttributeType_Get_Req| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AttributeType_Get_Req>(
                    "AttributeType_Get_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttributeType_Get_Req {
        static mut instance: ::protobuf::lazy::Lazy<AttributeType_Get_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttributeType_Get_Req,
        };
        unsafe {
            instance.get(AttributeType_Get_Req::new)
        }
    }
}

impl ::protobuf::Clear for AttributeType_Get_Req {
    fn clear(&mut self) {
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeType_Get_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeType_Get_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeType_Get_Res {
    // message oneof groups
    pub res: ::std::option::Option<AttributeType_Get_Res_oneof_res>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeType_Get_Res {
    fn default() -> &'a AttributeType_Get_Res {
        <AttributeType_Get_Res as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum AttributeType_Get_Res_oneof_res {
    attribute(Thing),
}

impl AttributeType_Get_Res {
    pub fn new() -> AttributeType_Get_Res {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Thing attribute = 1;


    pub fn get_attribute(&self) -> &Thing {
        match self.res {
            ::std::option::Option::Some(AttributeType_Get_Res_oneof_res::attribute(ref v)) => v,
            _ => Thing::default_instance(),
        }
    }
    pub fn clear_attribute(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_attribute(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(AttributeType_Get_Res_oneof_res::attribute(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_attribute(&mut self, v: Thing) {
        self.res = ::std::option::Option::Some(AttributeType_Get_Res_oneof_res::attribute(v))
    }

    // Mutable pointer to the field.
    pub fn mut_attribute(&mut self) -> &mut Thing {
        if let ::std::option::Option::Some(AttributeType_Get_Res_oneof_res::attribute(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(AttributeType_Get_Res_oneof_res::attribute(Thing::new()));
        }
        match self.res {
            ::std::option::Option::Some(AttributeType_Get_Res_oneof_res::attribute(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_attribute(&mut self) -> Thing {
        if self.has_attribute() {
            match self.res.take() {
                ::std::option::Option::Some(AttributeType_Get_Res_oneof_res::attribute(v)) => v,
                _ => panic!(),
            }
        } else {
            Thing::new()
        }
    }
}

impl ::protobuf::Message for AttributeType_Get_Res {
    fn is_initialized(&self) -> bool {
        if let Some(AttributeType_Get_Res_oneof_res::attribute(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(AttributeType_Get_Res_oneof_res::attribute(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &AttributeType_Get_Res_oneof_res::attribute(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &AttributeType_Get_Res_oneof_res::attribute(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeType_Get_Res {
        AttributeType_Get_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Thing>(
                    "attribute",
                    AttributeType_Get_Res::has_attribute,
                    AttributeType_Get_Res::get_attribute,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AttributeType_Get_Res>(
                    "AttributeType_Get_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttributeType_Get_Res {
        static mut instance: ::protobuf::lazy::Lazy<AttributeType_Get_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttributeType_Get_Res,
        };
        unsafe {
            instance.get(AttributeType_Get_Res::new)
        }
    }
}

impl ::protobuf::Clear for AttributeType_Get_Res {
    fn clear(&mut self) {
        self.res = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeType_Get_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeType_Get_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeType_GetOwners {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeType_GetOwners {
    fn default() -> &'a AttributeType_GetOwners {
        <AttributeType_GetOwners as ::protobuf::Message>::default_instance()
    }
}

impl AttributeType_GetOwners {
    pub fn new() -> AttributeType_GetOwners {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AttributeType_GetOwners {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeType_GetOwners {
        AttributeType_GetOwners::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AttributeType_GetOwners>(
                    "AttributeType_GetOwners",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttributeType_GetOwners {
        static mut instance: ::protobuf::lazy::Lazy<AttributeType_GetOwners> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttributeType_GetOwners,
        };
        unsafe {
            instance.get(AttributeType_GetOwners::new)
        }
    }
}

impl ::protobuf::Clear for AttributeType_GetOwners {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeType_GetOwners {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeType_GetOwners {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeType_GetOwners_Req {
    // message fields
    pub only_key: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeType_GetOwners_Req {
    fn default() -> &'a AttributeType_GetOwners_Req {
        <AttributeType_GetOwners_Req as ::protobuf::Message>::default_instance()
    }
}

impl AttributeType_GetOwners_Req {
    pub fn new() -> AttributeType_GetOwners_Req {
        ::std::default::Default::default()
    }

    // bool only_key = 1;


    pub fn get_only_key(&self) -> bool {
        self.only_key
    }
    pub fn clear_only_key(&mut self) {
        self.only_key = false;
    }

    // Param is passed by value, moved
    pub fn set_only_key(&mut self, v: bool) {
        self.only_key = v;
    }
}

impl ::protobuf::Message for AttributeType_GetOwners_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.only_key = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.only_key != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.only_key != false {
            os.write_bool(1, self.only_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeType_GetOwners_Req {
        AttributeType_GetOwners_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "only_key",
                    |m: &AttributeType_GetOwners_Req| { &m.only_key },
                    |m: &mut AttributeType_GetOwners_Req| { &mut m.only_key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AttributeType_GetOwners_Req>(
                    "AttributeType_GetOwners_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttributeType_GetOwners_Req {
        static mut instance: ::protobuf::lazy::Lazy<AttributeType_GetOwners_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttributeType_GetOwners_Req,
        };
        unsafe {
            instance.get(AttributeType_GetOwners_Req::new)
        }
    }
}

impl ::protobuf::Clear for AttributeType_GetOwners_Req {
    fn clear(&mut self) {
        self.only_key = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeType_GetOwners_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeType_GetOwners_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeType_GetOwners_ResPart {
    // message fields
    pub owners: ::protobuf::RepeatedField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeType_GetOwners_ResPart {
    fn default() -> &'a AttributeType_GetOwners_ResPart {
        <AttributeType_GetOwners_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl AttributeType_GetOwners_ResPart {
    pub fn new() -> AttributeType_GetOwners_ResPart {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.Type owners = 1;


    pub fn get_owners(&self) -> &[Type] {
        &self.owners
    }
    pub fn clear_owners(&mut self) {
        self.owners.clear();
    }

    // Param is passed by value, moved
    pub fn set_owners(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.owners = v;
    }

    // Mutable pointer to the field.
    pub fn mut_owners(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.owners
    }

    // Take field
    pub fn take_owners(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.owners, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AttributeType_GetOwners_ResPart {
    fn is_initialized(&self) -> bool {
        for v in &self.owners {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.owners)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.owners {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.owners {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeType_GetOwners_ResPart {
        AttributeType_GetOwners_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "owners",
                    |m: &AttributeType_GetOwners_ResPart| { &m.owners },
                    |m: &mut AttributeType_GetOwners_ResPart| { &mut m.owners },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AttributeType_GetOwners_ResPart>(
                    "AttributeType_GetOwners_ResPart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttributeType_GetOwners_ResPart {
        static mut instance: ::protobuf::lazy::Lazy<AttributeType_GetOwners_ResPart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttributeType_GetOwners_ResPart,
        };
        unsafe {
            instance.get(AttributeType_GetOwners_ResPart::new)
        }
    }
}

impl ::protobuf::Clear for AttributeType_GetOwners_ResPart {
    fn clear(&mut self) {
        self.owners.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeType_GetOwners_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeType_GetOwners_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeType_GetRegex {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeType_GetRegex {
    fn default() -> &'a AttributeType_GetRegex {
        <AttributeType_GetRegex as ::protobuf::Message>::default_instance()
    }
}

impl AttributeType_GetRegex {
    pub fn new() -> AttributeType_GetRegex {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AttributeType_GetRegex {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeType_GetRegex {
        AttributeType_GetRegex::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AttributeType_GetRegex>(
                    "AttributeType_GetRegex",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttributeType_GetRegex {
        static mut instance: ::protobuf::lazy::Lazy<AttributeType_GetRegex> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttributeType_GetRegex,
        };
        unsafe {
            instance.get(AttributeType_GetRegex::new)
        }
    }
}

impl ::protobuf::Clear for AttributeType_GetRegex {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeType_GetRegex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeType_GetRegex {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeType_GetRegex_Req {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeType_GetRegex_Req {
    fn default() -> &'a AttributeType_GetRegex_Req {
        <AttributeType_GetRegex_Req as ::protobuf::Message>::default_instance()
    }
}

impl AttributeType_GetRegex_Req {
    pub fn new() -> AttributeType_GetRegex_Req {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AttributeType_GetRegex_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeType_GetRegex_Req {
        AttributeType_GetRegex_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AttributeType_GetRegex_Req>(
                    "AttributeType_GetRegex_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttributeType_GetRegex_Req {
        static mut instance: ::protobuf::lazy::Lazy<AttributeType_GetRegex_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttributeType_GetRegex_Req,
        };
        unsafe {
            instance.get(AttributeType_GetRegex_Req::new)
        }
    }
}

impl ::protobuf::Clear for AttributeType_GetRegex_Req {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeType_GetRegex_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeType_GetRegex_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeType_GetRegex_Res {
    // message fields
    pub regex: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeType_GetRegex_Res {
    fn default() -> &'a AttributeType_GetRegex_Res {
        <AttributeType_GetRegex_Res as ::protobuf::Message>::default_instance()
    }
}

impl AttributeType_GetRegex_Res {
    pub fn new() -> AttributeType_GetRegex_Res {
        ::std::default::Default::default()
    }

    // string regex = 1;


    pub fn get_regex(&self) -> &str {
        &self.regex
    }
    pub fn clear_regex(&mut self) {
        self.regex.clear();
    }

    // Param is passed by value, moved
    pub fn set_regex(&mut self, v: ::std::string::String) {
        self.regex = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_regex(&mut self) -> &mut ::std::string::String {
        &mut self.regex
    }

    // Take field
    pub fn take_regex(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.regex, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AttributeType_GetRegex_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.regex)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.regex.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.regex);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.regex.is_empty() {
            os.write_string(1, &self.regex)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeType_GetRegex_Res {
        AttributeType_GetRegex_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "regex",
                    |m: &AttributeType_GetRegex_Res| { &m.regex },
                    |m: &mut AttributeType_GetRegex_Res| { &mut m.regex },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AttributeType_GetRegex_Res>(
                    "AttributeType_GetRegex_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttributeType_GetRegex_Res {
        static mut instance: ::protobuf::lazy::Lazy<AttributeType_GetRegex_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttributeType_GetRegex_Res,
        };
        unsafe {
            instance.get(AttributeType_GetRegex_Res::new)
        }
    }
}

impl ::protobuf::Clear for AttributeType_GetRegex_Res {
    fn clear(&mut self) {
        self.regex.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeType_GetRegex_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeType_GetRegex_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeType_SetRegex {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeType_SetRegex {
    fn default() -> &'a AttributeType_SetRegex {
        <AttributeType_SetRegex as ::protobuf::Message>::default_instance()
    }
}

impl AttributeType_SetRegex {
    pub fn new() -> AttributeType_SetRegex {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AttributeType_SetRegex {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeType_SetRegex {
        AttributeType_SetRegex::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AttributeType_SetRegex>(
                    "AttributeType_SetRegex",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttributeType_SetRegex {
        static mut instance: ::protobuf::lazy::Lazy<AttributeType_SetRegex> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttributeType_SetRegex,
        };
        unsafe {
            instance.get(AttributeType_SetRegex::new)
        }
    }
}

impl ::protobuf::Clear for AttributeType_SetRegex {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeType_SetRegex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeType_SetRegex {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeType_SetRegex_Req {
    // message fields
    pub regex: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeType_SetRegex_Req {
    fn default() -> &'a AttributeType_SetRegex_Req {
        <AttributeType_SetRegex_Req as ::protobuf::Message>::default_instance()
    }
}

impl AttributeType_SetRegex_Req {
    pub fn new() -> AttributeType_SetRegex_Req {
        ::std::default::Default::default()
    }

    // string regex = 1;


    pub fn get_regex(&self) -> &str {
        &self.regex
    }
    pub fn clear_regex(&mut self) {
        self.regex.clear();
    }

    // Param is passed by value, moved
    pub fn set_regex(&mut self, v: ::std::string::String) {
        self.regex = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_regex(&mut self) -> &mut ::std::string::String {
        &mut self.regex
    }

    // Take field
    pub fn take_regex(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.regex, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AttributeType_SetRegex_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.regex)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.regex.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.regex);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.regex.is_empty() {
            os.write_string(1, &self.regex)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeType_SetRegex_Req {
        AttributeType_SetRegex_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "regex",
                    |m: &AttributeType_SetRegex_Req| { &m.regex },
                    |m: &mut AttributeType_SetRegex_Req| { &mut m.regex },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AttributeType_SetRegex_Req>(
                    "AttributeType_SetRegex_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttributeType_SetRegex_Req {
        static mut instance: ::protobuf::lazy::Lazy<AttributeType_SetRegex_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttributeType_SetRegex_Req,
        };
        unsafe {
            instance.get(AttributeType_SetRegex_Req::new)
        }
    }
}

impl ::protobuf::Clear for AttributeType_SetRegex_Req {
    fn clear(&mut self) {
        self.regex.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeType_SetRegex_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeType_SetRegex_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeType_SetRegex_Res {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeType_SetRegex_Res {
    fn default() -> &'a AttributeType_SetRegex_Res {
        <AttributeType_SetRegex_Res as ::protobuf::Message>::default_instance()
    }
}

impl AttributeType_SetRegex_Res {
    pub fn new() -> AttributeType_SetRegex_Res {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AttributeType_SetRegex_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeType_SetRegex_Res {
        AttributeType_SetRegex_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AttributeType_SetRegex_Res>(
                    "AttributeType_SetRegex_Res",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttributeType_SetRegex_Res {
        static mut instance: ::protobuf::lazy::Lazy<AttributeType_SetRegex_Res> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttributeType_SetRegex_Res,
        };
        unsafe {
            instance.get(AttributeType_SetRegex_Res::new)
        }
    }
}

impl ::protobuf::Clear for AttributeType_SetRegex_Res {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeType_SetRegex_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeType_SetRegex_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeType_GetSubtypes {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeType_GetSubtypes {
    fn default() -> &'a AttributeType_GetSubtypes {
        <AttributeType_GetSubtypes as ::protobuf::Message>::default_instance()
    }
}

impl AttributeType_GetSubtypes {
    pub fn new() -> AttributeType_GetSubtypes {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AttributeType_GetSubtypes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeType_GetSubtypes {
        AttributeType_GetSubtypes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AttributeType_GetSubtypes>(
                    "AttributeType_GetSubtypes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttributeType_GetSubtypes {
        static mut instance: ::protobuf::lazy::Lazy<AttributeType_GetSubtypes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttributeType_GetSubtypes,
        };
        unsafe {
            instance.get(AttributeType_GetSubtypes::new)
        }
    }
}

impl ::protobuf::Clear for AttributeType_GetSubtypes {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeType_GetSubtypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeType_GetSubtypes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeType_GetSubtypes_Req {
    // message oneof groups
    pub req: ::std::option::Option<AttributeType_GetSubtypes_Req_oneof_req>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeType_GetSubtypes_Req {
    fn default() -> &'a AttributeType_GetSubtypes_Req {
        <AttributeType_GetSubtypes_Req as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum AttributeType_GetSubtypes_Req_oneof_req {
    value_type(AttributeType_ValueType),
}

impl AttributeType_GetSubtypes_Req {
    pub fn new() -> AttributeType_GetSubtypes_Req {
        ::std::default::Default::default()
    }

    // .typedb.protocol.AttributeType.ValueType value_type = 1;


    pub fn get_value_type(&self) -> AttributeType_ValueType {
        match self.req {
            ::std::option::Option::Some(AttributeType_GetSubtypes_Req_oneof_req::value_type(v)) => v,
            _ => AttributeType_ValueType::OBJECT,
        }
    }
    pub fn clear_value_type(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_value_type(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(AttributeType_GetSubtypes_Req_oneof_req::value_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_value_type(&mut self, v: AttributeType_ValueType) {
        self.req = ::std::option::Option::Some(AttributeType_GetSubtypes_Req_oneof_req::value_type(v))
    }
}

impl ::protobuf::Message for AttributeType_GetSubtypes_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(AttributeType_GetSubtypes_Req_oneof_req::value_type(is.read_enum()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.req {
            match v {
                &AttributeType_GetSubtypes_Req_oneof_req::value_type(v) => {
                    my_size += ::protobuf::rt::enum_size(1, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.req {
            match v {
                &AttributeType_GetSubtypes_Req_oneof_req::value_type(v) => {
                    os.write_enum(1, v.value())?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeType_GetSubtypes_Req {
        AttributeType_GetSubtypes_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, AttributeType_ValueType>(
                    "value_type",
                    AttributeType_GetSubtypes_Req::has_value_type,
                    AttributeType_GetSubtypes_Req::get_value_type,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AttributeType_GetSubtypes_Req>(
                    "AttributeType_GetSubtypes_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttributeType_GetSubtypes_Req {
        static mut instance: ::protobuf::lazy::Lazy<AttributeType_GetSubtypes_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttributeType_GetSubtypes_Req,
        };
        unsafe {
            instance.get(AttributeType_GetSubtypes_Req::new)
        }
    }
}

impl ::protobuf::Clear for AttributeType_GetSubtypes_Req {
    fn clear(&mut self) {
        self.req = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeType_GetSubtypes_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeType_GetSubtypes_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeType_GetSubtypes_ResPart {
    // message fields
    pub types: ::protobuf::RepeatedField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeType_GetSubtypes_ResPart {
    fn default() -> &'a AttributeType_GetSubtypes_ResPart {
        <AttributeType_GetSubtypes_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl AttributeType_GetSubtypes_ResPart {
    pub fn new() -> AttributeType_GetSubtypes_ResPart {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.Type types = 1;


    pub fn get_types(&self) -> &[Type] {
        &self.types
    }
    pub fn clear_types(&mut self) {
        self.types.clear();
    }

    // Param is passed by value, moved
    pub fn set_types(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_types(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.types
    }

    // Take field
    pub fn take_types(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.types, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AttributeType_GetSubtypes_ResPart {
    fn is_initialized(&self) -> bool {
        for v in &self.types {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.types {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeType_GetSubtypes_ResPart {
        AttributeType_GetSubtypes_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "types",
                    |m: &AttributeType_GetSubtypes_ResPart| { &m.types },
                    |m: &mut AttributeType_GetSubtypes_ResPart| { &mut m.types },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AttributeType_GetSubtypes_ResPart>(
                    "AttributeType_GetSubtypes_ResPart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttributeType_GetSubtypes_ResPart {
        static mut instance: ::protobuf::lazy::Lazy<AttributeType_GetSubtypes_ResPart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttributeType_GetSubtypes_ResPart,
        };
        unsafe {
            instance.get(AttributeType_GetSubtypes_ResPart::new)
        }
    }
}

impl ::protobuf::Clear for AttributeType_GetSubtypes_ResPart {
    fn clear(&mut self) {
        self.types.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeType_GetSubtypes_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeType_GetSubtypes_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeType_GetInstances {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeType_GetInstances {
    fn default() -> &'a AttributeType_GetInstances {
        <AttributeType_GetInstances as ::protobuf::Message>::default_instance()
    }
}

impl AttributeType_GetInstances {
    pub fn new() -> AttributeType_GetInstances {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AttributeType_GetInstances {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeType_GetInstances {
        AttributeType_GetInstances::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AttributeType_GetInstances>(
                    "AttributeType_GetInstances",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttributeType_GetInstances {
        static mut instance: ::protobuf::lazy::Lazy<AttributeType_GetInstances> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttributeType_GetInstances,
        };
        unsafe {
            instance.get(AttributeType_GetInstances::new)
        }
    }
}

impl ::protobuf::Clear for AttributeType_GetInstances {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeType_GetInstances {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeType_GetInstances {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeType_GetInstances_Req {
    // message oneof groups
    pub req: ::std::option::Option<AttributeType_GetInstances_Req_oneof_req>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeType_GetInstances_Req {
    fn default() -> &'a AttributeType_GetInstances_Req {
        <AttributeType_GetInstances_Req as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum AttributeType_GetInstances_Req_oneof_req {
    value_type(AttributeType_ValueType),
}

impl AttributeType_GetInstances_Req {
    pub fn new() -> AttributeType_GetInstances_Req {
        ::std::default::Default::default()
    }

    // .typedb.protocol.AttributeType.ValueType value_type = 1;


    pub fn get_value_type(&self) -> AttributeType_ValueType {
        match self.req {
            ::std::option::Option::Some(AttributeType_GetInstances_Req_oneof_req::value_type(v)) => v,
            _ => AttributeType_ValueType::OBJECT,
        }
    }
    pub fn clear_value_type(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_value_type(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(AttributeType_GetInstances_Req_oneof_req::value_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_value_type(&mut self, v: AttributeType_ValueType) {
        self.req = ::std::option::Option::Some(AttributeType_GetInstances_Req_oneof_req::value_type(v))
    }
}

impl ::protobuf::Message for AttributeType_GetInstances_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(AttributeType_GetInstances_Req_oneof_req::value_type(is.read_enum()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.req {
            match v {
                &AttributeType_GetInstances_Req_oneof_req::value_type(v) => {
                    my_size += ::protobuf::rt::enum_size(1, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.req {
            match v {
                &AttributeType_GetInstances_Req_oneof_req::value_type(v) => {
                    os.write_enum(1, v.value())?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeType_GetInstances_Req {
        AttributeType_GetInstances_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, AttributeType_ValueType>(
                    "value_type",
                    AttributeType_GetInstances_Req::has_value_type,
                    AttributeType_GetInstances_Req::get_value_type,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AttributeType_GetInstances_Req>(
                    "AttributeType_GetInstances_Req",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttributeType_GetInstances_Req {
        static mut instance: ::protobuf::lazy::Lazy<AttributeType_GetInstances_Req> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttributeType_GetInstances_Req,
        };
        unsafe {
            instance.get(AttributeType_GetInstances_Req::new)
        }
    }
}

impl ::protobuf::Clear for AttributeType_GetInstances_Req {
    fn clear(&mut self) {
        self.req = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeType_GetInstances_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeType_GetInstances_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeType_GetInstances_ResPart {
    // message fields
    pub things: ::protobuf::RepeatedField<Thing>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeType_GetInstances_ResPart {
    fn default() -> &'a AttributeType_GetInstances_ResPart {
        <AttributeType_GetInstances_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl AttributeType_GetInstances_ResPart {
    pub fn new() -> AttributeType_GetInstances_ResPart {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.Thing things = 1;


    pub fn get_things(&self) -> &[Thing] {
        &self.things
    }
    pub fn clear_things(&mut self) {
        self.things.clear();
    }

    // Param is passed by value, moved
    pub fn set_things(&mut self, v: ::protobuf::RepeatedField<Thing>) {
        self.things = v;
    }

    // Mutable pointer to the field.
    pub fn mut_things(&mut self) -> &mut ::protobuf::RepeatedField<Thing> {
        &mut self.things
    }

    // Take field
    pub fn take_things(&mut self) -> ::protobuf::RepeatedField<Thing> {
        ::std::mem::replace(&mut self.things, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AttributeType_GetInstances_ResPart {
    fn is_initialized(&self) -> bool {
        for v in &self.things {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.things)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.things {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.things {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeType_GetInstances_ResPart {
        AttributeType_GetInstances_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Thing>>(
                    "things",
                    |m: &AttributeType_GetInstances_ResPart| { &m.things },
                    |m: &mut AttributeType_GetInstances_ResPart| { &mut m.things },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AttributeType_GetInstances_ResPart>(
                    "AttributeType_GetInstances_ResPart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttributeType_GetInstances_ResPart {
        static mut instance: ::protobuf::lazy::Lazy<AttributeType_GetInstances_ResPart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttributeType_GetInstances_ResPart,
        };
        unsafe {
            instance.get(AttributeType_GetInstances_ResPart::new)
        }
    }
}

impl ::protobuf::Clear for AttributeType_GetInstances_ResPart {
    fn clear(&mut self) {
        self.things.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeType_GetInstances_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeType_GetInstances_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AttributeType_ValueType {
    OBJECT = 0,
    BOOLEAN = 1,
    LONG = 2,
    DOUBLE = 3,
    STRING = 4,
    DATETIME = 5,
}

impl ::protobuf::ProtobufEnum for AttributeType_ValueType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AttributeType_ValueType> {
        match value {
            0 => ::std::option::Option::Some(AttributeType_ValueType::OBJECT),
            1 => ::std::option::Option::Some(AttributeType_ValueType::BOOLEAN),
            2 => ::std::option::Option::Some(AttributeType_ValueType::LONG),
            3 => ::std::option::Option::Some(AttributeType_ValueType::DOUBLE),
            4 => ::std::option::Option::Some(AttributeType_ValueType::STRING),
            5 => ::std::option::Option::Some(AttributeType_ValueType::DATETIME),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AttributeType_ValueType] = &[
            AttributeType_ValueType::OBJECT,
            AttributeType_ValueType::BOOLEAN,
            AttributeType_ValueType::LONG,
            AttributeType_ValueType::DOUBLE,
            AttributeType_ValueType::STRING,
            AttributeType_ValueType::DATETIME,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AttributeType_ValueType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AttributeType_ValueType {
}

impl ::std::default::Default for AttributeType_ValueType {
    fn default() -> Self {
        AttributeType_ValueType::OBJECT
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeType_ValueType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x14common/concept.proto\x12\x0ftypedb.protocol\"\x84\r\n\x0eConceptMa\
    nager\x1a\xfc\x03\n\x03Req\x12_\n\x12get_thing_type_req\x18\x01\x20\x01(\
    \x0b20.typedb.protocol.ConceptManager.GetThingType.ReqH\0R\x0fgetThingTy\
    peReq\x12R\n\rget_thing_req\x18\x02\x20\x01(\x0b2,.typedb.protocol.Conce\
    ptManager.GetThing.ReqH\0R\x0bgetThingReq\x12b\n\x13put_entity_type_req\
    \x18\x03\x20\x01(\x0b21.typedb.protocol.ConceptManager.PutEntityType.Req\
    H\0R\x10putEntityTypeReq\x12k\n\x16put_attribute_type_req\x18\x04\x20\
    \x01(\x0b24.typedb.protocol.ConceptManager.PutAttributeType.ReqH\0R\x13p\
    utAttributeTypeReq\x12h\n\x15put_relation_type_req\x18\x05\x20\x01(\x0b2\
    3.typedb.protocol.ConceptManager.PutRelationType.ReqH\0R\x12putRelationT\
    ypeReqB\x05\n\x03req\x1a\xfc\x03\n\x03Res\x12_\n\x12get_thing_type_res\
    \x18\x01\x20\x01(\x0b20.typedb.protocol.ConceptManager.GetThingType.ResH\
    \0R\x0fgetThingTypeRes\x12R\n\rget_thing_res\x18\x02\x20\x01(\x0b2,.type\
    db.protocol.ConceptManager.GetThing.ResH\0R\x0bgetThingRes\x12b\n\x13put\
    _entity_type_res\x18\x03\x20\x01(\x0b21.typedb.protocol.ConceptManager.P\
    utEntityType.ResH\0R\x10putEntityTypeRes\x12k\n\x16put_attribute_type_re\
    s\x18\x04\x20\x01(\x0b24.typedb.protocol.ConceptManager.PutAttributeType\
    .ResH\0R\x13putAttributeTypeRes\x12h\n\x15put_relation_type_res\x18\x05\
    \x20\x01(\x0b23.typedb.protocol.ConceptManager.PutRelationType.ResH\0R\
    \x12putRelationTypeResB\x05\n\x03res\x1aq\n\x0cGetThingType\x1a\x1b\n\
    \x03Req\x12\x14\n\x05label\x18\x01\x20\x01(\tR\x05label\x1aD\n\x03Res\
    \x126\n\nthing_type\x18\x01\x20\x01(\x0b2\x15.typedb.protocol.TypeH\0R\t\
    thingTypeB\x05\n\x03res\x1aa\n\x08GetThing\x1a\x17\n\x03Req\x12\x10\n\
    \x03iid\x18\x01\x20\x01(\x0cR\x03iid\x1a<\n\x03Res\x12.\n\x05thing\x18\
    \x01\x20\x01(\x0b2\x16.typedb.protocol.ThingH\0R\x05thingB\x05\n\x03res\
    \x1ak\n\rPutEntityType\x1a\x1b\n\x03Req\x12\x14\n\x05label\x18\x01\x20\
    \x01(\tR\x05label\x1a=\n\x03Res\x126\n\x0bentity_type\x18\x01\x20\x01(\
    \x0b2\x15.typedb.protocol.TypeR\nentityType\x1a\xbd\x01\n\x10PutAttribut\
    eType\x1ad\n\x03Req\x12\x14\n\x05label\x18\x01\x20\x01(\tR\x05label\x12G\
    \n\nvalue_type\x18\x02\x20\x01(\x0e2(.typedb.protocol.AttributeType.Valu\
    eTypeR\tvalueType\x1aC\n\x03Res\x12<\n\x0eattribute_type\x18\x01\x20\x01\
    (\x0b2\x15.typedb.protocol.TypeR\rattributeType\x1aq\n\x0fPutRelationTyp\
    e\x1a\x1b\n\x03Req\x12\x14\n\x05label\x18\x01\x20\x01(\tR\x05label\x1aA\
    \n\x03Res\x12:\n\rrelation_type\x18\x01\x20\x01(\x0b2\x15.typedb.protoco\
    l.TypeR\x0crelationType\"q\n\x07Concept\x12.\n\x05thing\x18\x01\x20\x01(\
    \x0b2\x16.typedb.protocol.ThingH\0R\x05thing\x12+\n\x04type\x18\x02\x20\
    \x01(\x0b2\x15.typedb.protocol.TypeH\0R\x04typeB\t\n\x07concept\"\x96\
    \x1b\n\x05Thing\x12\x10\n\x03iid\x18\x01\x20\x01(\x0cR\x03iid\x12)\n\x04\
    type\x18\x02\x20\x01(\x0b2\x15.typedb.protocol.TypeR\x04type\x126\n\x05v\
    alue\x18\x03\x20\x01(\x0b2\x20.typedb.protocol.Attribute.ValueR\x05value\
    \x12\x1a\n\x08inferred\x18\x04\x20\x01(\x08R\x08inferred\x1a\x80\n\n\x03\
    Req\x12\x10\n\x03iid\x18\x01\x20\x01(\x0cR\x03iid\x12M\n\x10thing_delete\
    _req\x18d\x20\x01(\x0b2!.typedb.protocol.Thing.Delete.ReqH\0R\x0ethingDe\
    leteReq\x12Q\n\x12thing_get_type_req\x18e\x20\x01(\x0b2\".typedb.protoco\
    l.Thing.GetType.ReqH\0R\x0fthingGetTypeReq\x12N\n\x11thing_get_has_req\
    \x18f\x20\x01(\x0b2!.typedb.protocol.Thing.GetHas.ReqH\0R\x0ethingGetHas\
    Req\x12N\n\x11thing_set_has_req\x18g\x20\x01(\x0b2!.typedb.protocol.Thin\
    g.SetHas.ReqH\0R\x0ethingSetHasReq\x12T\n\x13thing_unset_has_req\x18h\
    \x20\x01(\x0b2#.typedb.protocol.Thing.UnsetHas.ReqH\0R\x10thingUnsetHasR\
    eq\x12`\n\x17thing_get_relations_req\x18i\x20\x01(\x0b2'.typedb.protocol\
    .Thing.GetRelations.ReqH\0R\x14thingGetRelationsReq\x12Z\n\x15thing_get_\
    playing_req\x18j\x20\x01(\x0b2%.typedb.protocol.Thing.GetPlaying.ReqH\0R\
    \x12thingGetPlayingReq\x12a\n\x17relation_add_player_req\x18\xc8\x01\x20\
    \x01(\x0b2'.typedb.protocol.Relation.AddPlayer.ReqH\0R\x14relationAddPla\
    yerReq\x12j\n\x1arelation_remove_player_req\x18\xc9\x01\x20\x01(\x0b2*.t\
    ypedb.protocol.Relation.RemovePlayer.ReqH\0R\x17relationRemovePlayerReq\
    \x12d\n\x18relation_get_players_req\x18\xca\x01\x20\x01(\x0b2(.typedb.pr\
    otocol.Relation.GetPlayers.ReqH\0R\x15relationGetPlayersReq\x12\x85\x01\
    \n%relation_get_players_by_role_type_req\x18\xcb\x01\x20\x01(\x0b22.type\
    db.protocol.Relation.GetPlayersByRoleType.ReqH\0R\x1frelationGetPlayersB\
    yRoleTypeReq\x12g\n\x19relation_get_relating_req\x18\xcc\x01\x20\x01(\
    \x0b2).typedb.protocol.Relation.GetRelating.ReqH\0R\x16relationGetRelati\
    ngReq\x12d\n\x18attribute_get_owners_req\x18\xac\x02\x20\x01(\x0b2(.type\
    db.protocol.Attribute.GetOwners.ReqH\0R\x15attributeGetOwnersReqB\x05\n\
    \x03req\x1a\xa3\x04\n\x03Res\x12M\n\x10thing_delete_res\x18d\x20\x01(\
    \x0b2!.typedb.protocol.Thing.Delete.ResH\0R\x0ethingDeleteRes\x12Q\n\x12\
    thing_get_type_res\x18e\x20\x01(\x0b2\".typedb.protocol.Thing.GetType.Re\
    sH\0R\x0fthingGetTypeRes\x12N\n\x11thing_set_has_res\x18f\x20\x01(\x0b2!\
    .typedb.protocol.Thing.SetHas.ResH\0R\x0ethingSetHasRes\x12T\n\x13thing_\
    unset_has_res\x18g\x20\x01(\x0b2#.typedb.protocol.Thing.UnsetHas.ResH\0R\
    \x10thingUnsetHasRes\x12a\n\x17relation_add_player_res\x18\xc8\x01\x20\
    \x01(\x0b2'.typedb.protocol.Relation.AddPlayer.ResH\0R\x14relationAddPla\
    yerRes\x12j\n\x1arelation_remove_player_res\x18\xc9\x01\x20\x01(\x0b2*.t\
    ypedb.protocol.Relation.RemovePlayer.ResH\0R\x17relationRemovePlayerResB\
    \x05\n\x03res\x1a\xb6\x06\n\x07ResPart\x12[\n\x16thing_get_has_res_part\
    \x18d\x20\x01(\x0b2%.typedb.protocol.Thing.GetHas.ResPartH\0R\x12thingGe\
    tHasResPart\x12m\n\x1cthing_get_relations_res_part\x18e\x20\x01(\x0b2+.t\
    ypedb.protocol.Thing.GetRelations.ResPartH\0R\x18thingGetRelationsResPar\
    t\x12g\n\x1athing_get_playing_res_part\x18f\x20\x01(\x0b2).typedb.protoc\
    ol.Thing.GetPlaying.ResPartH\0R\x16thingGetPlayingResPart\x12q\n\x1drela\
    tion_get_players_res_part\x18\xc8\x01\x20\x01(\x0b2,.typedb.protocol.Rel\
    ation.GetPlayers.ResPartH\0R\x19relationGetPlayersResPart\x12\x92\x01\n*\
    relation_get_players_by_role_type_res_part\x18\xc9\x01\x20\x01(\x0b26.ty\
    pedb.protocol.Relation.GetPlayersByRoleType.ResPartH\0R#relationGetPlaye\
    rsByRoleTypeResPart\x12t\n\x1erelation_get_relating_res_part\x18\xca\x01\
    \x20\x01(\x0b2-.typedb.protocol.Relation.GetRelating.ResPartH\0R\x1arela\
    tionGetRelatingResPart\x12q\n\x1dattribute_get_owners_res_part\x18\xac\
    \x02\x20\x01(\x0b2,.typedb.protocol.Attribute.GetOwners.ResPartH\0R\x19a\
    ttributeGetOwnersResPartB\x05\n\x03res\x1a\x16\n\x06Delete\x1a\x05\n\x03\
    Req\x1a\x05\n\x03Res\x1aM\n\x07GetType\x1a\x05\n\x03Req\x1a;\n\x03Res\
    \x124\n\nthing_type\x18\x01\x20\x01(\x0b2\x15.typedb.protocol.TypeR\tthi\
    ngType\x1aL\n\x06SetHas\x1a;\n\x03Req\x124\n\tattribute\x18\x01\x20\x01(\
    \x0b2\x16.typedb.protocol.ThingR\tattribute\x1a\x05\n\x03Res\x1aN\n\x08U\
    nsetHas\x1a;\n\x03Req\x124\n\tattribute\x18\x01\x20\x01(\x0b2\x16.typedb\
    .protocol.ThingR\tattribute\x1a\x05\n\x03Res\x1a\xaf\x01\n\x06GetHas\x1a\
    b\n\x03Req\x12>\n\x0fattribute_types\x18\x01\x20\x03(\x0b2\x15.typedb.pr\
    otocol.TypeR\x0eattributeTypes\x12\x1b\n\tkeys_only\x18\x02\x20\x01(\x08\
    R\x08keysOnly\x1aA\n\x07ResPart\x126\n\nattributes\x18\x01\x20\x03(\x0b2\
    \x16.typedb.protocol.ThingR\nattributes\x1aT\n\nGetPlaying\x1a\x05\n\x03\
    Req\x1a?\n\x07ResPart\x124\n\nrole_types\x18\x01\x20\x03(\x0b2\x15.typed\
    b.protocol.TypeR\troleTypes\x1a\x8c\x01\n\x0cGetRelations\x1a;\n\x03Req\
    \x124\n\nrole_types\x18\x01\x20\x03(\x0b2\x15.typedb.protocol.TypeR\trol\
    eTypes\x1a?\n\x07ResPart\x124\n\trelations\x18\x01\x20\x03(\x0b2\x16.typ\
    edb.protocol.ThingR\trelations\"\x8a\x06\n\x08Relation\x1a}\n\tAddPlayer\
    \x1ai\n\x03Req\x122\n\trole_type\x18\x01\x20\x01(\x0b2\x15.typedb.protoc\
    ol.TypeR\x08roleType\x12.\n\x06player\x18\x02\x20\x01(\x0b2\x16.typedb.p\
    rotocol.ThingR\x06player\x1a\x05\n\x03Res\x1a\x80\x01\n\x0cRemovePlayer\
    \x1ai\n\x03Req\x122\n\trole_type\x18\x01\x20\x01(\x0b2\x15.typedb.protoc\
    ol.TypeR\x08roleType\x12.\n\x06player\x18\x02\x20\x01(\x0b2\x16.typedb.p\
    rotocol.ThingR\x06player\x1a\x05\n\x03Res\x1a\x84\x01\n\nGetPlayers\x1a;\
    \n\x03Req\x124\n\nrole_types\x18\x01\x20\x03(\x0b2\x15.typedb.protocol.T\
    ypeR\troleTypes\x1a9\n\x07ResPart\x12.\n\x06things\x18\x01\x20\x03(\x0b2\
    \x16.typedb.protocol.ThingR\x06things\x1a\x9d\x02\n\x14GetPlayersByRoleT\
    ype\x1ax\n\x12RoleTypeWithPlayer\x122\n\trole_type\x18\x01\x20\x01(\x0b2\
    \x15.typedb.protocol.TypeR\x08roleType\x12.\n\x06player\x18\x02\x20\x01(\
    \x0b2\x16.typedb.protocol.ThingR\x06player\x1a\x05\n\x03Req\x1a\x83\x01\
    \n\x07ResPart\x12x\n\x17role_types_with_players\x18\x01\x20\x03(\x0b2A.t\
    ypedb.protocol.Relation.GetPlayersByRoleType.RoleTypeWithPlayerR\x14role\
    TypesWithPlayers\x1aU\n\x0bGetRelating\x1a\x05\n\x03Req\x1a?\n\x07ResPar\
    t\x124\n\nrole_types\x18\x01\x20\x03(\x0b2\x15.typedb.protocol.TypeR\tro\
    leTypes\"\xb5\x02\n\tAttribute\x1a\x95\x01\n\x05Value\x12\x18\n\x06strin\
    g\x18\x01\x20\x01(\tH\0R\x06string\x12\x1a\n\x07boolean\x18\x02\x20\x01(\
    \x08H\0R\x07boolean\x12\x14\n\x04long\x18\x03\x20\x01(\x03H\0R\x04long\
    \x12\x18\n\x06double\x18\x04\x20\x01(\x01H\0R\x06double\x12\x1d\n\tdate_\
    time\x18\x05\x20\x01(\x03H\0R\x08dateTimeB\x07\n\x05value\x1a\x8f\x01\n\
    \tGetOwners\x1aG\n\x03Req\x126\n\nthing_type\x18\x01\x20\x01(\x0b2\x15.t\
    ypedb.protocol.TypeH\0R\tthingTypeB\x08\n\x06filter\x1a9\n\x07ResPart\
    \x12.\n\x06things\x18\x01\x20\x03(\x0b2\x16.typedb.protocol.ThingR\x06th\
    ings\"\xe06\n\x04Type\x12\x14\n\x05label\x18\x01\x20\x01(\tR\x05label\
    \x12\x14\n\x05scope\x18\x02\x20\x01(\tR\x05scope\x12:\n\x08encoding\x18\
    \x03\x20\x01(\x0e2\x1e.typedb.protocol.Type.EncodingR\x08encoding\x12G\n\
    \nvalue_type\x18\x04\x20\x01(\x0e2(.typedb.protocol.AttributeType.ValueT\
    ypeR\tvalueType\x12\x12\n\x04root\x18\x05\x20\x01(\x08R\x04root\x1a\x8b\
    \x18\n\x03Req\x12\x14\n\x05label\x18\x01\x20\x01(\tR\x05label\x12\x14\n\
    \x05scope\x18\x02\x20\x01(\tR\x05scope\x12J\n\x0ftype_delete_req\x18d\
    \x20\x01(\x0b2\x20.typedb.protocol.Type.Delete.ReqH\0R\rtypeDeleteReq\
    \x12Q\n\x12type_set_label_req\x18e\x20\x01(\x0b2\".typedb.protocol.Type.\
    SetLabel.ReqH\0R\x0ftypeSetLabelReq\x12W\n\x14type_is_abstract_req\x18f\
    \x20\x01(\x0b2$.typedb.protocol.Type.IsAbstract.ReqH\0R\x11typeIsAbstrac\
    tReq\x12]\n\x16type_get_supertype_req\x18g\x20\x01(\x0b2&.typedb.protoco\
    l.Type.GetSupertype.ReqH\0R\x13typeGetSupertypeReq\x12]\n\x16type_set_su\
    pertype_req\x18h\x20\x01(\x0b2&.typedb.protocol.Type.SetSupertype.ReqH\0\
    R\x13typeSetSupertypeReq\x12`\n\x17type_get_supertypes_req\x18i\x20\x01(\
    \x0b2'.typedb.protocol.Type.GetSupertypes.ReqH\0R\x14typeGetSupertypesRe\
    q\x12Z\n\x15type_get_subtypes_req\x18j\x20\x01(\x0b2%.typedb.protocol.Ty\
    pe.GetSubtypes.ReqH\0R\x12typeGetSubtypesReq\x12x\n\x20role_type_get_rel\
    ation_types_req\x18\xc8\x01\x20\x01(\x0b2..typedb.protocol.RoleType.GetR\
    elationTypes.ReqH\0R\x1broleTypeGetRelationTypesReq\x12e\n\x19role_type_\
    get_players_req\x18\xc9\x01\x20\x01(\x0b2(.typedb.protocol.RoleType.GetP\
    layers.ReqH\0R\x15roleTypeGetPlayersReq\x12n\n\x1cthing_type_get_instanc\
    es_req\x18\xac\x02\x20\x01(\x0b2+.typedb.protocol.ThingType.GetInstances\
    .ReqH\0R\x18thingTypeGetInstancesReq\x12k\n\x1bthing_type_set_abstract_r\
    eq\x18\xad\x02\x20\x01(\x0b2*.typedb.protocol.ThingType.SetAbstract.ReqH\
    \0R\x17thingTypeSetAbstractReq\x12q\n\x1dthing_type_unset_abstract_req\
    \x18\xae\x02\x20\x01(\x0b2,.typedb.protocol.ThingType.UnsetAbstract.ReqH\
    \0R\x19thingTypeUnsetAbstractReq\x12_\n\x17thing_type_get_owns_req\x18\
    \xaf\x02\x20\x01(\x0b2&.typedb.protocol.ThingType.GetOwns.ReqH\0R\x13thi\
    ngTypeGetOwnsReq\x12_\n\x17thing_type_set_owns_req\x18\xb0\x02\x20\x01(\
    \x0b2&.typedb.protocol.ThingType.SetOwns.ReqH\0R\x13thingTypeSetOwnsReq\
    \x12e\n\x19thing_type_unset_owns_req\x18\xb1\x02\x20\x01(\x0b2(.typedb.p\
    rotocol.ThingType.UnsetOwns.ReqH\0R\x15thingTypeUnsetOwnsReq\x12b\n\x18t\
    hing_type_get_plays_req\x18\xb2\x02\x20\x01(\x0b2'.typedb.protocol.Thing\
    Type.GetPlays.ReqH\0R\x14thingTypeGetPlaysReq\x12b\n\x18thing_type_set_p\
    lays_req\x18\xb3\x02\x20\x01(\x0b2'.typedb.protocol.ThingType.SetPlays.R\
    eqH\0R\x14thingTypeSetPlaysReq\x12h\n\x1athing_type_unset_plays_req\x18\
    \xb4\x02\x20\x01(\x0b2).typedb.protocol.ThingType.UnsetPlays.ReqH\0R\x16\
    thingTypeUnsetPlaysReq\x12^\n\x16entity_type_create_req\x18\x90\x03\x20\
    \x01(\x0b2&.typedb.protocol.EntityType.Create.ReqH\0R\x13entityTypeCreat\
    eReq\x12d\n\x18relation_type_create_req\x18\xf4\x03\x20\x01(\x0b2(.typed\
    b.protocol.RelationType.Create.ReqH\0R\x15relationTypeCreateReq\x12\x98\
    \x01\n,relation_type_get_relates_for_role_label_req\x18\xf5\x03\x20\x01(\
    \x0b28.typedb.protocol.RelationType.GetRelatesForRoleLabel.ReqH\0R%relat\
    ionTypeGetRelatesForRoleLabelReq\x12q\n\x1drelation_type_get_relates_req\
    \x18\xf6\x03\x20\x01(\x0b2,.typedb.protocol.RelationType.GetRelates.ReqH\
    \0R\x19relationTypeGetRelatesReq\x12q\n\x1drelation_type_set_relates_req\
    \x18\xf7\x03\x20\x01(\x0b2,.typedb.protocol.RelationType.SetRelates.ReqH\
    \0R\x19relationTypeSetRelatesReq\x12w\n\x1frelation_type_unset_relates_r\
    eq\x18\xf8\x03\x20\x01(\x0b2..typedb.protocol.RelationType.UnsetRelates.\
    ReqH\0R\x1brelationTypeUnsetRelatesReq\x12^\n\x16attribute_type_put_req\
    \x18\xd8\x04\x20\x01(\x0b2&.typedb.protocol.AttributeType.Put.ReqH\0R\
    \x13attributeTypePutReq\x12^\n\x16attribute_type_get_req\x18\xd9\x04\x20\
    \x01(\x0b2&.typedb.protocol.AttributeType.Get.ReqH\0R\x13attributeTypeGe\
    tReq\x12n\n\x1cattribute_type_get_regex_req\x18\xda\x04\x20\x01(\x0b2+.t\
    ypedb.protocol.AttributeType.GetRegex.ReqH\0R\x18attributeTypeGetRegexRe\
    q\x12n\n\x1cattribute_type_set_regex_req\x18\xdb\x04\x20\x01(\x0b2+.type\
    db.protocol.AttributeType.SetRegex.ReqH\0R\x18attributeTypeSetRegexReq\
    \x12q\n\x1dattribute_type_get_owners_req\x18\xdc\x04\x20\x01(\x0b2,.type\
    db.protocol.AttributeType.GetOwners.ReqH\0R\x19attributeTypeGetOwnersReq\
    B\x05\n\x03req\x1a\xa5\x10\n\x03Res\x12J\n\x0ftype_delete_res\x18d\x20\
    \x01(\x0b2\x20.typedb.protocol.Type.Delete.ResH\0R\rtypeDeleteRes\x12Q\n\
    \x12type_set_label_res\x18e\x20\x01(\x0b2\".typedb.protocol.Type.SetLabe\
    l.ResH\0R\x0ftypeSetLabelRes\x12W\n\x14type_is_abstract_res\x18f\x20\x01\
    (\x0b2$.typedb.protocol.Type.IsAbstract.ResH\0R\x11typeIsAbstractRes\x12\
    ]\n\x16type_get_supertype_res\x18g\x20\x01(\x0b2&.typedb.protocol.Type.G\
    etSupertype.ResH\0R\x13typeGetSupertypeRes\x12]\n\x16type_set_supertype_\
    res\x18h\x20\x01(\x0b2&.typedb.protocol.Type.SetSupertype.ResH\0R\x13typ\
    eSetSupertypeRes\x12k\n\x1bthing_type_set_abstract_res\x18\xac\x02\x20\
    \x01(\x0b2*.typedb.protocol.ThingType.SetAbstract.ResH\0R\x17thingTypeSe\
    tAbstractRes\x12q\n\x1dthing_type_unset_abstract_res\x18\xad\x02\x20\x01\
    (\x0b2,.typedb.protocol.ThingType.UnsetAbstract.ResH\0R\x19thingTypeUnse\
    tAbstractRes\x12_\n\x17thing_type_set_owns_res\x18\xae\x02\x20\x01(\x0b2\
    &.typedb.protocol.ThingType.SetOwns.ResH\0R\x13thingTypeSetOwnsRes\x12e\
    \n\x19thing_type_unset_owns_res\x18\xaf\x02\x20\x01(\x0b2(.typedb.protoc\
    ol.ThingType.UnsetOwns.ResH\0R\x15thingTypeUnsetOwnsRes\x12b\n\x18thing_\
    type_set_plays_res\x18\xb0\x02\x20\x01(\x0b2'.typedb.protocol.ThingType.\
    SetPlays.ResH\0R\x14thingTypeSetPlaysRes\x12h\n\x1athing_type_unset_play\
    s_res\x18\xb1\x02\x20\x01(\x0b2).typedb.protocol.ThingType.UnsetPlays.Re\
    sH\0R\x16thingTypeUnsetPlaysRes\x12^\n\x16entity_type_create_res\x18\x90\
    \x03\x20\x01(\x0b2&.typedb.protocol.EntityType.Create.ResH\0R\x13entityT\
    ypeCreateRes\x12d\n\x18relation_type_create_res\x18\xf4\x03\x20\x01(\x0b\
    2(.typedb.protocol.RelationType.Create.ResH\0R\x15relationTypeCreateRes\
    \x12\x98\x01\n,relation_type_get_relates_for_role_label_res\x18\xf5\x03\
    \x20\x01(\x0b28.typedb.protocol.RelationType.GetRelatesForRoleLabel.ResH\
    \0R%relationTypeGetRelatesForRoleLabelRes\x12q\n\x1drelation_type_set_re\
    lates_res\x18\xf6\x03\x20\x01(\x0b2,.typedb.protocol.RelationType.SetRel\
    ates.ResH\0R\x19relationTypeSetRelatesRes\x12w\n\x1frelation_type_unset_\
    relates_res\x18\xf7\x03\x20\x01(\x0b2..typedb.protocol.RelationType.Unse\
    tRelates.ResH\0R\x1brelationTypeUnsetRelatesRes\x12^\n\x16attribute_type\
    _put_res\x18\xd8\x04\x20\x01(\x0b2&.typedb.protocol.AttributeType.Put.Re\
    sH\0R\x13attributeTypePutRes\x12^\n\x16attribute_type_get_res\x18\xd9\
    \x04\x20\x01(\x0b2&.typedb.protocol.AttributeType.Get.ResH\0R\x13attribu\
    teTypeGetRes\x12n\n\x1cattribute_type_get_regex_res\x18\xda\x04\x20\x01(\
    \x0b2+.typedb.protocol.AttributeType.GetRegex.ResH\0R\x18attributeTypeGe\
    tRegexRes\x12n\n\x1cattribute_type_set_regex_res\x18\xdb\x04\x20\x01(\
    \x0b2+.typedb.protocol.AttributeType.SetRegex.ResH\0R\x18attributeTypeSe\
    tRegexResB\x05\n\x03res\x1a\xc0\x08\n\x07ResPart\x12m\n\x1ctype_get_supe\
    rtypes_res_part\x18d\x20\x01(\x0b2+.typedb.protocol.Type.GetSupertypes.R\
    esPartH\0R\x18typeGetSupertypesResPart\x12g\n\x1atype_get_subtypes_res_p\
    art\x18e\x20\x01(\x0b2).typedb.protocol.Type.GetSubtypes.ResPartH\0R\x16\
    typeGetSubtypesResPart\x12\x85\x01\n%role_type_get_relation_types_res_pa\
    rt\x18\xc8\x01\x20\x01(\x0b22.typedb.protocol.RoleType.GetRelationTypes.\
    ResPartH\0R\x1froleTypeGetRelationTypesResPart\x12r\n\x1erole_type_get_p\
    layers_res_part\x18\xc9\x01\x20\x01(\x0b2,.typedb.protocol.RoleType.GetP\
    layers.ResPartH\0R\x19roleTypeGetPlayersResPart\x12{\n!thing_type_get_in\
    stances_res_part\x18\xac\x02\x20\x01(\x0b2/.typedb.protocol.ThingType.Ge\
    tInstances.ResPartH\0R\x1cthingTypeGetInstancesResPart\x12l\n\x1cthing_t\
    ype_get_owns_res_part\x18\xad\x02\x20\x01(\x0b2*.typedb.protocol.ThingTy\
    pe.GetOwns.ResPartH\0R\x17thingTypeGetOwnsResPart\x12o\n\x1dthing_type_g\
    et_plays_res_part\x18\xae\x02\x20\x01(\x0b2+.typedb.protocol.ThingType.G\
    etPlays.ResPartH\0R\x18thingTypeGetPlaysResPart\x12~\n\"relation_type_ge\
    t_relates_res_part\x18\xf4\x03\x20\x01(\x0b20.typedb.protocol.RelationTy\
    pe.GetRelates.ResPartH\0R\x1drelationTypeGetRelatesResPart\x12~\n\"attri\
    bute_type_get_owners_res_part\x18\xd8\x04\x20\x01(\x0b20.typedb.protocol\
    .AttributeType.GetOwners.ResPartH\0R\x1dattributeTypeGetOwnersResPartB\
    \x05\n\x03res\x1a\x16\n\x06Delete\x1a\x05\n\x03Req\x1a\x05\n\x03Res\x1a.\
    \n\x08SetLabel\x1a\x1b\n\x03Req\x12\x14\n\x05label\x18\x01\x20\x01(\tR\
    \x05label\x1a\x05\n\x03Res\x1a6\n\nIsAbstract\x1a\x05\n\x03Req\x1a!\n\
    \x03Res\x12\x1a\n\x08abstract\x18\x01\x20\x01(\x08R\x08abstract\x1aP\n\
    \x0cGetSupertype\x1a\x05\n\x03Req\x1a9\n\x03Res\x12+\n\x04type\x18\x01\
    \x20\x01(\x0b2\x15.typedb.protocol.TypeH\0R\x04typeB\x05\n\x03res\x1aG\n\
    \x0cSetSupertype\x1a0\n\x03Req\x12)\n\x04type\x18\x01\x20\x01(\x0b2\x15.\
    typedb.protocol.TypeR\x04type\x1a\x05\n\x03Res\x1aN\n\rGetSupertypes\x1a\
    \x05\n\x03Req\x1a6\n\x07ResPart\x12+\n\x05types\x18\x01\x20\x03(\x0b2\
    \x15.typedb.protocol.TypeR\x05types\x1aL\n\x0bGetSubtypes\x1a\x05\n\x03R\
    eq\x1a6\n\x07ResPart\x12+\n\x05types\x18\x01\x20\x03(\x0b2\x15.typedb.pr\
    otocol.TypeR\x05types\"a\n\x08Encoding\x12\x0e\n\nTHING_TYPE\x10\0\x12\
    \x0f\n\x0bENTITY_TYPE\x10\x01\x12\x11\n\rRELATION_TYPE\x10\x02\x12\x12\n\
    \x0eATTRIBUTE_TYPE\x10\x03\x12\r\n\tROLE_TYPE\x10\x04\"\xc6\x01\n\x08Rol\
    eType\x1ab\n\x10GetRelationTypes\x1a\x05\n\x03Req\x1aG\n\x07ResPart\x12<\
    \n\x0erelation_types\x18\x01\x20\x03(\x0b2\x15.typedb.protocol.TypeR\rre\
    lationTypes\x1aV\n\nGetPlayers\x1a\x05\n\x03Req\x1aA\n\x07ResPart\x126\n\
    \x0bthing_types\x18\x01\x20\x03(\x0b2\x15.typedb.protocol.TypeR\nthingTy\
    pes\"\xab\x07\n\tThingType\x1a\x1b\n\x0bSetAbstract\x1a\x05\n\x03Req\x1a\
    \x05\n\x03Res\x1a\x1d\n\rUnsetAbstract\x1a\x05\n\x03Req\x1a\x05\n\x03Res\
    \x1aP\n\x0cGetInstances\x1a\x05\n\x03Req\x1a9\n\x07ResPart\x12.\n\x06thi\
    ngs\x18\x01\x20\x03(\x0b2\x16.typedb.protocol.ThingR\x06things\x1a\xcd\
    \x01\n\x07GetOwns\x1aw\n\x03Req\x12I\n\nvalue_type\x18\x01\x20\x01(\x0e2\
    (.typedb.protocol.AttributeType.ValueTypeH\0R\tvalueType\x12\x1b\n\tkeys\
    _only\x18\x03\x20\x01(\x08R\x08keysOnlyB\x08\n\x06filter\x1aI\n\x07ResPa\
    rt\x12>\n\x0fattribute_types\x18\x01\x20\x03(\x0b2\x15.typedb.protocol.T\
    ypeR\x0eattributeTypes\x1aI\n\x08GetPlays\x1a\x05\n\x03Req\x1a6\n\x07Res\
    Part\x12+\n\x05roles\x18\x01\x20\x03(\x0b2\x15.typedb.protocol.TypeR\x05\
    roles\x1a\xbd\x01\n\x07SetOwns\x1a\xaa\x01\n\x03Req\x12<\n\x0eattribute_\
    type\x18\x01\x20\x01(\x0b2\x15.typedb.protocol.TypeR\rattributeType\x12@\
    \n\x0foverridden_type\x18\x02\x20\x01(\x0b2\x15.typedb.protocol.TypeH\0R\
    \x0eoverriddenType\x12\x15\n\x06is_key\x18\x03\x20\x01(\x08R\x05isKeyB\
    \x0c\n\noverridden\x1a\x05\n\x03Res\x1a\x94\x01\n\x08SetPlays\x1a\x80\
    \x01\n\x03Req\x12)\n\x04role\x18\x01\x20\x01(\x0b2\x15.typedb.protocol.T\
    ypeR\x04role\x12@\n\x0foverridden_role\x18\x02\x20\x01(\x0b2\x15.typedb.\
    protocol.TypeH\0R\x0eoverriddenRoleB\x0c\n\noverridden\x1a\x05\n\x03Res\
    \x1aW\n\tUnsetOwns\x1aC\n\x03Req\x12<\n\x0eattribute_type\x18\x01\x20\
    \x01(\x0b2\x15.typedb.protocol.TypeR\rattributeType\x1a\x05\n\x03Res\x1a\
    E\n\nUnsetPlays\x1a0\n\x03Req\x12)\n\x04role\x18\x01\x20\x01(\x0b2\x15.t\
    ypedb.protocol.TypeR\x04role\x1a\x05\n\x03Res\"T\n\nEntityType\x1aF\n\
    \x06Create\x1a\x05\n\x03Req\x1a5\n\x03Res\x12.\n\x06entity\x18\x01\x20\
    \x01(\x0b2\x16.typedb.protocol.ThingR\x06entity\"\xc4\x03\n\x0cRelationT\
    ype\x1aJ\n\x06Create\x1a\x05\n\x03Req\x1a9\n\x03Res\x122\n\x08relation\
    \x18\x01\x20\x01(\x0b2\x16.typedb.protocol.ThingR\x08relation\x1aK\n\nGe\
    tRelates\x1a\x05\n\x03Req\x1a6\n\x07ResPart\x12+\n\x05roles\x18\x01\x20\
    \x03(\x0b2\x15.typedb.protocol.TypeR\x05roles\x1az\n\x16GetRelatesForRol\
    eLabel\x1a\x1b\n\x03Req\x12\x14\n\x05label\x18\x01\x20\x01(\tR\x05label\
    \x1aC\n\x03Res\x124\n\trole_type\x18\x01\x20\x01(\x0b2\x15.typedb.protoc\
    ol.TypeH\0R\x08roleTypeB\x06\n\x04role\x1ak\n\nSetRelates\x1aV\n\x03Req\
    \x12\x14\n\x05label\x18\x01\x20\x01(\tR\x05label\x12+\n\x10overridden_la\
    bel\x18\x02\x20\x01(\tH\0R\x0foverriddenLabelB\x0c\n\noverridden\x1a\x05\
    \n\x03Res\x1a2\n\x0cUnsetRelates\x1a\x1b\n\x03Req\x12\x14\n\x05label\x18\
    \x01\x20\x01(\tR\x05label\x1a\x05\n\x03Res\"\x85\x07\n\rAttributeType\
    \x1a\x81\x01\n\x03Put\x1a=\n\x03Req\x126\n\x05value\x18\x01\x20\x01(\x0b\
    2\x20.typedb.protocol.Attribute.ValueR\x05value\x1a;\n\x03Res\x124\n\tat\
    tribute\x18\x01\x20\x01(\x0b2\x16.typedb.protocol.ThingR\tattribute\x1a\
    \x8a\x01\n\x03Get\x1a=\n\x03Req\x126\n\x05value\x18\x01\x20\x01(\x0b2\
    \x20.typedb.protocol.Attribute.ValueR\x05value\x1aD\n\x03Res\x126\n\tatt\
    ribute\x18\x01\x20\x01(\x0b2\x16.typedb.protocol.ThingH\0R\tattributeB\
    \x05\n\x03res\x1ag\n\tGetOwners\x1a\x20\n\x03Req\x12\x19\n\x08only_key\
    \x18\x01\x20\x01(\x08R\x07onlyKey\x1a8\n\x07ResPart\x12-\n\x06owners\x18\
    \x01\x20\x03(\x0b2\x15.typedb.protocol.TypeR\x06owners\x1a.\n\x08GetRege\
    x\x1a\x05\n\x03Req\x1a\x1b\n\x03Res\x12\x14\n\x05regex\x18\x01\x20\x01(\
    \tR\x05regex\x1a.\n\x08SetRegex\x1a\x1b\n\x03Req\x12\x14\n\x05regex\x18\
    \x01\x20\x01(\tR\x05regex\x1a\x05\n\x03Res\x1a\x9e\x01\n\x0bGetSubtypes\
    \x1aW\n\x03Req\x12I\n\nvalue_type\x18\x01\x20\x01(\x0e2(.typedb.protocol\
    .AttributeType.ValueTypeH\0R\tvalueTypeB\x05\n\x03req\x1a6\n\x07ResPart\
    \x12+\n\x05types\x18\x01\x20\x03(\x0b2\x15.typedb.protocol.TypeR\x05type\
    s\x1a\xa2\x01\n\x0cGetInstances\x1aW\n\x03Req\x12I\n\nvalue_type\x18\x01\
    \x20\x01(\x0e2(.typedb.protocol.AttributeType.ValueTypeH\0R\tvalueTypeB\
    \x05\n\x03req\x1a9\n\x07ResPart\x12.\n\x06things\x18\x01\x20\x03(\x0b2\
    \x16.typedb.protocol.ThingR\x06things\"T\n\tValueType\x12\n\n\x06OBJECT\
    \x10\0\x12\x0b\n\x07BOOLEAN\x10\x01\x12\x08\n\x04LONG\x10\x02\x12\n\n\
    \x06DOUBLE\x10\x03\x12\n\n\x06STRING\x10\x04\x12\x0c\n\x08DATETIME\x10\
    \x05B+\n\x1bcom.vaticle.typedb.protocolB\x0cConceptProtob\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
