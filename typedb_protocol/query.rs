// This file is generated by rust-protobuf 2.18.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `common/query.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_2;

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager {
    fn default() -> &'a QueryManager {
        <QueryManager as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager {
    pub fn new() -> QueryManager {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryManager {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager {
        QueryManager::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager>(
                "QueryManager",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager {
        static instance: ::protobuf::rt::LazyV2<QueryManager> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager::new)
    }
}

impl ::protobuf::Clear for QueryManager {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_Req {
    // message fields
    pub options: ::protobuf::SingularPtrField<super::options::Options>,
    // message oneof groups
    pub req: ::std::option::Option<QueryManager_Req_oneof_req>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_Req {
    fn default() -> &'a QueryManager_Req {
        <QueryManager_Req as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum QueryManager_Req_oneof_req {
    define_req(QueryManager_Define_Req),
    undefine_req(QueryManager_Undefine_Req),
    match_req(QueryManager_Match_Req),
    match_aggregate_req(QueryManager_MatchAggregate_Req),
    match_group_req(QueryManager_MatchGroup_Req),
    match_group_aggregate_req(QueryManager_MatchGroupAggregate_Req),
    insert_req(QueryManager_Insert_Req),
    delete_req(QueryManager_Delete_Req),
    update_req(QueryManager_Update_Req),
    explain_req(QueryManager_Explain_Req),
}

impl QueryManager_Req {
    pub fn new() -> QueryManager_Req {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Options options = 1;


    pub fn get_options(&self) -> &super::options::Options {
        self.options.as_ref().unwrap_or_else(|| <super::options::Options as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: super::options::Options) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut super::options::Options {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> super::options::Options {
        self.options.take().unwrap_or_else(|| super::options::Options::new())
    }

    // .typedb.protocol.QueryManager.Define.Req define_req = 100;


    pub fn get_define_req(&self) -> &QueryManager_Define_Req {
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::define_req(ref v)) => v,
            _ => <QueryManager_Define_Req as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_define_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_define_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::define_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_define_req(&mut self, v: QueryManager_Define_Req) {
        self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::define_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_define_req(&mut self) -> &mut QueryManager_Define_Req {
        if let ::std::option::Option::Some(QueryManager_Req_oneof_req::define_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::define_req(QueryManager_Define_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::define_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_define_req(&mut self) -> QueryManager_Define_Req {
        if self.has_define_req() {
            match self.req.take() {
                ::std::option::Option::Some(QueryManager_Req_oneof_req::define_req(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryManager_Define_Req::new()
        }
    }

    // .typedb.protocol.QueryManager.Undefine.Req undefine_req = 101;


    pub fn get_undefine_req(&self) -> &QueryManager_Undefine_Req {
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::undefine_req(ref v)) => v,
            _ => <QueryManager_Undefine_Req as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_undefine_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_undefine_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::undefine_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_undefine_req(&mut self, v: QueryManager_Undefine_Req) {
        self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::undefine_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_undefine_req(&mut self) -> &mut QueryManager_Undefine_Req {
        if let ::std::option::Option::Some(QueryManager_Req_oneof_req::undefine_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::undefine_req(QueryManager_Undefine_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::undefine_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_undefine_req(&mut self) -> QueryManager_Undefine_Req {
        if self.has_undefine_req() {
            match self.req.take() {
                ::std::option::Option::Some(QueryManager_Req_oneof_req::undefine_req(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryManager_Undefine_Req::new()
        }
    }

    // .typedb.protocol.QueryManager.Match.Req match_req = 102;


    pub fn get_match_req(&self) -> &QueryManager_Match_Req {
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::match_req(ref v)) => v,
            _ => <QueryManager_Match_Req as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_match_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_match_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::match_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_match_req(&mut self, v: QueryManager_Match_Req) {
        self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::match_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_match_req(&mut self) -> &mut QueryManager_Match_Req {
        if let ::std::option::Option::Some(QueryManager_Req_oneof_req::match_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::match_req(QueryManager_Match_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::match_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_match_req(&mut self) -> QueryManager_Match_Req {
        if self.has_match_req() {
            match self.req.take() {
                ::std::option::Option::Some(QueryManager_Req_oneof_req::match_req(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryManager_Match_Req::new()
        }
    }

    // .typedb.protocol.QueryManager.MatchAggregate.Req match_aggregate_req = 103;


    pub fn get_match_aggregate_req(&self) -> &QueryManager_MatchAggregate_Req {
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::match_aggregate_req(ref v)) => v,
            _ => <QueryManager_MatchAggregate_Req as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_match_aggregate_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_match_aggregate_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::match_aggregate_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_match_aggregate_req(&mut self, v: QueryManager_MatchAggregate_Req) {
        self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::match_aggregate_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_match_aggregate_req(&mut self) -> &mut QueryManager_MatchAggregate_Req {
        if let ::std::option::Option::Some(QueryManager_Req_oneof_req::match_aggregate_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::match_aggregate_req(QueryManager_MatchAggregate_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::match_aggregate_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_match_aggregate_req(&mut self) -> QueryManager_MatchAggregate_Req {
        if self.has_match_aggregate_req() {
            match self.req.take() {
                ::std::option::Option::Some(QueryManager_Req_oneof_req::match_aggregate_req(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryManager_MatchAggregate_Req::new()
        }
    }

    // .typedb.protocol.QueryManager.MatchGroup.Req match_group_req = 104;


    pub fn get_match_group_req(&self) -> &QueryManager_MatchGroup_Req {
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::match_group_req(ref v)) => v,
            _ => <QueryManager_MatchGroup_Req as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_match_group_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_match_group_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::match_group_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_match_group_req(&mut self, v: QueryManager_MatchGroup_Req) {
        self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::match_group_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_match_group_req(&mut self) -> &mut QueryManager_MatchGroup_Req {
        if let ::std::option::Option::Some(QueryManager_Req_oneof_req::match_group_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::match_group_req(QueryManager_MatchGroup_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::match_group_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_match_group_req(&mut self) -> QueryManager_MatchGroup_Req {
        if self.has_match_group_req() {
            match self.req.take() {
                ::std::option::Option::Some(QueryManager_Req_oneof_req::match_group_req(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryManager_MatchGroup_Req::new()
        }
    }

    // .typedb.protocol.QueryManager.MatchGroupAggregate.Req match_group_aggregate_req = 105;


    pub fn get_match_group_aggregate_req(&self) -> &QueryManager_MatchGroupAggregate_Req {
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::match_group_aggregate_req(ref v)) => v,
            _ => <QueryManager_MatchGroupAggregate_Req as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_match_group_aggregate_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_match_group_aggregate_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::match_group_aggregate_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_match_group_aggregate_req(&mut self, v: QueryManager_MatchGroupAggregate_Req) {
        self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::match_group_aggregate_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_match_group_aggregate_req(&mut self) -> &mut QueryManager_MatchGroupAggregate_Req {
        if let ::std::option::Option::Some(QueryManager_Req_oneof_req::match_group_aggregate_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::match_group_aggregate_req(QueryManager_MatchGroupAggregate_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::match_group_aggregate_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_match_group_aggregate_req(&mut self) -> QueryManager_MatchGroupAggregate_Req {
        if self.has_match_group_aggregate_req() {
            match self.req.take() {
                ::std::option::Option::Some(QueryManager_Req_oneof_req::match_group_aggregate_req(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryManager_MatchGroupAggregate_Req::new()
        }
    }

    // .typedb.protocol.QueryManager.Insert.Req insert_req = 106;


    pub fn get_insert_req(&self) -> &QueryManager_Insert_Req {
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::insert_req(ref v)) => v,
            _ => <QueryManager_Insert_Req as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_insert_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_insert_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::insert_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_insert_req(&mut self, v: QueryManager_Insert_Req) {
        self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::insert_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_insert_req(&mut self) -> &mut QueryManager_Insert_Req {
        if let ::std::option::Option::Some(QueryManager_Req_oneof_req::insert_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::insert_req(QueryManager_Insert_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::insert_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_insert_req(&mut self) -> QueryManager_Insert_Req {
        if self.has_insert_req() {
            match self.req.take() {
                ::std::option::Option::Some(QueryManager_Req_oneof_req::insert_req(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryManager_Insert_Req::new()
        }
    }

    // .typedb.protocol.QueryManager.Delete.Req delete_req = 107;


    pub fn get_delete_req(&self) -> &QueryManager_Delete_Req {
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::delete_req(ref v)) => v,
            _ => <QueryManager_Delete_Req as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_delete_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_delete_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::delete_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_req(&mut self, v: QueryManager_Delete_Req) {
        self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::delete_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete_req(&mut self) -> &mut QueryManager_Delete_Req {
        if let ::std::option::Option::Some(QueryManager_Req_oneof_req::delete_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::delete_req(QueryManager_Delete_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::delete_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete_req(&mut self) -> QueryManager_Delete_Req {
        if self.has_delete_req() {
            match self.req.take() {
                ::std::option::Option::Some(QueryManager_Req_oneof_req::delete_req(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryManager_Delete_Req::new()
        }
    }

    // .typedb.protocol.QueryManager.Update.Req update_req = 108;


    pub fn get_update_req(&self) -> &QueryManager_Update_Req {
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::update_req(ref v)) => v,
            _ => <QueryManager_Update_Req as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_update_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_update_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::update_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_update_req(&mut self, v: QueryManager_Update_Req) {
        self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::update_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_update_req(&mut self) -> &mut QueryManager_Update_Req {
        if let ::std::option::Option::Some(QueryManager_Req_oneof_req::update_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::update_req(QueryManager_Update_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::update_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_update_req(&mut self) -> QueryManager_Update_Req {
        if self.has_update_req() {
            match self.req.take() {
                ::std::option::Option::Some(QueryManager_Req_oneof_req::update_req(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryManager_Update_Req::new()
        }
    }

    // .typedb.protocol.QueryManager.Explain.Req explain_req = 109;


    pub fn get_explain_req(&self) -> &QueryManager_Explain_Req {
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::explain_req(ref v)) => v,
            _ => <QueryManager_Explain_Req as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_explain_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_explain_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::explain_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_explain_req(&mut self, v: QueryManager_Explain_Req) {
        self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::explain_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_explain_req(&mut self) -> &mut QueryManager_Explain_Req {
        if let ::std::option::Option::Some(QueryManager_Req_oneof_req::explain_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::explain_req(QueryManager_Explain_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(QueryManager_Req_oneof_req::explain_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_explain_req(&mut self) -> QueryManager_Explain_Req {
        if self.has_explain_req() {
            match self.req.take() {
                ::std::option::Option::Some(QueryManager_Req_oneof_req::explain_req(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryManager_Explain_Req::new()
        }
    }
}

impl ::protobuf::Message for QueryManager_Req {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(QueryManager_Req_oneof_req::define_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(QueryManager_Req_oneof_req::undefine_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(QueryManager_Req_oneof_req::match_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(QueryManager_Req_oneof_req::match_aggregate_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(QueryManager_Req_oneof_req::match_group_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(QueryManager_Req_oneof_req::match_group_aggregate_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(QueryManager_Req_oneof_req::insert_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(QueryManager_Req_oneof_req::delete_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(QueryManager_Req_oneof_req::update_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(QueryManager_Req_oneof_req::explain_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                100 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::define_req(is.read_message()?));
                },
                101 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::undefine_req(is.read_message()?));
                },
                102 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::match_req(is.read_message()?));
                },
                103 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::match_aggregate_req(is.read_message()?));
                },
                104 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::match_group_req(is.read_message()?));
                },
                105 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::match_group_aggregate_req(is.read_message()?));
                },
                106 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::insert_req(is.read_message()?));
                },
                107 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::delete_req(is.read_message()?));
                },
                108 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::update_req(is.read_message()?));
                },
                109 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(QueryManager_Req_oneof_req::explain_req(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.req {
            match v {
                &QueryManager_Req_oneof_req::define_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &QueryManager_Req_oneof_req::undefine_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &QueryManager_Req_oneof_req::match_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &QueryManager_Req_oneof_req::match_aggregate_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &QueryManager_Req_oneof_req::match_group_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &QueryManager_Req_oneof_req::match_group_aggregate_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &QueryManager_Req_oneof_req::insert_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &QueryManager_Req_oneof_req::delete_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &QueryManager_Req_oneof_req::update_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &QueryManager_Req_oneof_req::explain_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.req {
            match v {
                &QueryManager_Req_oneof_req::define_req(ref v) => {
                    os.write_tag(100, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &QueryManager_Req_oneof_req::undefine_req(ref v) => {
                    os.write_tag(101, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &QueryManager_Req_oneof_req::match_req(ref v) => {
                    os.write_tag(102, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &QueryManager_Req_oneof_req::match_aggregate_req(ref v) => {
                    os.write_tag(103, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &QueryManager_Req_oneof_req::match_group_req(ref v) => {
                    os.write_tag(104, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &QueryManager_Req_oneof_req::match_group_aggregate_req(ref v) => {
                    os.write_tag(105, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &QueryManager_Req_oneof_req::insert_req(ref v) => {
                    os.write_tag(106, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &QueryManager_Req_oneof_req::delete_req(ref v) => {
                    os.write_tag(107, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &QueryManager_Req_oneof_req::update_req(ref v) => {
                    os.write_tag(108, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &QueryManager_Req_oneof_req::explain_req(ref v) => {
                    os.write_tag(109, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_Req {
        QueryManager_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::options::Options>>(
                "options",
                |m: &QueryManager_Req| { &m.options },
                |m: &mut QueryManager_Req| { &mut m.options },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryManager_Define_Req>(
                "define_req",
                QueryManager_Req::has_define_req,
                QueryManager_Req::get_define_req,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryManager_Undefine_Req>(
                "undefine_req",
                QueryManager_Req::has_undefine_req,
                QueryManager_Req::get_undefine_req,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryManager_Match_Req>(
                "match_req",
                QueryManager_Req::has_match_req,
                QueryManager_Req::get_match_req,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryManager_MatchAggregate_Req>(
                "match_aggregate_req",
                QueryManager_Req::has_match_aggregate_req,
                QueryManager_Req::get_match_aggregate_req,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryManager_MatchGroup_Req>(
                "match_group_req",
                QueryManager_Req::has_match_group_req,
                QueryManager_Req::get_match_group_req,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryManager_MatchGroupAggregate_Req>(
                "match_group_aggregate_req",
                QueryManager_Req::has_match_group_aggregate_req,
                QueryManager_Req::get_match_group_aggregate_req,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryManager_Insert_Req>(
                "insert_req",
                QueryManager_Req::has_insert_req,
                QueryManager_Req::get_insert_req,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryManager_Delete_Req>(
                "delete_req",
                QueryManager_Req::has_delete_req,
                QueryManager_Req::get_delete_req,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryManager_Update_Req>(
                "update_req",
                QueryManager_Req::has_update_req,
                QueryManager_Req::get_update_req,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryManager_Explain_Req>(
                "explain_req",
                QueryManager_Req::has_explain_req,
                QueryManager_Req::get_explain_req,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_Req>(
                "QueryManager.Req",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_Req {
        static instance: ::protobuf::rt::LazyV2<QueryManager_Req> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_Req::new)
    }
}

impl ::protobuf::Clear for QueryManager_Req {
    fn clear(&mut self) {
        self.options.clear();
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_Res {
    // message oneof groups
    pub res: ::std::option::Option<QueryManager_Res_oneof_res>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_Res {
    fn default() -> &'a QueryManager_Res {
        <QueryManager_Res as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum QueryManager_Res_oneof_res {
    define_res(QueryManager_Define_Res),
    undefine_res(QueryManager_Undefine_Res),
    match_aggregate_res(QueryManager_MatchAggregate_Res),
    delete_res(QueryManager_Delete_Res),
}

impl QueryManager_Res {
    pub fn new() -> QueryManager_Res {
        ::std::default::Default::default()
    }

    // .typedb.protocol.QueryManager.Define.Res define_res = 100;


    pub fn get_define_res(&self) -> &QueryManager_Define_Res {
        match self.res {
            ::std::option::Option::Some(QueryManager_Res_oneof_res::define_res(ref v)) => v,
            _ => <QueryManager_Define_Res as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_define_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_define_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(QueryManager_Res_oneof_res::define_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_define_res(&mut self, v: QueryManager_Define_Res) {
        self.res = ::std::option::Option::Some(QueryManager_Res_oneof_res::define_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_define_res(&mut self) -> &mut QueryManager_Define_Res {
        if let ::std::option::Option::Some(QueryManager_Res_oneof_res::define_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(QueryManager_Res_oneof_res::define_res(QueryManager_Define_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(QueryManager_Res_oneof_res::define_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_define_res(&mut self) -> QueryManager_Define_Res {
        if self.has_define_res() {
            match self.res.take() {
                ::std::option::Option::Some(QueryManager_Res_oneof_res::define_res(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryManager_Define_Res::new()
        }
    }

    // .typedb.protocol.QueryManager.Undefine.Res undefine_res = 101;


    pub fn get_undefine_res(&self) -> &QueryManager_Undefine_Res {
        match self.res {
            ::std::option::Option::Some(QueryManager_Res_oneof_res::undefine_res(ref v)) => v,
            _ => <QueryManager_Undefine_Res as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_undefine_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_undefine_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(QueryManager_Res_oneof_res::undefine_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_undefine_res(&mut self, v: QueryManager_Undefine_Res) {
        self.res = ::std::option::Option::Some(QueryManager_Res_oneof_res::undefine_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_undefine_res(&mut self) -> &mut QueryManager_Undefine_Res {
        if let ::std::option::Option::Some(QueryManager_Res_oneof_res::undefine_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(QueryManager_Res_oneof_res::undefine_res(QueryManager_Undefine_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(QueryManager_Res_oneof_res::undefine_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_undefine_res(&mut self) -> QueryManager_Undefine_Res {
        if self.has_undefine_res() {
            match self.res.take() {
                ::std::option::Option::Some(QueryManager_Res_oneof_res::undefine_res(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryManager_Undefine_Res::new()
        }
    }

    // .typedb.protocol.QueryManager.MatchAggregate.Res match_aggregate_res = 102;


    pub fn get_match_aggregate_res(&self) -> &QueryManager_MatchAggregate_Res {
        match self.res {
            ::std::option::Option::Some(QueryManager_Res_oneof_res::match_aggregate_res(ref v)) => v,
            _ => <QueryManager_MatchAggregate_Res as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_match_aggregate_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_match_aggregate_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(QueryManager_Res_oneof_res::match_aggregate_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_match_aggregate_res(&mut self, v: QueryManager_MatchAggregate_Res) {
        self.res = ::std::option::Option::Some(QueryManager_Res_oneof_res::match_aggregate_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_match_aggregate_res(&mut self) -> &mut QueryManager_MatchAggregate_Res {
        if let ::std::option::Option::Some(QueryManager_Res_oneof_res::match_aggregate_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(QueryManager_Res_oneof_res::match_aggregate_res(QueryManager_MatchAggregate_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(QueryManager_Res_oneof_res::match_aggregate_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_match_aggregate_res(&mut self) -> QueryManager_MatchAggregate_Res {
        if self.has_match_aggregate_res() {
            match self.res.take() {
                ::std::option::Option::Some(QueryManager_Res_oneof_res::match_aggregate_res(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryManager_MatchAggregate_Res::new()
        }
    }

    // .typedb.protocol.QueryManager.Delete.Res delete_res = 104;


    pub fn get_delete_res(&self) -> &QueryManager_Delete_Res {
        match self.res {
            ::std::option::Option::Some(QueryManager_Res_oneof_res::delete_res(ref v)) => v,
            _ => <QueryManager_Delete_Res as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_delete_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_delete_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(QueryManager_Res_oneof_res::delete_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_res(&mut self, v: QueryManager_Delete_Res) {
        self.res = ::std::option::Option::Some(QueryManager_Res_oneof_res::delete_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete_res(&mut self) -> &mut QueryManager_Delete_Res {
        if let ::std::option::Option::Some(QueryManager_Res_oneof_res::delete_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(QueryManager_Res_oneof_res::delete_res(QueryManager_Delete_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(QueryManager_Res_oneof_res::delete_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete_res(&mut self) -> QueryManager_Delete_Res {
        if self.has_delete_res() {
            match self.res.take() {
                ::std::option::Option::Some(QueryManager_Res_oneof_res::delete_res(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryManager_Delete_Res::new()
        }
    }
}

impl ::protobuf::Message for QueryManager_Res {
    fn is_initialized(&self) -> bool {
        if let Some(QueryManager_Res_oneof_res::define_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(QueryManager_Res_oneof_res::undefine_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(QueryManager_Res_oneof_res::match_aggregate_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(QueryManager_Res_oneof_res::delete_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                100 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(QueryManager_Res_oneof_res::define_res(is.read_message()?));
                },
                101 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(QueryManager_Res_oneof_res::undefine_res(is.read_message()?));
                },
                102 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(QueryManager_Res_oneof_res::match_aggregate_res(is.read_message()?));
                },
                104 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(QueryManager_Res_oneof_res::delete_res(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &QueryManager_Res_oneof_res::define_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &QueryManager_Res_oneof_res::undefine_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &QueryManager_Res_oneof_res::match_aggregate_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &QueryManager_Res_oneof_res::delete_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &QueryManager_Res_oneof_res::define_res(ref v) => {
                    os.write_tag(100, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &QueryManager_Res_oneof_res::undefine_res(ref v) => {
                    os.write_tag(101, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &QueryManager_Res_oneof_res::match_aggregate_res(ref v) => {
                    os.write_tag(102, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &QueryManager_Res_oneof_res::delete_res(ref v) => {
                    os.write_tag(104, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_Res {
        QueryManager_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryManager_Define_Res>(
                "define_res",
                QueryManager_Res::has_define_res,
                QueryManager_Res::get_define_res,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryManager_Undefine_Res>(
                "undefine_res",
                QueryManager_Res::has_undefine_res,
                QueryManager_Res::get_undefine_res,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryManager_MatchAggregate_Res>(
                "match_aggregate_res",
                QueryManager_Res::has_match_aggregate_res,
                QueryManager_Res::get_match_aggregate_res,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryManager_Delete_Res>(
                "delete_res",
                QueryManager_Res::has_delete_res,
                QueryManager_Res::get_delete_res,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_Res>(
                "QueryManager.Res",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_Res {
        static instance: ::protobuf::rt::LazyV2<QueryManager_Res> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_Res::new)
    }
}

impl ::protobuf::Clear for QueryManager_Res {
    fn clear(&mut self) {
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_ResPart {
    // message oneof groups
    pub res: ::std::option::Option<QueryManager_ResPart_oneof_res>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_ResPart {
    fn default() -> &'a QueryManager_ResPart {
        <QueryManager_ResPart as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum QueryManager_ResPart_oneof_res {
    match_res_part(QueryManager_Match_ResPart),
    match_group_res_part(QueryManager_MatchGroup_ResPart),
    match_group_aggregate_res_part(QueryManager_MatchGroupAggregate_ResPart),
    insert_res_part(QueryManager_Insert_ResPart),
    update_res_part(QueryManager_Update_ResPart),
    explain_res_part(QueryManager_Explain_ResPart),
}

impl QueryManager_ResPart {
    pub fn new() -> QueryManager_ResPart {
        ::std::default::Default::default()
    }

    // .typedb.protocol.QueryManager.Match.ResPart match_res_part = 100;


    pub fn get_match_res_part(&self) -> &QueryManager_Match_ResPart {
        match self.res {
            ::std::option::Option::Some(QueryManager_ResPart_oneof_res::match_res_part(ref v)) => v,
            _ => <QueryManager_Match_ResPart as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_match_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_match_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(QueryManager_ResPart_oneof_res::match_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_match_res_part(&mut self, v: QueryManager_Match_ResPart) {
        self.res = ::std::option::Option::Some(QueryManager_ResPart_oneof_res::match_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_match_res_part(&mut self) -> &mut QueryManager_Match_ResPart {
        if let ::std::option::Option::Some(QueryManager_ResPart_oneof_res::match_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(QueryManager_ResPart_oneof_res::match_res_part(QueryManager_Match_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(QueryManager_ResPart_oneof_res::match_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_match_res_part(&mut self) -> QueryManager_Match_ResPart {
        if self.has_match_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(QueryManager_ResPart_oneof_res::match_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryManager_Match_ResPart::new()
        }
    }

    // .typedb.protocol.QueryManager.MatchGroup.ResPart match_group_res_part = 101;


    pub fn get_match_group_res_part(&self) -> &QueryManager_MatchGroup_ResPart {
        match self.res {
            ::std::option::Option::Some(QueryManager_ResPart_oneof_res::match_group_res_part(ref v)) => v,
            _ => <QueryManager_MatchGroup_ResPart as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_match_group_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_match_group_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(QueryManager_ResPart_oneof_res::match_group_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_match_group_res_part(&mut self, v: QueryManager_MatchGroup_ResPart) {
        self.res = ::std::option::Option::Some(QueryManager_ResPart_oneof_res::match_group_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_match_group_res_part(&mut self) -> &mut QueryManager_MatchGroup_ResPart {
        if let ::std::option::Option::Some(QueryManager_ResPart_oneof_res::match_group_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(QueryManager_ResPart_oneof_res::match_group_res_part(QueryManager_MatchGroup_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(QueryManager_ResPart_oneof_res::match_group_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_match_group_res_part(&mut self) -> QueryManager_MatchGroup_ResPart {
        if self.has_match_group_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(QueryManager_ResPart_oneof_res::match_group_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryManager_MatchGroup_ResPart::new()
        }
    }

    // .typedb.protocol.QueryManager.MatchGroupAggregate.ResPart match_group_aggregate_res_part = 102;


    pub fn get_match_group_aggregate_res_part(&self) -> &QueryManager_MatchGroupAggregate_ResPart {
        match self.res {
            ::std::option::Option::Some(QueryManager_ResPart_oneof_res::match_group_aggregate_res_part(ref v)) => v,
            _ => <QueryManager_MatchGroupAggregate_ResPart as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_match_group_aggregate_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_match_group_aggregate_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(QueryManager_ResPart_oneof_res::match_group_aggregate_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_match_group_aggregate_res_part(&mut self, v: QueryManager_MatchGroupAggregate_ResPart) {
        self.res = ::std::option::Option::Some(QueryManager_ResPart_oneof_res::match_group_aggregate_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_match_group_aggregate_res_part(&mut self) -> &mut QueryManager_MatchGroupAggregate_ResPart {
        if let ::std::option::Option::Some(QueryManager_ResPart_oneof_res::match_group_aggregate_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(QueryManager_ResPart_oneof_res::match_group_aggregate_res_part(QueryManager_MatchGroupAggregate_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(QueryManager_ResPart_oneof_res::match_group_aggregate_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_match_group_aggregate_res_part(&mut self) -> QueryManager_MatchGroupAggregate_ResPart {
        if self.has_match_group_aggregate_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(QueryManager_ResPart_oneof_res::match_group_aggregate_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryManager_MatchGroupAggregate_ResPart::new()
        }
    }

    // .typedb.protocol.QueryManager.Insert.ResPart insert_res_part = 103;


    pub fn get_insert_res_part(&self) -> &QueryManager_Insert_ResPart {
        match self.res {
            ::std::option::Option::Some(QueryManager_ResPart_oneof_res::insert_res_part(ref v)) => v,
            _ => <QueryManager_Insert_ResPart as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_insert_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_insert_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(QueryManager_ResPart_oneof_res::insert_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_insert_res_part(&mut self, v: QueryManager_Insert_ResPart) {
        self.res = ::std::option::Option::Some(QueryManager_ResPart_oneof_res::insert_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_insert_res_part(&mut self) -> &mut QueryManager_Insert_ResPart {
        if let ::std::option::Option::Some(QueryManager_ResPart_oneof_res::insert_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(QueryManager_ResPart_oneof_res::insert_res_part(QueryManager_Insert_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(QueryManager_ResPart_oneof_res::insert_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_insert_res_part(&mut self) -> QueryManager_Insert_ResPart {
        if self.has_insert_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(QueryManager_ResPart_oneof_res::insert_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryManager_Insert_ResPart::new()
        }
    }

    // .typedb.protocol.QueryManager.Update.ResPart update_res_part = 104;


    pub fn get_update_res_part(&self) -> &QueryManager_Update_ResPart {
        match self.res {
            ::std::option::Option::Some(QueryManager_ResPart_oneof_res::update_res_part(ref v)) => v,
            _ => <QueryManager_Update_ResPart as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_update_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_update_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(QueryManager_ResPart_oneof_res::update_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_update_res_part(&mut self, v: QueryManager_Update_ResPart) {
        self.res = ::std::option::Option::Some(QueryManager_ResPart_oneof_res::update_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_update_res_part(&mut self) -> &mut QueryManager_Update_ResPart {
        if let ::std::option::Option::Some(QueryManager_ResPart_oneof_res::update_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(QueryManager_ResPart_oneof_res::update_res_part(QueryManager_Update_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(QueryManager_ResPart_oneof_res::update_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_update_res_part(&mut self) -> QueryManager_Update_ResPart {
        if self.has_update_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(QueryManager_ResPart_oneof_res::update_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryManager_Update_ResPart::new()
        }
    }

    // .typedb.protocol.QueryManager.Explain.ResPart explain_res_part = 105;


    pub fn get_explain_res_part(&self) -> &QueryManager_Explain_ResPart {
        match self.res {
            ::std::option::Option::Some(QueryManager_ResPart_oneof_res::explain_res_part(ref v)) => v,
            _ => <QueryManager_Explain_ResPart as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_explain_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_explain_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(QueryManager_ResPart_oneof_res::explain_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_explain_res_part(&mut self, v: QueryManager_Explain_ResPart) {
        self.res = ::std::option::Option::Some(QueryManager_ResPart_oneof_res::explain_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_explain_res_part(&mut self) -> &mut QueryManager_Explain_ResPart {
        if let ::std::option::Option::Some(QueryManager_ResPart_oneof_res::explain_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(QueryManager_ResPart_oneof_res::explain_res_part(QueryManager_Explain_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(QueryManager_ResPart_oneof_res::explain_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_explain_res_part(&mut self) -> QueryManager_Explain_ResPart {
        if self.has_explain_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(QueryManager_ResPart_oneof_res::explain_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryManager_Explain_ResPart::new()
        }
    }
}

impl ::protobuf::Message for QueryManager_ResPart {
    fn is_initialized(&self) -> bool {
        if let Some(QueryManager_ResPart_oneof_res::match_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(QueryManager_ResPart_oneof_res::match_group_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(QueryManager_ResPart_oneof_res::match_group_aggregate_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(QueryManager_ResPart_oneof_res::insert_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(QueryManager_ResPart_oneof_res::update_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(QueryManager_ResPart_oneof_res::explain_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                100 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(QueryManager_ResPart_oneof_res::match_res_part(is.read_message()?));
                },
                101 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(QueryManager_ResPart_oneof_res::match_group_res_part(is.read_message()?));
                },
                102 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(QueryManager_ResPart_oneof_res::match_group_aggregate_res_part(is.read_message()?));
                },
                103 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(QueryManager_ResPart_oneof_res::insert_res_part(is.read_message()?));
                },
                104 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(QueryManager_ResPart_oneof_res::update_res_part(is.read_message()?));
                },
                105 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(QueryManager_ResPart_oneof_res::explain_res_part(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &QueryManager_ResPart_oneof_res::match_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &QueryManager_ResPart_oneof_res::match_group_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &QueryManager_ResPart_oneof_res::match_group_aggregate_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &QueryManager_ResPart_oneof_res::insert_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &QueryManager_ResPart_oneof_res::update_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &QueryManager_ResPart_oneof_res::explain_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &QueryManager_ResPart_oneof_res::match_res_part(ref v) => {
                    os.write_tag(100, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &QueryManager_ResPart_oneof_res::match_group_res_part(ref v) => {
                    os.write_tag(101, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &QueryManager_ResPart_oneof_res::match_group_aggregate_res_part(ref v) => {
                    os.write_tag(102, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &QueryManager_ResPart_oneof_res::insert_res_part(ref v) => {
                    os.write_tag(103, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &QueryManager_ResPart_oneof_res::update_res_part(ref v) => {
                    os.write_tag(104, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &QueryManager_ResPart_oneof_res::explain_res_part(ref v) => {
                    os.write_tag(105, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_ResPart {
        QueryManager_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryManager_Match_ResPart>(
                "match_res_part",
                QueryManager_ResPart::has_match_res_part,
                QueryManager_ResPart::get_match_res_part,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryManager_MatchGroup_ResPart>(
                "match_group_res_part",
                QueryManager_ResPart::has_match_group_res_part,
                QueryManager_ResPart::get_match_group_res_part,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryManager_MatchGroupAggregate_ResPart>(
                "match_group_aggregate_res_part",
                QueryManager_ResPart::has_match_group_aggregate_res_part,
                QueryManager_ResPart::get_match_group_aggregate_res_part,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryManager_Insert_ResPart>(
                "insert_res_part",
                QueryManager_ResPart::has_insert_res_part,
                QueryManager_ResPart::get_insert_res_part,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryManager_Update_ResPart>(
                "update_res_part",
                QueryManager_ResPart::has_update_res_part,
                QueryManager_ResPart::get_update_res_part,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryManager_Explain_ResPart>(
                "explain_res_part",
                QueryManager_ResPart::has_explain_res_part,
                QueryManager_ResPart::get_explain_res_part,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_ResPart>(
                "QueryManager.ResPart",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_ResPart {
        static instance: ::protobuf::rt::LazyV2<QueryManager_ResPart> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_ResPart::new)
    }
}

impl ::protobuf::Clear for QueryManager_ResPart {
    fn clear(&mut self) {
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_Match {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_Match {
    fn default() -> &'a QueryManager_Match {
        <QueryManager_Match as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_Match {
    pub fn new() -> QueryManager_Match {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryManager_Match {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_Match {
        QueryManager_Match::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_Match>(
                "QueryManager.Match",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_Match {
        static instance: ::protobuf::rt::LazyV2<QueryManager_Match> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_Match::new)
    }
}

impl ::protobuf::Clear for QueryManager_Match {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_Match {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_Match {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_Match_Req {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_Match_Req {
    fn default() -> &'a QueryManager_Match_Req {
        <QueryManager_Match_Req as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_Match_Req {
    pub fn new() -> QueryManager_Match_Req {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryManager_Match_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_Match_Req {
        QueryManager_Match_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &QueryManager_Match_Req| { &m.query },
                |m: &mut QueryManager_Match_Req| { &mut m.query },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_Match_Req>(
                "QueryManager.Match.Req",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_Match_Req {
        static instance: ::protobuf::rt::LazyV2<QueryManager_Match_Req> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_Match_Req::new)
    }
}

impl ::protobuf::Clear for QueryManager_Match_Req {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_Match_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_Match_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_Match_ResPart {
    // message fields
    pub answers: ::protobuf::RepeatedField<super::answer::ConceptMap>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_Match_ResPart {
    fn default() -> &'a QueryManager_Match_ResPart {
        <QueryManager_Match_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_Match_ResPart {
    pub fn new() -> QueryManager_Match_ResPart {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.ConceptMap answers = 1;


    pub fn get_answers(&self) -> &[super::answer::ConceptMap] {
        &self.answers
    }
    pub fn clear_answers(&mut self) {
        self.answers.clear();
    }

    // Param is passed by value, moved
    pub fn set_answers(&mut self, v: ::protobuf::RepeatedField<super::answer::ConceptMap>) {
        self.answers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_answers(&mut self) -> &mut ::protobuf::RepeatedField<super::answer::ConceptMap> {
        &mut self.answers
    }

    // Take field
    pub fn take_answers(&mut self) -> ::protobuf::RepeatedField<super::answer::ConceptMap> {
        ::std::mem::replace(&mut self.answers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryManager_Match_ResPart {
    fn is_initialized(&self) -> bool {
        for v in &self.answers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.answers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.answers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.answers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_Match_ResPart {
        QueryManager_Match_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::answer::ConceptMap>>(
                "answers",
                |m: &QueryManager_Match_ResPart| { &m.answers },
                |m: &mut QueryManager_Match_ResPart| { &mut m.answers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_Match_ResPart>(
                "QueryManager.Match.ResPart",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_Match_ResPart {
        static instance: ::protobuf::rt::LazyV2<QueryManager_Match_ResPart> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_Match_ResPart::new)
    }
}

impl ::protobuf::Clear for QueryManager_Match_ResPart {
    fn clear(&mut self) {
        self.answers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_Match_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_Match_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_MatchAggregate {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_MatchAggregate {
    fn default() -> &'a QueryManager_MatchAggregate {
        <QueryManager_MatchAggregate as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_MatchAggregate {
    pub fn new() -> QueryManager_MatchAggregate {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryManager_MatchAggregate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_MatchAggregate {
        QueryManager_MatchAggregate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_MatchAggregate>(
                "QueryManager.MatchAggregate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_MatchAggregate {
        static instance: ::protobuf::rt::LazyV2<QueryManager_MatchAggregate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_MatchAggregate::new)
    }
}

impl ::protobuf::Clear for QueryManager_MatchAggregate {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_MatchAggregate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_MatchAggregate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_MatchAggregate_Req {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_MatchAggregate_Req {
    fn default() -> &'a QueryManager_MatchAggregate_Req {
        <QueryManager_MatchAggregate_Req as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_MatchAggregate_Req {
    pub fn new() -> QueryManager_MatchAggregate_Req {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryManager_MatchAggregate_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_MatchAggregate_Req {
        QueryManager_MatchAggregate_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &QueryManager_MatchAggregate_Req| { &m.query },
                |m: &mut QueryManager_MatchAggregate_Req| { &mut m.query },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_MatchAggregate_Req>(
                "QueryManager.MatchAggregate.Req",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_MatchAggregate_Req {
        static instance: ::protobuf::rt::LazyV2<QueryManager_MatchAggregate_Req> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_MatchAggregate_Req::new)
    }
}

impl ::protobuf::Clear for QueryManager_MatchAggregate_Req {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_MatchAggregate_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_MatchAggregate_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_MatchAggregate_Res {
    // message fields
    pub answer: ::protobuf::SingularPtrField<super::answer::Numeric>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_MatchAggregate_Res {
    fn default() -> &'a QueryManager_MatchAggregate_Res {
        <QueryManager_MatchAggregate_Res as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_MatchAggregate_Res {
    pub fn new() -> QueryManager_MatchAggregate_Res {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Numeric answer = 1;


    pub fn get_answer(&self) -> &super::answer::Numeric {
        self.answer.as_ref().unwrap_or_else(|| <super::answer::Numeric as ::protobuf::Message>::default_instance())
    }
    pub fn clear_answer(&mut self) {
        self.answer.clear();
    }

    pub fn has_answer(&self) -> bool {
        self.answer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer(&mut self, v: super::answer::Numeric) {
        self.answer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_answer(&mut self) -> &mut super::answer::Numeric {
        if self.answer.is_none() {
            self.answer.set_default();
        }
        self.answer.as_mut().unwrap()
    }

    // Take field
    pub fn take_answer(&mut self) -> super::answer::Numeric {
        self.answer.take().unwrap_or_else(|| super::answer::Numeric::new())
    }
}

impl ::protobuf::Message for QueryManager_MatchAggregate_Res {
    fn is_initialized(&self) -> bool {
        for v in &self.answer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.answer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.answer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.answer.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_MatchAggregate_Res {
        QueryManager_MatchAggregate_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::answer::Numeric>>(
                "answer",
                |m: &QueryManager_MatchAggregate_Res| { &m.answer },
                |m: &mut QueryManager_MatchAggregate_Res| { &mut m.answer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_MatchAggregate_Res>(
                "QueryManager.MatchAggregate.Res",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_MatchAggregate_Res {
        static instance: ::protobuf::rt::LazyV2<QueryManager_MatchAggregate_Res> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_MatchAggregate_Res::new)
    }
}

impl ::protobuf::Clear for QueryManager_MatchAggregate_Res {
    fn clear(&mut self) {
        self.answer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_MatchAggregate_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_MatchAggregate_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_MatchGroup {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_MatchGroup {
    fn default() -> &'a QueryManager_MatchGroup {
        <QueryManager_MatchGroup as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_MatchGroup {
    pub fn new() -> QueryManager_MatchGroup {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryManager_MatchGroup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_MatchGroup {
        QueryManager_MatchGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_MatchGroup>(
                "QueryManager.MatchGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_MatchGroup {
        static instance: ::protobuf::rt::LazyV2<QueryManager_MatchGroup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_MatchGroup::new)
    }
}

impl ::protobuf::Clear for QueryManager_MatchGroup {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_MatchGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_MatchGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_MatchGroup_Req {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_MatchGroup_Req {
    fn default() -> &'a QueryManager_MatchGroup_Req {
        <QueryManager_MatchGroup_Req as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_MatchGroup_Req {
    pub fn new() -> QueryManager_MatchGroup_Req {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryManager_MatchGroup_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_MatchGroup_Req {
        QueryManager_MatchGroup_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &QueryManager_MatchGroup_Req| { &m.query },
                |m: &mut QueryManager_MatchGroup_Req| { &mut m.query },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_MatchGroup_Req>(
                "QueryManager.MatchGroup.Req",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_MatchGroup_Req {
        static instance: ::protobuf::rt::LazyV2<QueryManager_MatchGroup_Req> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_MatchGroup_Req::new)
    }
}

impl ::protobuf::Clear for QueryManager_MatchGroup_Req {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_MatchGroup_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_MatchGroup_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_MatchGroup_ResPart {
    // message fields
    pub answers: ::protobuf::RepeatedField<super::answer::ConceptMapGroup>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_MatchGroup_ResPart {
    fn default() -> &'a QueryManager_MatchGroup_ResPart {
        <QueryManager_MatchGroup_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_MatchGroup_ResPart {
    pub fn new() -> QueryManager_MatchGroup_ResPart {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.ConceptMapGroup answers = 1;


    pub fn get_answers(&self) -> &[super::answer::ConceptMapGroup] {
        &self.answers
    }
    pub fn clear_answers(&mut self) {
        self.answers.clear();
    }

    // Param is passed by value, moved
    pub fn set_answers(&mut self, v: ::protobuf::RepeatedField<super::answer::ConceptMapGroup>) {
        self.answers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_answers(&mut self) -> &mut ::protobuf::RepeatedField<super::answer::ConceptMapGroup> {
        &mut self.answers
    }

    // Take field
    pub fn take_answers(&mut self) -> ::protobuf::RepeatedField<super::answer::ConceptMapGroup> {
        ::std::mem::replace(&mut self.answers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryManager_MatchGroup_ResPart {
    fn is_initialized(&self) -> bool {
        for v in &self.answers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.answers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.answers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.answers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_MatchGroup_ResPart {
        QueryManager_MatchGroup_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::answer::ConceptMapGroup>>(
                "answers",
                |m: &QueryManager_MatchGroup_ResPart| { &m.answers },
                |m: &mut QueryManager_MatchGroup_ResPart| { &mut m.answers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_MatchGroup_ResPart>(
                "QueryManager.MatchGroup.ResPart",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_MatchGroup_ResPart {
        static instance: ::protobuf::rt::LazyV2<QueryManager_MatchGroup_ResPart> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_MatchGroup_ResPart::new)
    }
}

impl ::protobuf::Clear for QueryManager_MatchGroup_ResPart {
    fn clear(&mut self) {
        self.answers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_MatchGroup_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_MatchGroup_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_MatchGroupAggregate {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_MatchGroupAggregate {
    fn default() -> &'a QueryManager_MatchGroupAggregate {
        <QueryManager_MatchGroupAggregate as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_MatchGroupAggregate {
    pub fn new() -> QueryManager_MatchGroupAggregate {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryManager_MatchGroupAggregate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_MatchGroupAggregate {
        QueryManager_MatchGroupAggregate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_MatchGroupAggregate>(
                "QueryManager.MatchGroupAggregate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_MatchGroupAggregate {
        static instance: ::protobuf::rt::LazyV2<QueryManager_MatchGroupAggregate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_MatchGroupAggregate::new)
    }
}

impl ::protobuf::Clear for QueryManager_MatchGroupAggregate {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_MatchGroupAggregate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_MatchGroupAggregate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_MatchGroupAggregate_Req {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_MatchGroupAggregate_Req {
    fn default() -> &'a QueryManager_MatchGroupAggregate_Req {
        <QueryManager_MatchGroupAggregate_Req as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_MatchGroupAggregate_Req {
    pub fn new() -> QueryManager_MatchGroupAggregate_Req {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryManager_MatchGroupAggregate_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_MatchGroupAggregate_Req {
        QueryManager_MatchGroupAggregate_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &QueryManager_MatchGroupAggregate_Req| { &m.query },
                |m: &mut QueryManager_MatchGroupAggregate_Req| { &mut m.query },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_MatchGroupAggregate_Req>(
                "QueryManager.MatchGroupAggregate.Req",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_MatchGroupAggregate_Req {
        static instance: ::protobuf::rt::LazyV2<QueryManager_MatchGroupAggregate_Req> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_MatchGroupAggregate_Req::new)
    }
}

impl ::protobuf::Clear for QueryManager_MatchGroupAggregate_Req {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_MatchGroupAggregate_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_MatchGroupAggregate_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_MatchGroupAggregate_ResPart {
    // message fields
    pub answers: ::protobuf::RepeatedField<super::answer::NumericGroup>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_MatchGroupAggregate_ResPart {
    fn default() -> &'a QueryManager_MatchGroupAggregate_ResPart {
        <QueryManager_MatchGroupAggregate_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_MatchGroupAggregate_ResPart {
    pub fn new() -> QueryManager_MatchGroupAggregate_ResPart {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.NumericGroup answers = 1;


    pub fn get_answers(&self) -> &[super::answer::NumericGroup] {
        &self.answers
    }
    pub fn clear_answers(&mut self) {
        self.answers.clear();
    }

    // Param is passed by value, moved
    pub fn set_answers(&mut self, v: ::protobuf::RepeatedField<super::answer::NumericGroup>) {
        self.answers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_answers(&mut self) -> &mut ::protobuf::RepeatedField<super::answer::NumericGroup> {
        &mut self.answers
    }

    // Take field
    pub fn take_answers(&mut self) -> ::protobuf::RepeatedField<super::answer::NumericGroup> {
        ::std::mem::replace(&mut self.answers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryManager_MatchGroupAggregate_ResPart {
    fn is_initialized(&self) -> bool {
        for v in &self.answers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.answers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.answers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.answers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_MatchGroupAggregate_ResPart {
        QueryManager_MatchGroupAggregate_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::answer::NumericGroup>>(
                "answers",
                |m: &QueryManager_MatchGroupAggregate_ResPart| { &m.answers },
                |m: &mut QueryManager_MatchGroupAggregate_ResPart| { &mut m.answers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_MatchGroupAggregate_ResPart>(
                "QueryManager.MatchGroupAggregate.ResPart",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_MatchGroupAggregate_ResPart {
        static instance: ::protobuf::rt::LazyV2<QueryManager_MatchGroupAggregate_ResPart> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_MatchGroupAggregate_ResPart::new)
    }
}

impl ::protobuf::Clear for QueryManager_MatchGroupAggregate_ResPart {
    fn clear(&mut self) {
        self.answers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_MatchGroupAggregate_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_MatchGroupAggregate_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_Explain {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_Explain {
    fn default() -> &'a QueryManager_Explain {
        <QueryManager_Explain as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_Explain {
    pub fn new() -> QueryManager_Explain {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryManager_Explain {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_Explain {
        QueryManager_Explain::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_Explain>(
                "QueryManager.Explain",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_Explain {
        static instance: ::protobuf::rt::LazyV2<QueryManager_Explain> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_Explain::new)
    }
}

impl ::protobuf::Clear for QueryManager_Explain {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_Explain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_Explain {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_Explain_Req {
    // message fields
    pub explainable_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_Explain_Req {
    fn default() -> &'a QueryManager_Explain_Req {
        <QueryManager_Explain_Req as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_Explain_Req {
    pub fn new() -> QueryManager_Explain_Req {
        ::std::default::Default::default()
    }

    // int64 explainable_id = 1;


    pub fn get_explainable_id(&self) -> i64 {
        self.explainable_id
    }
    pub fn clear_explainable_id(&mut self) {
        self.explainable_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_explainable_id(&mut self, v: i64) {
        self.explainable_id = v;
    }
}

impl ::protobuf::Message for QueryManager_Explain_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.explainable_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.explainable_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.explainable_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.explainable_id != 0 {
            os.write_int64(1, self.explainable_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_Explain_Req {
        QueryManager_Explain_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "explainable_id",
                |m: &QueryManager_Explain_Req| { &m.explainable_id },
                |m: &mut QueryManager_Explain_Req| { &mut m.explainable_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_Explain_Req>(
                "QueryManager.Explain.Req",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_Explain_Req {
        static instance: ::protobuf::rt::LazyV2<QueryManager_Explain_Req> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_Explain_Req::new)
    }
}

impl ::protobuf::Clear for QueryManager_Explain_Req {
    fn clear(&mut self) {
        self.explainable_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_Explain_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_Explain_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_Explain_ResPart {
    // message fields
    pub explanations: ::protobuf::RepeatedField<super::logic::Explanation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_Explain_ResPart {
    fn default() -> &'a QueryManager_Explain_ResPart {
        <QueryManager_Explain_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_Explain_ResPart {
    pub fn new() -> QueryManager_Explain_ResPart {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.Explanation explanations = 1;


    pub fn get_explanations(&self) -> &[super::logic::Explanation] {
        &self.explanations
    }
    pub fn clear_explanations(&mut self) {
        self.explanations.clear();
    }

    // Param is passed by value, moved
    pub fn set_explanations(&mut self, v: ::protobuf::RepeatedField<super::logic::Explanation>) {
        self.explanations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_explanations(&mut self) -> &mut ::protobuf::RepeatedField<super::logic::Explanation> {
        &mut self.explanations
    }

    // Take field
    pub fn take_explanations(&mut self) -> ::protobuf::RepeatedField<super::logic::Explanation> {
        ::std::mem::replace(&mut self.explanations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryManager_Explain_ResPart {
    fn is_initialized(&self) -> bool {
        for v in &self.explanations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.explanations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.explanations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.explanations {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_Explain_ResPart {
        QueryManager_Explain_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::logic::Explanation>>(
                "explanations",
                |m: &QueryManager_Explain_ResPart| { &m.explanations },
                |m: &mut QueryManager_Explain_ResPart| { &mut m.explanations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_Explain_ResPart>(
                "QueryManager.Explain.ResPart",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_Explain_ResPart {
        static instance: ::protobuf::rt::LazyV2<QueryManager_Explain_ResPart> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_Explain_ResPart::new)
    }
}

impl ::protobuf::Clear for QueryManager_Explain_ResPart {
    fn clear(&mut self) {
        self.explanations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_Explain_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_Explain_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_Insert {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_Insert {
    fn default() -> &'a QueryManager_Insert {
        <QueryManager_Insert as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_Insert {
    pub fn new() -> QueryManager_Insert {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryManager_Insert {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_Insert {
        QueryManager_Insert::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_Insert>(
                "QueryManager.Insert",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_Insert {
        static instance: ::protobuf::rt::LazyV2<QueryManager_Insert> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_Insert::new)
    }
}

impl ::protobuf::Clear for QueryManager_Insert {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_Insert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_Insert {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_Insert_Req {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_Insert_Req {
    fn default() -> &'a QueryManager_Insert_Req {
        <QueryManager_Insert_Req as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_Insert_Req {
    pub fn new() -> QueryManager_Insert_Req {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryManager_Insert_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_Insert_Req {
        QueryManager_Insert_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &QueryManager_Insert_Req| { &m.query },
                |m: &mut QueryManager_Insert_Req| { &mut m.query },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_Insert_Req>(
                "QueryManager.Insert.Req",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_Insert_Req {
        static instance: ::protobuf::rt::LazyV2<QueryManager_Insert_Req> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_Insert_Req::new)
    }
}

impl ::protobuf::Clear for QueryManager_Insert_Req {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_Insert_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_Insert_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_Insert_ResPart {
    // message fields
    pub answers: ::protobuf::RepeatedField<super::answer::ConceptMap>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_Insert_ResPart {
    fn default() -> &'a QueryManager_Insert_ResPart {
        <QueryManager_Insert_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_Insert_ResPart {
    pub fn new() -> QueryManager_Insert_ResPart {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.ConceptMap answers = 1;


    pub fn get_answers(&self) -> &[super::answer::ConceptMap] {
        &self.answers
    }
    pub fn clear_answers(&mut self) {
        self.answers.clear();
    }

    // Param is passed by value, moved
    pub fn set_answers(&mut self, v: ::protobuf::RepeatedField<super::answer::ConceptMap>) {
        self.answers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_answers(&mut self) -> &mut ::protobuf::RepeatedField<super::answer::ConceptMap> {
        &mut self.answers
    }

    // Take field
    pub fn take_answers(&mut self) -> ::protobuf::RepeatedField<super::answer::ConceptMap> {
        ::std::mem::replace(&mut self.answers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryManager_Insert_ResPart {
    fn is_initialized(&self) -> bool {
        for v in &self.answers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.answers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.answers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.answers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_Insert_ResPart {
        QueryManager_Insert_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::answer::ConceptMap>>(
                "answers",
                |m: &QueryManager_Insert_ResPart| { &m.answers },
                |m: &mut QueryManager_Insert_ResPart| { &mut m.answers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_Insert_ResPart>(
                "QueryManager.Insert.ResPart",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_Insert_ResPart {
        static instance: ::protobuf::rt::LazyV2<QueryManager_Insert_ResPart> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_Insert_ResPart::new)
    }
}

impl ::protobuf::Clear for QueryManager_Insert_ResPart {
    fn clear(&mut self) {
        self.answers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_Insert_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_Insert_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_Delete {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_Delete {
    fn default() -> &'a QueryManager_Delete {
        <QueryManager_Delete as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_Delete {
    pub fn new() -> QueryManager_Delete {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryManager_Delete {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_Delete {
        QueryManager_Delete::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_Delete>(
                "QueryManager.Delete",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_Delete {
        static instance: ::protobuf::rt::LazyV2<QueryManager_Delete> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_Delete::new)
    }
}

impl ::protobuf::Clear for QueryManager_Delete {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_Delete {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_Delete {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_Delete_Req {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_Delete_Req {
    fn default() -> &'a QueryManager_Delete_Req {
        <QueryManager_Delete_Req as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_Delete_Req {
    pub fn new() -> QueryManager_Delete_Req {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryManager_Delete_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_Delete_Req {
        QueryManager_Delete_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &QueryManager_Delete_Req| { &m.query },
                |m: &mut QueryManager_Delete_Req| { &mut m.query },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_Delete_Req>(
                "QueryManager.Delete.Req",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_Delete_Req {
        static instance: ::protobuf::rt::LazyV2<QueryManager_Delete_Req> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_Delete_Req::new)
    }
}

impl ::protobuf::Clear for QueryManager_Delete_Req {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_Delete_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_Delete_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_Delete_Res {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_Delete_Res {
    fn default() -> &'a QueryManager_Delete_Res {
        <QueryManager_Delete_Res as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_Delete_Res {
    pub fn new() -> QueryManager_Delete_Res {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryManager_Delete_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_Delete_Res {
        QueryManager_Delete_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_Delete_Res>(
                "QueryManager.Delete.Res",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_Delete_Res {
        static instance: ::protobuf::rt::LazyV2<QueryManager_Delete_Res> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_Delete_Res::new)
    }
}

impl ::protobuf::Clear for QueryManager_Delete_Res {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_Delete_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_Delete_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_Update {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_Update {
    fn default() -> &'a QueryManager_Update {
        <QueryManager_Update as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_Update {
    pub fn new() -> QueryManager_Update {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryManager_Update {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_Update {
        QueryManager_Update::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_Update>(
                "QueryManager.Update",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_Update {
        static instance: ::protobuf::rt::LazyV2<QueryManager_Update> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_Update::new)
    }
}

impl ::protobuf::Clear for QueryManager_Update {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_Update {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_Update {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_Update_Req {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_Update_Req {
    fn default() -> &'a QueryManager_Update_Req {
        <QueryManager_Update_Req as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_Update_Req {
    pub fn new() -> QueryManager_Update_Req {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryManager_Update_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_Update_Req {
        QueryManager_Update_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &QueryManager_Update_Req| { &m.query },
                |m: &mut QueryManager_Update_Req| { &mut m.query },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_Update_Req>(
                "QueryManager.Update.Req",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_Update_Req {
        static instance: ::protobuf::rt::LazyV2<QueryManager_Update_Req> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_Update_Req::new)
    }
}

impl ::protobuf::Clear for QueryManager_Update_Req {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_Update_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_Update_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_Update_ResPart {
    // message fields
    pub answers: ::protobuf::RepeatedField<super::answer::ConceptMap>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_Update_ResPart {
    fn default() -> &'a QueryManager_Update_ResPart {
        <QueryManager_Update_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_Update_ResPart {
    pub fn new() -> QueryManager_Update_ResPart {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.ConceptMap answers = 1;


    pub fn get_answers(&self) -> &[super::answer::ConceptMap] {
        &self.answers
    }
    pub fn clear_answers(&mut self) {
        self.answers.clear();
    }

    // Param is passed by value, moved
    pub fn set_answers(&mut self, v: ::protobuf::RepeatedField<super::answer::ConceptMap>) {
        self.answers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_answers(&mut self) -> &mut ::protobuf::RepeatedField<super::answer::ConceptMap> {
        &mut self.answers
    }

    // Take field
    pub fn take_answers(&mut self) -> ::protobuf::RepeatedField<super::answer::ConceptMap> {
        ::std::mem::replace(&mut self.answers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryManager_Update_ResPart {
    fn is_initialized(&self) -> bool {
        for v in &self.answers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.answers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.answers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.answers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_Update_ResPart {
        QueryManager_Update_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::answer::ConceptMap>>(
                "answers",
                |m: &QueryManager_Update_ResPart| { &m.answers },
                |m: &mut QueryManager_Update_ResPart| { &mut m.answers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_Update_ResPart>(
                "QueryManager.Update.ResPart",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_Update_ResPart {
        static instance: ::protobuf::rt::LazyV2<QueryManager_Update_ResPart> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_Update_ResPart::new)
    }
}

impl ::protobuf::Clear for QueryManager_Update_ResPart {
    fn clear(&mut self) {
        self.answers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_Update_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_Update_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_Define {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_Define {
    fn default() -> &'a QueryManager_Define {
        <QueryManager_Define as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_Define {
    pub fn new() -> QueryManager_Define {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryManager_Define {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_Define {
        QueryManager_Define::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_Define>(
                "QueryManager.Define",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_Define {
        static instance: ::protobuf::rt::LazyV2<QueryManager_Define> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_Define::new)
    }
}

impl ::protobuf::Clear for QueryManager_Define {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_Define {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_Define {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_Define_Req {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_Define_Req {
    fn default() -> &'a QueryManager_Define_Req {
        <QueryManager_Define_Req as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_Define_Req {
    pub fn new() -> QueryManager_Define_Req {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryManager_Define_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_Define_Req {
        QueryManager_Define_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &QueryManager_Define_Req| { &m.query },
                |m: &mut QueryManager_Define_Req| { &mut m.query },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_Define_Req>(
                "QueryManager.Define.Req",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_Define_Req {
        static instance: ::protobuf::rt::LazyV2<QueryManager_Define_Req> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_Define_Req::new)
    }
}

impl ::protobuf::Clear for QueryManager_Define_Req {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_Define_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_Define_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_Define_Res {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_Define_Res {
    fn default() -> &'a QueryManager_Define_Res {
        <QueryManager_Define_Res as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_Define_Res {
    pub fn new() -> QueryManager_Define_Res {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryManager_Define_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_Define_Res {
        QueryManager_Define_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_Define_Res>(
                "QueryManager.Define.Res",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_Define_Res {
        static instance: ::protobuf::rt::LazyV2<QueryManager_Define_Res> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_Define_Res::new)
    }
}

impl ::protobuf::Clear for QueryManager_Define_Res {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_Define_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_Define_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_Undefine {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_Undefine {
    fn default() -> &'a QueryManager_Undefine {
        <QueryManager_Undefine as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_Undefine {
    pub fn new() -> QueryManager_Undefine {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryManager_Undefine {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_Undefine {
        QueryManager_Undefine::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_Undefine>(
                "QueryManager.Undefine",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_Undefine {
        static instance: ::protobuf::rt::LazyV2<QueryManager_Undefine> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_Undefine::new)
    }
}

impl ::protobuf::Clear for QueryManager_Undefine {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_Undefine {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_Undefine {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_Undefine_Req {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_Undefine_Req {
    fn default() -> &'a QueryManager_Undefine_Req {
        <QueryManager_Undefine_Req as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_Undefine_Req {
    pub fn new() -> QueryManager_Undefine_Req {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryManager_Undefine_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_Undefine_Req {
        QueryManager_Undefine_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &QueryManager_Undefine_Req| { &m.query },
                |m: &mut QueryManager_Undefine_Req| { &mut m.query },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_Undefine_Req>(
                "QueryManager.Undefine.Req",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_Undefine_Req {
        static instance: ::protobuf::rt::LazyV2<QueryManager_Undefine_Req> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_Undefine_Req::new)
    }
}

impl ::protobuf::Clear for QueryManager_Undefine_Req {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_Undefine_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_Undefine_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryManager_Undefine_Res {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryManager_Undefine_Res {
    fn default() -> &'a QueryManager_Undefine_Res {
        <QueryManager_Undefine_Res as ::protobuf::Message>::default_instance()
    }
}

impl QueryManager_Undefine_Res {
    pub fn new() -> QueryManager_Undefine_Res {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryManager_Undefine_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryManager_Undefine_Res {
        QueryManager_Undefine_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryManager_Undefine_Res>(
                "QueryManager.Undefine.Res",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryManager_Undefine_Res {
        static instance: ::protobuf::rt::LazyV2<QueryManager_Undefine_Res> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryManager_Undefine_Res::new)
    }
}

impl ::protobuf::Clear for QueryManager_Undefine_Res {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryManager_Undefine_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryManager_Undefine_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12common/query.proto\x12\x0ftypedb.protocol\x1a\x13common/answer.pro\
    to\x1a\x12common/logic.proto\x1a\x14common/options.proto\"\xe6\x15\n\x0c\
    QueryManager\x1a\x83\x07\n\x03Req\x122\n\x07options\x18\x01\x20\x01(\x0b\
    2\x18.typedb.protocol.OptionsR\x07options\x12I\n\ndefine_req\x18d\x20\
    \x01(\x0b2(.typedb.protocol.QueryManager.Define.ReqH\0R\tdefineReq\x12O\
    \n\x0cundefine_req\x18e\x20\x01(\x0b2*.typedb.protocol.QueryManager.Unde\
    fine.ReqH\0R\x0bundefineReq\x12F\n\tmatch_req\x18f\x20\x01(\x0b2'.typedb\
    .protocol.QueryManager.Match.ReqH\0R\x08matchReq\x12b\n\x13match_aggrega\
    te_req\x18g\x20\x01(\x0b20.typedb.protocol.QueryManager.MatchAggregate.R\
    eqH\0R\x11matchAggregateReq\x12V\n\x0fmatch_group_req\x18h\x20\x01(\x0b2\
    ,.typedb.protocol.QueryManager.MatchGroup.ReqH\0R\rmatchGroupReq\x12r\n\
    \x19match_group_aggregate_req\x18i\x20\x01(\x0b25.typedb.protocol.QueryM\
    anager.MatchGroupAggregate.ReqH\0R\x16matchGroupAggregateReq\x12I\n\nins\
    ert_req\x18j\x20\x01(\x0b2(.typedb.protocol.QueryManager.Insert.ReqH\0R\
    \tinsertReq\x12I\n\ndelete_req\x18k\x20\x01(\x0b2(.typedb.protocol.Query\
    Manager.Delete.ReqH\0R\tdeleteReq\x12I\n\nupdate_req\x18l\x20\x01(\x0b2(\
    .typedb.protocol.QueryManager.Update.ReqH\0R\tupdateReq\x12L\n\x0bexplai\
    n_req\x18m\x20\x01(\x0b2).typedb.protocol.QueryManager.Explain.ReqH\0R\n\
    explainReqB\x05\n\x03req\x1a\xd7\x02\n\x03Res\x12I\n\ndefine_res\x18d\
    \x20\x01(\x0b2(.typedb.protocol.QueryManager.Define.ResH\0R\tdefineRes\
    \x12O\n\x0cundefine_res\x18e\x20\x01(\x0b2*.typedb.protocol.QueryManager\
    .Undefine.ResH\0R\x0bundefineRes\x12b\n\x13match_aggregate_res\x18f\x20\
    \x01(\x0b20.typedb.protocol.QueryManager.MatchAggregate.ResH\0R\x11match\
    AggregateRes\x12I\n\ndelete_res\x18h\x20\x01(\x0b2(.typedb.protocol.Quer\
    yManager.Delete.ResH\0R\tdeleteResB\x05\n\x03res\x1a\xd6\x04\n\x07ResPar\
    t\x12S\n\x0ematch_res_part\x18d\x20\x01(\x0b2+.typedb.protocol.QueryMana\
    ger.Match.ResPartH\0R\x0cmatchResPart\x12c\n\x14match_group_res_part\x18\
    e\x20\x01(\x0b20.typedb.protocol.QueryManager.MatchGroup.ResPartH\0R\x11\
    matchGroupResPart\x12\x7f\n\x1ematch_group_aggregate_res_part\x18f\x20\
    \x01(\x0b29.typedb.protocol.QueryManager.MatchGroupAggregate.ResPartH\0R\
    \x1amatchGroupAggregateResPart\x12V\n\x0finsert_res_part\x18g\x20\x01(\
    \x0b2,.typedb.protocol.QueryManager.Insert.ResPartH\0R\rinsertResPart\
    \x12V\n\x0fupdate_res_part\x18h\x20\x01(\x0b2,.typedb.protocol.QueryMana\
    ger.Update.ResPartH\0R\rupdateResPart\x12Y\n\x10explain_res_part\x18i\
    \x20\x01(\x0b2-.typedb.protocol.QueryManager.Explain.ResPartH\0R\x0eexpl\
    ainResPartB\x05\n\x03res\x1af\n\x05Match\x1a\x1b\n\x03Req\x12\x14\n\x05q\
    uery\x18\x01\x20\x01(\tR\x05query\x1a@\n\x07ResPart\x125\n\x07answers\
    \x18\x01\x20\x03(\x0b2\x1b.typedb.protocol.ConceptMapR\x07answers\x1af\n\
    \x0eMatchAggregate\x1a\x1b\n\x03Req\x12\x14\n\x05query\x18\x01\x20\x01(\
    \tR\x05query\x1a7\n\x03Res\x120\n\x06answer\x18\x01\x20\x01(\x0b2\x18.ty\
    pedb.protocol.NumericR\x06answer\x1ap\n\nMatchGroup\x1a\x1b\n\x03Req\x12\
    \x14\n\x05query\x18\x01\x20\x01(\tR\x05query\x1aE\n\x07ResPart\x12:\n\
    \x07answers\x18\x01\x20\x03(\x0b2\x20.typedb.protocol.ConceptMapGroupR\
    \x07answers\x1av\n\x13MatchGroupAggregate\x1a\x1b\n\x03Req\x12\x14\n\x05\
    query\x18\x01\x20\x01(\tR\x05query\x1aB\n\x07ResPart\x127\n\x07answers\
    \x18\x01\x20\x03(\x0b2\x1d.typedb.protocol.NumericGroupR\x07answers\x1a\
    \x84\x01\n\x07Explain\x1a,\n\x03Req\x12%\n\x0eexplainable_id\x18\x01\x20\
    \x01(\x03R\rexplainableId\x1aK\n\x07ResPart\x12@\n\x0cexplanations\x18\
    \x01\x20\x03(\x0b2\x1c.typedb.protocol.ExplanationR\x0cexplanations\x1ag\
    \n\x06Insert\x1a\x1b\n\x03Req\x12\x14\n\x05query\x18\x01\x20\x01(\tR\x05\
    query\x1a@\n\x07ResPart\x125\n\x07answers\x18\x01\x20\x03(\x0b2\x1b.type\
    db.protocol.ConceptMapR\x07answers\x1a,\n\x06Delete\x1a\x1b\n\x03Req\x12\
    \x14\n\x05query\x18\x01\x20\x01(\tR\x05query\x1a\x05\n\x03Res\x1ag\n\x06\
    Update\x1a\x1b\n\x03Req\x12\x14\n\x05query\x18\x01\x20\x01(\tR\x05query\
    \x1a@\n\x07ResPart\x125\n\x07answers\x18\x01\x20\x03(\x0b2\x1b.typedb.pr\
    otocol.ConceptMapR\x07answers\x1a,\n\x06Define\x1a\x1b\n\x03Req\x12\x14\
    \n\x05query\x18\x01\x20\x01(\tR\x05query\x1a\x05\n\x03Res\x1a.\n\x08Unde\
    fine\x1a\x1b\n\x03Req\x12\x14\n\x05query\x18\x01\x20\x01(\tR\x05query\
    \x1a\x05\n\x03ResB)\n\x1bcom.vaticle.typedb.protocolB\nQueryProtob\x06pr\
    oto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
