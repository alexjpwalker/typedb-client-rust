// This file is generated by rust-protobuf 2.18.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `common/transaction.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_2;

#[derive(PartialEq,Clone,Default)]
pub struct Transaction {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction {
    fn default() -> &'a Transaction {
        <Transaction as ::protobuf::Message>::default_instance()
    }
}

impl Transaction {
    pub fn new() -> Transaction {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Transaction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction {
        Transaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction>(
                "Transaction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction {
        static instance: ::protobuf::rt::LazyV2<Transaction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction::new)
    }
}

impl ::protobuf::Clear for Transaction {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction_Client {
    // message fields
    pub reqs: ::protobuf::RepeatedField<Transaction_Req>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction_Client {
    fn default() -> &'a Transaction_Client {
        <Transaction_Client as ::protobuf::Message>::default_instance()
    }
}

impl Transaction_Client {
    pub fn new() -> Transaction_Client {
        ::std::default::Default::default()
    }

    // repeated .typedb.protocol.Transaction.Req reqs = 1;


    pub fn get_reqs(&self) -> &[Transaction_Req] {
        &self.reqs
    }
    pub fn clear_reqs(&mut self) {
        self.reqs.clear();
    }

    // Param is passed by value, moved
    pub fn set_reqs(&mut self, v: ::protobuf::RepeatedField<Transaction_Req>) {
        self.reqs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reqs(&mut self) -> &mut ::protobuf::RepeatedField<Transaction_Req> {
        &mut self.reqs
    }

    // Take field
    pub fn take_reqs(&mut self) -> ::protobuf::RepeatedField<Transaction_Req> {
        ::std::mem::replace(&mut self.reqs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Transaction_Client {
    fn is_initialized(&self) -> bool {
        for v in &self.reqs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.reqs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.reqs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.reqs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction_Client {
        Transaction_Client::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transaction_Req>>(
                "reqs",
                |m: &Transaction_Client| { &m.reqs },
                |m: &mut Transaction_Client| { &mut m.reqs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction_Client>(
                "Transaction.Client",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction_Client {
        static instance: ::protobuf::rt::LazyV2<Transaction_Client> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction_Client::new)
    }
}

impl ::protobuf::Clear for Transaction_Client {
    fn clear(&mut self) {
        self.reqs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction_Client {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Client {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction_Server {
    // message oneof groups
    pub server: ::std::option::Option<Transaction_Server_oneof_server>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction_Server {
    fn default() -> &'a Transaction_Server {
        <Transaction_Server as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Transaction_Server_oneof_server {
    res(Transaction_Res),
    res_part(Transaction_ResPart),
}

impl Transaction_Server {
    pub fn new() -> Transaction_Server {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Transaction.Res res = 2;


    pub fn get_res(&self) -> &Transaction_Res {
        match self.server {
            ::std::option::Option::Some(Transaction_Server_oneof_server::res(ref v)) => v,
            _ => <Transaction_Res as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_res(&mut self) {
        self.server = ::std::option::Option::None;
    }

    pub fn has_res(&self) -> bool {
        match self.server {
            ::std::option::Option::Some(Transaction_Server_oneof_server::res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_res(&mut self, v: Transaction_Res) {
        self.server = ::std::option::Option::Some(Transaction_Server_oneof_server::res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_res(&mut self) -> &mut Transaction_Res {
        if let ::std::option::Option::Some(Transaction_Server_oneof_server::res(_)) = self.server {
        } else {
            self.server = ::std::option::Option::Some(Transaction_Server_oneof_server::res(Transaction_Res::new()));
        }
        match self.server {
            ::std::option::Option::Some(Transaction_Server_oneof_server::res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_res(&mut self) -> Transaction_Res {
        if self.has_res() {
            match self.server.take() {
                ::std::option::Option::Some(Transaction_Server_oneof_server::res(v)) => v,
                _ => panic!(),
            }
        } else {
            Transaction_Res::new()
        }
    }

    // .typedb.protocol.Transaction.ResPart res_part = 3;


    pub fn get_res_part(&self) -> &Transaction_ResPart {
        match self.server {
            ::std::option::Option::Some(Transaction_Server_oneof_server::res_part(ref v)) => v,
            _ => <Transaction_ResPart as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_res_part(&mut self) {
        self.server = ::std::option::Option::None;
    }

    pub fn has_res_part(&self) -> bool {
        match self.server {
            ::std::option::Option::Some(Transaction_Server_oneof_server::res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_res_part(&mut self, v: Transaction_ResPart) {
        self.server = ::std::option::Option::Some(Transaction_Server_oneof_server::res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_res_part(&mut self) -> &mut Transaction_ResPart {
        if let ::std::option::Option::Some(Transaction_Server_oneof_server::res_part(_)) = self.server {
        } else {
            self.server = ::std::option::Option::Some(Transaction_Server_oneof_server::res_part(Transaction_ResPart::new()));
        }
        match self.server {
            ::std::option::Option::Some(Transaction_Server_oneof_server::res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_res_part(&mut self) -> Transaction_ResPart {
        if self.has_res_part() {
            match self.server.take() {
                ::std::option::Option::Some(Transaction_Server_oneof_server::res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            Transaction_ResPart::new()
        }
    }
}

impl ::protobuf::Message for Transaction_Server {
    fn is_initialized(&self) -> bool {
        if let Some(Transaction_Server_oneof_server::res(ref v)) = self.server {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transaction_Server_oneof_server::res_part(ref v)) = self.server {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.server = ::std::option::Option::Some(Transaction_Server_oneof_server::res(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.server = ::std::option::Option::Some(Transaction_Server_oneof_server::res_part(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.server {
            match v {
                &Transaction_Server_oneof_server::res(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transaction_Server_oneof_server::res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.server {
            match v {
                &Transaction_Server_oneof_server::res(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transaction_Server_oneof_server::res_part(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction_Server {
        Transaction_Server::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Transaction_Res>(
                "res",
                Transaction_Server::has_res,
                Transaction_Server::get_res,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Transaction_ResPart>(
                "res_part",
                Transaction_Server::has_res_part,
                Transaction_Server::get_res_part,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction_Server>(
                "Transaction.Server",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction_Server {
        static instance: ::protobuf::rt::LazyV2<Transaction_Server> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction_Server::new)
    }
}

impl ::protobuf::Clear for Transaction_Server {
    fn clear(&mut self) {
        self.server = ::std::option::Option::None;
        self.server = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction_Server {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Server {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction_Req {
    // message fields
    pub req_id: ::std::vec::Vec<u8>,
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // message oneof groups
    pub req: ::std::option::Option<Transaction_Req_oneof_req>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction_Req {
    fn default() -> &'a Transaction_Req {
        <Transaction_Req as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Transaction_Req_oneof_req {
    open_req(Transaction_Open_Req),
    stream_req(Transaction_Stream_Req),
    commit_req(Transaction_Commit_Req),
    rollback_req(Transaction_Rollback_Req),
    query_manager_req(super::query::QueryManager_Req),
    concept_manager_req(super::concept::ConceptManager_Req),
    logic_manager_req(super::logic::LogicManager_Req),
    rule_req(super::logic::Rule_Req),
    type_req(super::concept::Type_Req),
    thing_req(super::concept::Thing_Req),
}

impl Transaction_Req {
    pub fn new() -> Transaction_Req {
        ::std::default::Default::default()
    }

    // bytes req_id = 1;


    pub fn get_req_id(&self) -> &[u8] {
        &self.req_id
    }
    pub fn clear_req_id(&mut self) {
        self.req_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_req_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.req_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_req_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.req_id
    }

    // Take field
    pub fn take_req_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.req_id, ::std::vec::Vec::new())
    }

    // repeated .typedb.protocol.Transaction.Req.MetadataEntry metadata = 2;


    pub fn get_metadata(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.metadata, ::std::collections::HashMap::new())
    }

    // .typedb.protocol.Transaction.Open.Req open_req = 3;


    pub fn get_open_req(&self) -> &Transaction_Open_Req {
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::open_req(ref v)) => v,
            _ => <Transaction_Open_Req as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_open_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_open_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::open_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_open_req(&mut self, v: Transaction_Open_Req) {
        self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::open_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_open_req(&mut self) -> &mut Transaction_Open_Req {
        if let ::std::option::Option::Some(Transaction_Req_oneof_req::open_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::open_req(Transaction_Open_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::open_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_open_req(&mut self) -> Transaction_Open_Req {
        if self.has_open_req() {
            match self.req.take() {
                ::std::option::Option::Some(Transaction_Req_oneof_req::open_req(v)) => v,
                _ => panic!(),
            }
        } else {
            Transaction_Open_Req::new()
        }
    }

    // .typedb.protocol.Transaction.Stream.Req stream_req = 4;


    pub fn get_stream_req(&self) -> &Transaction_Stream_Req {
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::stream_req(ref v)) => v,
            _ => <Transaction_Stream_Req as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_stream_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_stream_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::stream_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stream_req(&mut self, v: Transaction_Stream_Req) {
        self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::stream_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stream_req(&mut self) -> &mut Transaction_Stream_Req {
        if let ::std::option::Option::Some(Transaction_Req_oneof_req::stream_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::stream_req(Transaction_Stream_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::stream_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stream_req(&mut self) -> Transaction_Stream_Req {
        if self.has_stream_req() {
            match self.req.take() {
                ::std::option::Option::Some(Transaction_Req_oneof_req::stream_req(v)) => v,
                _ => panic!(),
            }
        } else {
            Transaction_Stream_Req::new()
        }
    }

    // .typedb.protocol.Transaction.Commit.Req commit_req = 5;


    pub fn get_commit_req(&self) -> &Transaction_Commit_Req {
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::commit_req(ref v)) => v,
            _ => <Transaction_Commit_Req as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_commit_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_commit_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::commit_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_commit_req(&mut self, v: Transaction_Commit_Req) {
        self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::commit_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_commit_req(&mut self) -> &mut Transaction_Commit_Req {
        if let ::std::option::Option::Some(Transaction_Req_oneof_req::commit_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::commit_req(Transaction_Commit_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::commit_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_commit_req(&mut self) -> Transaction_Commit_Req {
        if self.has_commit_req() {
            match self.req.take() {
                ::std::option::Option::Some(Transaction_Req_oneof_req::commit_req(v)) => v,
                _ => panic!(),
            }
        } else {
            Transaction_Commit_Req::new()
        }
    }

    // .typedb.protocol.Transaction.Rollback.Req rollback_req = 6;


    pub fn get_rollback_req(&self) -> &Transaction_Rollback_Req {
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::rollback_req(ref v)) => v,
            _ => <Transaction_Rollback_Req as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_rollback_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_rollback_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::rollback_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rollback_req(&mut self, v: Transaction_Rollback_Req) {
        self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::rollback_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rollback_req(&mut self) -> &mut Transaction_Rollback_Req {
        if let ::std::option::Option::Some(Transaction_Req_oneof_req::rollback_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::rollback_req(Transaction_Rollback_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::rollback_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rollback_req(&mut self) -> Transaction_Rollback_Req {
        if self.has_rollback_req() {
            match self.req.take() {
                ::std::option::Option::Some(Transaction_Req_oneof_req::rollback_req(v)) => v,
                _ => panic!(),
            }
        } else {
            Transaction_Rollback_Req::new()
        }
    }

    // .typedb.protocol.QueryManager.Req query_manager_req = 7;


    pub fn get_query_manager_req(&self) -> &super::query::QueryManager_Req {
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::query_manager_req(ref v)) => v,
            _ => <super::query::QueryManager_Req as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_query_manager_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_query_manager_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::query_manager_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_query_manager_req(&mut self, v: super::query::QueryManager_Req) {
        self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::query_manager_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_query_manager_req(&mut self) -> &mut super::query::QueryManager_Req {
        if let ::std::option::Option::Some(Transaction_Req_oneof_req::query_manager_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::query_manager_req(super::query::QueryManager_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::query_manager_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_query_manager_req(&mut self) -> super::query::QueryManager_Req {
        if self.has_query_manager_req() {
            match self.req.take() {
                ::std::option::Option::Some(Transaction_Req_oneof_req::query_manager_req(v)) => v,
                _ => panic!(),
            }
        } else {
            super::query::QueryManager_Req::new()
        }
    }

    // .typedb.protocol.ConceptManager.Req concept_manager_req = 8;


    pub fn get_concept_manager_req(&self) -> &super::concept::ConceptManager_Req {
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::concept_manager_req(ref v)) => v,
            _ => <super::concept::ConceptManager_Req as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_concept_manager_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_concept_manager_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::concept_manager_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_concept_manager_req(&mut self, v: super::concept::ConceptManager_Req) {
        self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::concept_manager_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_concept_manager_req(&mut self) -> &mut super::concept::ConceptManager_Req {
        if let ::std::option::Option::Some(Transaction_Req_oneof_req::concept_manager_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::concept_manager_req(super::concept::ConceptManager_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::concept_manager_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_concept_manager_req(&mut self) -> super::concept::ConceptManager_Req {
        if self.has_concept_manager_req() {
            match self.req.take() {
                ::std::option::Option::Some(Transaction_Req_oneof_req::concept_manager_req(v)) => v,
                _ => panic!(),
            }
        } else {
            super::concept::ConceptManager_Req::new()
        }
    }

    // .typedb.protocol.LogicManager.Req logic_manager_req = 9;


    pub fn get_logic_manager_req(&self) -> &super::logic::LogicManager_Req {
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::logic_manager_req(ref v)) => v,
            _ => <super::logic::LogicManager_Req as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_logic_manager_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_logic_manager_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::logic_manager_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_logic_manager_req(&mut self, v: super::logic::LogicManager_Req) {
        self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::logic_manager_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_logic_manager_req(&mut self) -> &mut super::logic::LogicManager_Req {
        if let ::std::option::Option::Some(Transaction_Req_oneof_req::logic_manager_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::logic_manager_req(super::logic::LogicManager_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::logic_manager_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_logic_manager_req(&mut self) -> super::logic::LogicManager_Req {
        if self.has_logic_manager_req() {
            match self.req.take() {
                ::std::option::Option::Some(Transaction_Req_oneof_req::logic_manager_req(v)) => v,
                _ => panic!(),
            }
        } else {
            super::logic::LogicManager_Req::new()
        }
    }

    // .typedb.protocol.Rule.Req rule_req = 10;


    pub fn get_rule_req(&self) -> &super::logic::Rule_Req {
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::rule_req(ref v)) => v,
            _ => <super::logic::Rule_Req as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_rule_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_rule_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::rule_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rule_req(&mut self, v: super::logic::Rule_Req) {
        self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::rule_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rule_req(&mut self) -> &mut super::logic::Rule_Req {
        if let ::std::option::Option::Some(Transaction_Req_oneof_req::rule_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::rule_req(super::logic::Rule_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::rule_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rule_req(&mut self) -> super::logic::Rule_Req {
        if self.has_rule_req() {
            match self.req.take() {
                ::std::option::Option::Some(Transaction_Req_oneof_req::rule_req(v)) => v,
                _ => panic!(),
            }
        } else {
            super::logic::Rule_Req::new()
        }
    }

    // .typedb.protocol.Type.Req type_req = 11;


    pub fn get_type_req(&self) -> &super::concept::Type_Req {
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::type_req(ref v)) => v,
            _ => <super::concept::Type_Req as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_type_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_type_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::type_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_type_req(&mut self, v: super::concept::Type_Req) {
        self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::type_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_type_req(&mut self) -> &mut super::concept::Type_Req {
        if let ::std::option::Option::Some(Transaction_Req_oneof_req::type_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::type_req(super::concept::Type_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::type_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_type_req(&mut self) -> super::concept::Type_Req {
        if self.has_type_req() {
            match self.req.take() {
                ::std::option::Option::Some(Transaction_Req_oneof_req::type_req(v)) => v,
                _ => panic!(),
            }
        } else {
            super::concept::Type_Req::new()
        }
    }

    // .typedb.protocol.Thing.Req thing_req = 12;


    pub fn get_thing_req(&self) -> &super::concept::Thing_Req {
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::thing_req(ref v)) => v,
            _ => <super::concept::Thing_Req as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_thing_req(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_thing_req(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::thing_req(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_req(&mut self, v: super::concept::Thing_Req) {
        self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::thing_req(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_req(&mut self) -> &mut super::concept::Thing_Req {
        if let ::std::option::Option::Some(Transaction_Req_oneof_req::thing_req(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::thing_req(super::concept::Thing_Req::new()));
        }
        match self.req {
            ::std::option::Option::Some(Transaction_Req_oneof_req::thing_req(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_req(&mut self) -> super::concept::Thing_Req {
        if self.has_thing_req() {
            match self.req.take() {
                ::std::option::Option::Some(Transaction_Req_oneof_req::thing_req(v)) => v,
                _ => panic!(),
            }
        } else {
            super::concept::Thing_Req::new()
        }
    }
}

impl ::protobuf::Message for Transaction_Req {
    fn is_initialized(&self) -> bool {
        if let Some(Transaction_Req_oneof_req::open_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transaction_Req_oneof_req::stream_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transaction_Req_oneof_req::commit_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transaction_Req_oneof_req::rollback_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transaction_Req_oneof_req::query_manager_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transaction_Req_oneof_req::concept_manager_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transaction_Req_oneof_req::logic_manager_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transaction_Req_oneof_req::rule_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transaction_Req_oneof_req::type_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transaction_Req_oneof_req::thing_req(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.req_id)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.metadata)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::open_req(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::stream_req(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::commit_req(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::rollback_req(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::query_manager_req(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::concept_manager_req(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::logic_manager_req(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::rule_req(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::type_req(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(Transaction_Req_oneof_req::thing_req(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.req_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.req_id);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.metadata);
        if let ::std::option::Option::Some(ref v) = self.req {
            match v {
                &Transaction_Req_oneof_req::open_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transaction_Req_oneof_req::stream_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transaction_Req_oneof_req::commit_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transaction_Req_oneof_req::rollback_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transaction_Req_oneof_req::query_manager_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transaction_Req_oneof_req::concept_manager_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transaction_Req_oneof_req::logic_manager_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transaction_Req_oneof_req::rule_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transaction_Req_oneof_req::type_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transaction_Req_oneof_req::thing_req(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.req_id.is_empty() {
            os.write_bytes(1, &self.req_id)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.metadata, os)?;
        if let ::std::option::Option::Some(ref v) = self.req {
            match v {
                &Transaction_Req_oneof_req::open_req(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transaction_Req_oneof_req::stream_req(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transaction_Req_oneof_req::commit_req(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transaction_Req_oneof_req::rollback_req(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transaction_Req_oneof_req::query_manager_req(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transaction_Req_oneof_req::concept_manager_req(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transaction_Req_oneof_req::logic_manager_req(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transaction_Req_oneof_req::rule_req(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transaction_Req_oneof_req::type_req(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transaction_Req_oneof_req::thing_req(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction_Req {
        Transaction_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "req_id",
                |m: &Transaction_Req| { &m.req_id },
                |m: &mut Transaction_Req| { &mut m.req_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "metadata",
                |m: &Transaction_Req| { &m.metadata },
                |m: &mut Transaction_Req| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Transaction_Open_Req>(
                "open_req",
                Transaction_Req::has_open_req,
                Transaction_Req::get_open_req,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Transaction_Stream_Req>(
                "stream_req",
                Transaction_Req::has_stream_req,
                Transaction_Req::get_stream_req,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Transaction_Commit_Req>(
                "commit_req",
                Transaction_Req::has_commit_req,
                Transaction_Req::get_commit_req,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Transaction_Rollback_Req>(
                "rollback_req",
                Transaction_Req::has_rollback_req,
                Transaction_Req::get_rollback_req,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::query::QueryManager_Req>(
                "query_manager_req",
                Transaction_Req::has_query_manager_req,
                Transaction_Req::get_query_manager_req,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::concept::ConceptManager_Req>(
                "concept_manager_req",
                Transaction_Req::has_concept_manager_req,
                Transaction_Req::get_concept_manager_req,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::logic::LogicManager_Req>(
                "logic_manager_req",
                Transaction_Req::has_logic_manager_req,
                Transaction_Req::get_logic_manager_req,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::logic::Rule_Req>(
                "rule_req",
                Transaction_Req::has_rule_req,
                Transaction_Req::get_rule_req,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::concept::Type_Req>(
                "type_req",
                Transaction_Req::has_type_req,
                Transaction_Req::get_type_req,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::concept::Thing_Req>(
                "thing_req",
                Transaction_Req::has_thing_req,
                Transaction_Req::get_thing_req,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction_Req>(
                "Transaction.Req",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction_Req {
        static instance: ::protobuf::rt::LazyV2<Transaction_Req> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction_Req::new)
    }
}

impl ::protobuf::Clear for Transaction_Req {
    fn clear(&mut self) {
        self.req_id.clear();
        self.metadata.clear();
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction_Res {
    // message fields
    pub req_id: ::std::vec::Vec<u8>,
    // message oneof groups
    pub res: ::std::option::Option<Transaction_Res_oneof_res>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction_Res {
    fn default() -> &'a Transaction_Res {
        <Transaction_Res as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Transaction_Res_oneof_res {
    open_res(Transaction_Open_Res),
    commit_res(Transaction_Commit_Res),
    rollback_res(Transaction_Rollback_Res),
    query_manager_res(super::query::QueryManager_Res),
    concept_manager_res(super::concept::ConceptManager_Res),
    logic_manager_res(super::logic::LogicManager_Res),
    rule_res(super::logic::Rule_Res),
    type_res(super::concept::Type_Res),
    thing_res(super::concept::Thing_Res),
}

impl Transaction_Res {
    pub fn new() -> Transaction_Res {
        ::std::default::Default::default()
    }

    // bytes req_id = 1;


    pub fn get_req_id(&self) -> &[u8] {
        &self.req_id
    }
    pub fn clear_req_id(&mut self) {
        self.req_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_req_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.req_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_req_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.req_id
    }

    // Take field
    pub fn take_req_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.req_id, ::std::vec::Vec::new())
    }

    // .typedb.protocol.Transaction.Open.Res open_res = 2;


    pub fn get_open_res(&self) -> &Transaction_Open_Res {
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::open_res(ref v)) => v,
            _ => <Transaction_Open_Res as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_open_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_open_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::open_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_open_res(&mut self, v: Transaction_Open_Res) {
        self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::open_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_open_res(&mut self) -> &mut Transaction_Open_Res {
        if let ::std::option::Option::Some(Transaction_Res_oneof_res::open_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::open_res(Transaction_Open_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::open_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_open_res(&mut self) -> Transaction_Open_Res {
        if self.has_open_res() {
            match self.res.take() {
                ::std::option::Option::Some(Transaction_Res_oneof_res::open_res(v)) => v,
                _ => panic!(),
            }
        } else {
            Transaction_Open_Res::new()
        }
    }

    // .typedb.protocol.Transaction.Commit.Res commit_res = 3;


    pub fn get_commit_res(&self) -> &Transaction_Commit_Res {
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::commit_res(ref v)) => v,
            _ => <Transaction_Commit_Res as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_commit_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_commit_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::commit_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_commit_res(&mut self, v: Transaction_Commit_Res) {
        self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::commit_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_commit_res(&mut self) -> &mut Transaction_Commit_Res {
        if let ::std::option::Option::Some(Transaction_Res_oneof_res::commit_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::commit_res(Transaction_Commit_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::commit_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_commit_res(&mut self) -> Transaction_Commit_Res {
        if self.has_commit_res() {
            match self.res.take() {
                ::std::option::Option::Some(Transaction_Res_oneof_res::commit_res(v)) => v,
                _ => panic!(),
            }
        } else {
            Transaction_Commit_Res::new()
        }
    }

    // .typedb.protocol.Transaction.Rollback.Res rollback_res = 4;


    pub fn get_rollback_res(&self) -> &Transaction_Rollback_Res {
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::rollback_res(ref v)) => v,
            _ => <Transaction_Rollback_Res as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_rollback_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_rollback_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::rollback_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rollback_res(&mut self, v: Transaction_Rollback_Res) {
        self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::rollback_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rollback_res(&mut self) -> &mut Transaction_Rollback_Res {
        if let ::std::option::Option::Some(Transaction_Res_oneof_res::rollback_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::rollback_res(Transaction_Rollback_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::rollback_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rollback_res(&mut self) -> Transaction_Rollback_Res {
        if self.has_rollback_res() {
            match self.res.take() {
                ::std::option::Option::Some(Transaction_Res_oneof_res::rollback_res(v)) => v,
                _ => panic!(),
            }
        } else {
            Transaction_Rollback_Res::new()
        }
    }

    // .typedb.protocol.QueryManager.Res query_manager_res = 5;


    pub fn get_query_manager_res(&self) -> &super::query::QueryManager_Res {
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::query_manager_res(ref v)) => v,
            _ => <super::query::QueryManager_Res as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_query_manager_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_query_manager_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::query_manager_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_query_manager_res(&mut self, v: super::query::QueryManager_Res) {
        self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::query_manager_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_query_manager_res(&mut self) -> &mut super::query::QueryManager_Res {
        if let ::std::option::Option::Some(Transaction_Res_oneof_res::query_manager_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::query_manager_res(super::query::QueryManager_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::query_manager_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_query_manager_res(&mut self) -> super::query::QueryManager_Res {
        if self.has_query_manager_res() {
            match self.res.take() {
                ::std::option::Option::Some(Transaction_Res_oneof_res::query_manager_res(v)) => v,
                _ => panic!(),
            }
        } else {
            super::query::QueryManager_Res::new()
        }
    }

    // .typedb.protocol.ConceptManager.Res concept_manager_res = 6;


    pub fn get_concept_manager_res(&self) -> &super::concept::ConceptManager_Res {
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::concept_manager_res(ref v)) => v,
            _ => <super::concept::ConceptManager_Res as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_concept_manager_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_concept_manager_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::concept_manager_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_concept_manager_res(&mut self, v: super::concept::ConceptManager_Res) {
        self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::concept_manager_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_concept_manager_res(&mut self) -> &mut super::concept::ConceptManager_Res {
        if let ::std::option::Option::Some(Transaction_Res_oneof_res::concept_manager_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::concept_manager_res(super::concept::ConceptManager_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::concept_manager_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_concept_manager_res(&mut self) -> super::concept::ConceptManager_Res {
        if self.has_concept_manager_res() {
            match self.res.take() {
                ::std::option::Option::Some(Transaction_Res_oneof_res::concept_manager_res(v)) => v,
                _ => panic!(),
            }
        } else {
            super::concept::ConceptManager_Res::new()
        }
    }

    // .typedb.protocol.LogicManager.Res logic_manager_res = 7;


    pub fn get_logic_manager_res(&self) -> &super::logic::LogicManager_Res {
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::logic_manager_res(ref v)) => v,
            _ => <super::logic::LogicManager_Res as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_logic_manager_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_logic_manager_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::logic_manager_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_logic_manager_res(&mut self, v: super::logic::LogicManager_Res) {
        self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::logic_manager_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_logic_manager_res(&mut self) -> &mut super::logic::LogicManager_Res {
        if let ::std::option::Option::Some(Transaction_Res_oneof_res::logic_manager_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::logic_manager_res(super::logic::LogicManager_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::logic_manager_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_logic_manager_res(&mut self) -> super::logic::LogicManager_Res {
        if self.has_logic_manager_res() {
            match self.res.take() {
                ::std::option::Option::Some(Transaction_Res_oneof_res::logic_manager_res(v)) => v,
                _ => panic!(),
            }
        } else {
            super::logic::LogicManager_Res::new()
        }
    }

    // .typedb.protocol.Rule.Res rule_res = 8;


    pub fn get_rule_res(&self) -> &super::logic::Rule_Res {
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::rule_res(ref v)) => v,
            _ => <super::logic::Rule_Res as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_rule_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_rule_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::rule_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rule_res(&mut self, v: super::logic::Rule_Res) {
        self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::rule_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rule_res(&mut self) -> &mut super::logic::Rule_Res {
        if let ::std::option::Option::Some(Transaction_Res_oneof_res::rule_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::rule_res(super::logic::Rule_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::rule_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rule_res(&mut self) -> super::logic::Rule_Res {
        if self.has_rule_res() {
            match self.res.take() {
                ::std::option::Option::Some(Transaction_Res_oneof_res::rule_res(v)) => v,
                _ => panic!(),
            }
        } else {
            super::logic::Rule_Res::new()
        }
    }

    // .typedb.protocol.Type.Res type_res = 9;


    pub fn get_type_res(&self) -> &super::concept::Type_Res {
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::type_res(ref v)) => v,
            _ => <super::concept::Type_Res as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_type_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_type_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::type_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_type_res(&mut self, v: super::concept::Type_Res) {
        self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::type_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_type_res(&mut self) -> &mut super::concept::Type_Res {
        if let ::std::option::Option::Some(Transaction_Res_oneof_res::type_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::type_res(super::concept::Type_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::type_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_type_res(&mut self) -> super::concept::Type_Res {
        if self.has_type_res() {
            match self.res.take() {
                ::std::option::Option::Some(Transaction_Res_oneof_res::type_res(v)) => v,
                _ => panic!(),
            }
        } else {
            super::concept::Type_Res::new()
        }
    }

    // .typedb.protocol.Thing.Res thing_res = 10;


    pub fn get_thing_res(&self) -> &super::concept::Thing_Res {
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::thing_res(ref v)) => v,
            _ => <super::concept::Thing_Res as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_thing_res(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_thing_res(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::thing_res(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_res(&mut self, v: super::concept::Thing_Res) {
        self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::thing_res(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_res(&mut self) -> &mut super::concept::Thing_Res {
        if let ::std::option::Option::Some(Transaction_Res_oneof_res::thing_res(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::thing_res(super::concept::Thing_Res::new()));
        }
        match self.res {
            ::std::option::Option::Some(Transaction_Res_oneof_res::thing_res(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_res(&mut self) -> super::concept::Thing_Res {
        if self.has_thing_res() {
            match self.res.take() {
                ::std::option::Option::Some(Transaction_Res_oneof_res::thing_res(v)) => v,
                _ => panic!(),
            }
        } else {
            super::concept::Thing_Res::new()
        }
    }
}

impl ::protobuf::Message for Transaction_Res {
    fn is_initialized(&self) -> bool {
        if let Some(Transaction_Res_oneof_res::open_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transaction_Res_oneof_res::commit_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transaction_Res_oneof_res::rollback_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transaction_Res_oneof_res::query_manager_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transaction_Res_oneof_res::concept_manager_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transaction_Res_oneof_res::logic_manager_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transaction_Res_oneof_res::rule_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transaction_Res_oneof_res::type_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transaction_Res_oneof_res::thing_res(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.req_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::open_res(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::commit_res(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::rollback_res(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::query_manager_res(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::concept_manager_res(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::logic_manager_res(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::rule_res(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::type_res(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Transaction_Res_oneof_res::thing_res(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.req_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.req_id);
        }
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &Transaction_Res_oneof_res::open_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transaction_Res_oneof_res::commit_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transaction_Res_oneof_res::rollback_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transaction_Res_oneof_res::query_manager_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transaction_Res_oneof_res::concept_manager_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transaction_Res_oneof_res::logic_manager_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transaction_Res_oneof_res::rule_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transaction_Res_oneof_res::type_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transaction_Res_oneof_res::thing_res(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.req_id.is_empty() {
            os.write_bytes(1, &self.req_id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &Transaction_Res_oneof_res::open_res(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transaction_Res_oneof_res::commit_res(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transaction_Res_oneof_res::rollback_res(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transaction_Res_oneof_res::query_manager_res(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transaction_Res_oneof_res::concept_manager_res(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transaction_Res_oneof_res::logic_manager_res(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transaction_Res_oneof_res::rule_res(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transaction_Res_oneof_res::type_res(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transaction_Res_oneof_res::thing_res(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction_Res {
        Transaction_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "req_id",
                |m: &Transaction_Res| { &m.req_id },
                |m: &mut Transaction_Res| { &mut m.req_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Transaction_Open_Res>(
                "open_res",
                Transaction_Res::has_open_res,
                Transaction_Res::get_open_res,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Transaction_Commit_Res>(
                "commit_res",
                Transaction_Res::has_commit_res,
                Transaction_Res::get_commit_res,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Transaction_Rollback_Res>(
                "rollback_res",
                Transaction_Res::has_rollback_res,
                Transaction_Res::get_rollback_res,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::query::QueryManager_Res>(
                "query_manager_res",
                Transaction_Res::has_query_manager_res,
                Transaction_Res::get_query_manager_res,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::concept::ConceptManager_Res>(
                "concept_manager_res",
                Transaction_Res::has_concept_manager_res,
                Transaction_Res::get_concept_manager_res,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::logic::LogicManager_Res>(
                "logic_manager_res",
                Transaction_Res::has_logic_manager_res,
                Transaction_Res::get_logic_manager_res,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::logic::Rule_Res>(
                "rule_res",
                Transaction_Res::has_rule_res,
                Transaction_Res::get_rule_res,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::concept::Type_Res>(
                "type_res",
                Transaction_Res::has_type_res,
                Transaction_Res::get_type_res,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::concept::Thing_Res>(
                "thing_res",
                Transaction_Res::has_thing_res,
                Transaction_Res::get_thing_res,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction_Res>(
                "Transaction.Res",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction_Res {
        static instance: ::protobuf::rt::LazyV2<Transaction_Res> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction_Res::new)
    }
}

impl ::protobuf::Clear for Transaction_Res {
    fn clear(&mut self) {
        self.req_id.clear();
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction_ResPart {
    // message fields
    pub req_id: ::std::vec::Vec<u8>,
    // message oneof groups
    pub res: ::std::option::Option<Transaction_ResPart_oneof_res>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction_ResPart {
    fn default() -> &'a Transaction_ResPart {
        <Transaction_ResPart as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Transaction_ResPart_oneof_res {
    stream_res_part(Transaction_Stream_ResPart),
    query_manager_res_part(super::query::QueryManager_ResPart),
    logic_manager_res_part(super::logic::LogicManager_ResPart),
    type_res_part(super::concept::Type_ResPart),
    thing_res_part(super::concept::Thing_ResPart),
}

impl Transaction_ResPart {
    pub fn new() -> Transaction_ResPart {
        ::std::default::Default::default()
    }

    // bytes req_id = 1;


    pub fn get_req_id(&self) -> &[u8] {
        &self.req_id
    }
    pub fn clear_req_id(&mut self) {
        self.req_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_req_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.req_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_req_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.req_id
    }

    // Take field
    pub fn take_req_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.req_id, ::std::vec::Vec::new())
    }

    // .typedb.protocol.Transaction.Stream.ResPart stream_res_part = 2;


    pub fn get_stream_res_part(&self) -> &Transaction_Stream_ResPart {
        match self.res {
            ::std::option::Option::Some(Transaction_ResPart_oneof_res::stream_res_part(ref v)) => v,
            _ => <Transaction_Stream_ResPart as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_stream_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_stream_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Transaction_ResPart_oneof_res::stream_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stream_res_part(&mut self, v: Transaction_Stream_ResPart) {
        self.res = ::std::option::Option::Some(Transaction_ResPart_oneof_res::stream_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stream_res_part(&mut self) -> &mut Transaction_Stream_ResPart {
        if let ::std::option::Option::Some(Transaction_ResPart_oneof_res::stream_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Transaction_ResPart_oneof_res::stream_res_part(Transaction_Stream_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(Transaction_ResPart_oneof_res::stream_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stream_res_part(&mut self) -> Transaction_Stream_ResPart {
        if self.has_stream_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(Transaction_ResPart_oneof_res::stream_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            Transaction_Stream_ResPart::new()
        }
    }

    // .typedb.protocol.QueryManager.ResPart query_manager_res_part = 3;


    pub fn get_query_manager_res_part(&self) -> &super::query::QueryManager_ResPart {
        match self.res {
            ::std::option::Option::Some(Transaction_ResPart_oneof_res::query_manager_res_part(ref v)) => v,
            _ => <super::query::QueryManager_ResPart as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_query_manager_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_query_manager_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Transaction_ResPart_oneof_res::query_manager_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_query_manager_res_part(&mut self, v: super::query::QueryManager_ResPart) {
        self.res = ::std::option::Option::Some(Transaction_ResPart_oneof_res::query_manager_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_query_manager_res_part(&mut self) -> &mut super::query::QueryManager_ResPart {
        if let ::std::option::Option::Some(Transaction_ResPart_oneof_res::query_manager_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Transaction_ResPart_oneof_res::query_manager_res_part(super::query::QueryManager_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(Transaction_ResPart_oneof_res::query_manager_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_query_manager_res_part(&mut self) -> super::query::QueryManager_ResPart {
        if self.has_query_manager_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(Transaction_ResPart_oneof_res::query_manager_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            super::query::QueryManager_ResPart::new()
        }
    }

    // .typedb.protocol.LogicManager.ResPart logic_manager_res_part = 4;


    pub fn get_logic_manager_res_part(&self) -> &super::logic::LogicManager_ResPart {
        match self.res {
            ::std::option::Option::Some(Transaction_ResPart_oneof_res::logic_manager_res_part(ref v)) => v,
            _ => <super::logic::LogicManager_ResPart as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_logic_manager_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_logic_manager_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Transaction_ResPart_oneof_res::logic_manager_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_logic_manager_res_part(&mut self, v: super::logic::LogicManager_ResPart) {
        self.res = ::std::option::Option::Some(Transaction_ResPart_oneof_res::logic_manager_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_logic_manager_res_part(&mut self) -> &mut super::logic::LogicManager_ResPart {
        if let ::std::option::Option::Some(Transaction_ResPart_oneof_res::logic_manager_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Transaction_ResPart_oneof_res::logic_manager_res_part(super::logic::LogicManager_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(Transaction_ResPart_oneof_res::logic_manager_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_logic_manager_res_part(&mut self) -> super::logic::LogicManager_ResPart {
        if self.has_logic_manager_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(Transaction_ResPart_oneof_res::logic_manager_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            super::logic::LogicManager_ResPart::new()
        }
    }

    // .typedb.protocol.Type.ResPart type_res_part = 5;


    pub fn get_type_res_part(&self) -> &super::concept::Type_ResPart {
        match self.res {
            ::std::option::Option::Some(Transaction_ResPart_oneof_res::type_res_part(ref v)) => v,
            _ => <super::concept::Type_ResPart as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_type_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_type_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Transaction_ResPart_oneof_res::type_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_type_res_part(&mut self, v: super::concept::Type_ResPart) {
        self.res = ::std::option::Option::Some(Transaction_ResPart_oneof_res::type_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_type_res_part(&mut self) -> &mut super::concept::Type_ResPart {
        if let ::std::option::Option::Some(Transaction_ResPart_oneof_res::type_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Transaction_ResPart_oneof_res::type_res_part(super::concept::Type_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(Transaction_ResPart_oneof_res::type_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_type_res_part(&mut self) -> super::concept::Type_ResPart {
        if self.has_type_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(Transaction_ResPart_oneof_res::type_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            super::concept::Type_ResPart::new()
        }
    }

    // .typedb.protocol.Thing.ResPart thing_res_part = 6;


    pub fn get_thing_res_part(&self) -> &super::concept::Thing_ResPart {
        match self.res {
            ::std::option::Option::Some(Transaction_ResPart_oneof_res::thing_res_part(ref v)) => v,
            _ => <super::concept::Thing_ResPart as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_thing_res_part(&mut self) {
        self.res = ::std::option::Option::None;
    }

    pub fn has_thing_res_part(&self) -> bool {
        match self.res {
            ::std::option::Option::Some(Transaction_ResPart_oneof_res::thing_res_part(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thing_res_part(&mut self, v: super::concept::Thing_ResPart) {
        self.res = ::std::option::Option::Some(Transaction_ResPart_oneof_res::thing_res_part(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thing_res_part(&mut self) -> &mut super::concept::Thing_ResPart {
        if let ::std::option::Option::Some(Transaction_ResPart_oneof_res::thing_res_part(_)) = self.res {
        } else {
            self.res = ::std::option::Option::Some(Transaction_ResPart_oneof_res::thing_res_part(super::concept::Thing_ResPart::new()));
        }
        match self.res {
            ::std::option::Option::Some(Transaction_ResPart_oneof_res::thing_res_part(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thing_res_part(&mut self) -> super::concept::Thing_ResPart {
        if self.has_thing_res_part() {
            match self.res.take() {
                ::std::option::Option::Some(Transaction_ResPart_oneof_res::thing_res_part(v)) => v,
                _ => panic!(),
            }
        } else {
            super::concept::Thing_ResPart::new()
        }
    }
}

impl ::protobuf::Message for Transaction_ResPart {
    fn is_initialized(&self) -> bool {
        if let Some(Transaction_ResPart_oneof_res::stream_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transaction_ResPart_oneof_res::query_manager_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transaction_ResPart_oneof_res::logic_manager_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transaction_ResPart_oneof_res::type_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Transaction_ResPart_oneof_res::thing_res_part(ref v)) = self.res {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.req_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Transaction_ResPart_oneof_res::stream_res_part(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Transaction_ResPart_oneof_res::query_manager_res_part(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Transaction_ResPart_oneof_res::logic_manager_res_part(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Transaction_ResPart_oneof_res::type_res_part(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.res = ::std::option::Option::Some(Transaction_ResPart_oneof_res::thing_res_part(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.req_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.req_id);
        }
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &Transaction_ResPart_oneof_res::stream_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transaction_ResPart_oneof_res::query_manager_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transaction_ResPart_oneof_res::logic_manager_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transaction_ResPart_oneof_res::type_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Transaction_ResPart_oneof_res::thing_res_part(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.req_id.is_empty() {
            os.write_bytes(1, &self.req_id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.res {
            match v {
                &Transaction_ResPart_oneof_res::stream_res_part(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transaction_ResPart_oneof_res::query_manager_res_part(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transaction_ResPart_oneof_res::logic_manager_res_part(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transaction_ResPart_oneof_res::type_res_part(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Transaction_ResPart_oneof_res::thing_res_part(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction_ResPart {
        Transaction_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "req_id",
                |m: &Transaction_ResPart| { &m.req_id },
                |m: &mut Transaction_ResPart| { &mut m.req_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Transaction_Stream_ResPart>(
                "stream_res_part",
                Transaction_ResPart::has_stream_res_part,
                Transaction_ResPart::get_stream_res_part,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::query::QueryManager_ResPart>(
                "query_manager_res_part",
                Transaction_ResPart::has_query_manager_res_part,
                Transaction_ResPart::get_query_manager_res_part,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::logic::LogicManager_ResPart>(
                "logic_manager_res_part",
                Transaction_ResPart::has_logic_manager_res_part,
                Transaction_ResPart::get_logic_manager_res_part,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::concept::Type_ResPart>(
                "type_res_part",
                Transaction_ResPart::has_type_res_part,
                Transaction_ResPart::get_type_res_part,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::concept::Thing_ResPart>(
                "thing_res_part",
                Transaction_ResPart::has_thing_res_part,
                Transaction_ResPart::get_thing_res_part,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction_ResPart>(
                "Transaction.ResPart",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction_ResPart {
        static instance: ::protobuf::rt::LazyV2<Transaction_ResPart> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction_ResPart::new)
    }
}

impl ::protobuf::Clear for Transaction_ResPart {
    fn clear(&mut self) {
        self.req_id.clear();
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.res = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction_Open {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction_Open {
    fn default() -> &'a Transaction_Open {
        <Transaction_Open as ::protobuf::Message>::default_instance()
    }
}

impl Transaction_Open {
    pub fn new() -> Transaction_Open {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Transaction_Open {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction_Open {
        Transaction_Open::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction_Open>(
                "Transaction.Open",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction_Open {
        static instance: ::protobuf::rt::LazyV2<Transaction_Open> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction_Open::new)
    }
}

impl ::protobuf::Clear for Transaction_Open {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction_Open {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Open {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction_Open_Req {
    // message fields
    pub session_id: ::std::vec::Vec<u8>,
    pub field_type: Transaction_Type,
    pub options: ::protobuf::SingularPtrField<super::options::Options>,
    pub network_latency_millis: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction_Open_Req {
    fn default() -> &'a Transaction_Open_Req {
        <Transaction_Open_Req as ::protobuf::Message>::default_instance()
    }
}

impl Transaction_Open_Req {
    pub fn new() -> Transaction_Open_Req {
        ::std::default::Default::default()
    }

    // bytes session_id = 1;


    pub fn get_session_id(&self) -> &[u8] {
        &self.session_id
    }
    pub fn clear_session_id(&mut self) {
        self.session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.session_id
    }

    // Take field
    pub fn take_session_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.session_id, ::std::vec::Vec::new())
    }

    // .typedb.protocol.Transaction.Type type = 2;


    pub fn get_field_type(&self) -> Transaction_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Transaction_Type::READ;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Transaction_Type) {
        self.field_type = v;
    }

    // .typedb.protocol.Options options = 3;


    pub fn get_options(&self) -> &super::options::Options {
        self.options.as_ref().unwrap_or_else(|| <super::options::Options as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: super::options::Options) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut super::options::Options {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> super::options::Options {
        self.options.take().unwrap_or_else(|| super::options::Options::new())
    }

    // int32 network_latency_millis = 4;


    pub fn get_network_latency_millis(&self) -> i32 {
        self.network_latency_millis
    }
    pub fn clear_network_latency_millis(&mut self) {
        self.network_latency_millis = 0;
    }

    // Param is passed by value, moved
    pub fn set_network_latency_millis(&mut self, v: i32) {
        self.network_latency_millis = v;
    }
}

impl ::protobuf::Message for Transaction_Open_Req {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.session_id)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.network_latency_millis = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.session_id);
        }
        if self.field_type != Transaction_Type::READ {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.network_latency_millis != 0 {
            my_size += ::protobuf::rt::value_size(4, self.network_latency_millis, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.session_id.is_empty() {
            os.write_bytes(1, &self.session_id)?;
        }
        if self.field_type != Transaction_Type::READ {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.network_latency_millis != 0 {
            os.write_int32(4, self.network_latency_millis)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction_Open_Req {
        Transaction_Open_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "session_id",
                |m: &Transaction_Open_Req| { &m.session_id },
                |m: &mut Transaction_Open_Req| { &mut m.session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Transaction_Type>>(
                "type",
                |m: &Transaction_Open_Req| { &m.field_type },
                |m: &mut Transaction_Open_Req| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::options::Options>>(
                "options",
                |m: &Transaction_Open_Req| { &m.options },
                |m: &mut Transaction_Open_Req| { &mut m.options },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "network_latency_millis",
                |m: &Transaction_Open_Req| { &m.network_latency_millis },
                |m: &mut Transaction_Open_Req| { &mut m.network_latency_millis },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction_Open_Req>(
                "Transaction.Open.Req",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction_Open_Req {
        static instance: ::protobuf::rt::LazyV2<Transaction_Open_Req> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction_Open_Req::new)
    }
}

impl ::protobuf::Clear for Transaction_Open_Req {
    fn clear(&mut self) {
        self.session_id.clear();
        self.field_type = Transaction_Type::READ;
        self.options.clear();
        self.network_latency_millis = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction_Open_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Open_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction_Open_Res {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction_Open_Res {
    fn default() -> &'a Transaction_Open_Res {
        <Transaction_Open_Res as ::protobuf::Message>::default_instance()
    }
}

impl Transaction_Open_Res {
    pub fn new() -> Transaction_Open_Res {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Transaction_Open_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction_Open_Res {
        Transaction_Open_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction_Open_Res>(
                "Transaction.Open.Res",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction_Open_Res {
        static instance: ::protobuf::rt::LazyV2<Transaction_Open_Res> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction_Open_Res::new)
    }
}

impl ::protobuf::Clear for Transaction_Open_Res {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction_Open_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Open_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction_Stream {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction_Stream {
    fn default() -> &'a Transaction_Stream {
        <Transaction_Stream as ::protobuf::Message>::default_instance()
    }
}

impl Transaction_Stream {
    pub fn new() -> Transaction_Stream {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Transaction_Stream {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction_Stream {
        Transaction_Stream::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction_Stream>(
                "Transaction.Stream",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction_Stream {
        static instance: ::protobuf::rt::LazyV2<Transaction_Stream> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction_Stream::new)
    }
}

impl ::protobuf::Clear for Transaction_Stream {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction_Stream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Stream {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction_Stream_Req {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction_Stream_Req {
    fn default() -> &'a Transaction_Stream_Req {
        <Transaction_Stream_Req as ::protobuf::Message>::default_instance()
    }
}

impl Transaction_Stream_Req {
    pub fn new() -> Transaction_Stream_Req {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Transaction_Stream_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction_Stream_Req {
        Transaction_Stream_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction_Stream_Req>(
                "Transaction.Stream.Req",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction_Stream_Req {
        static instance: ::protobuf::rt::LazyV2<Transaction_Stream_Req> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction_Stream_Req::new)
    }
}

impl ::protobuf::Clear for Transaction_Stream_Req {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction_Stream_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Stream_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction_Stream_ResPart {
    // message fields
    pub state: Transaction_Stream_State,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction_Stream_ResPart {
    fn default() -> &'a Transaction_Stream_ResPart {
        <Transaction_Stream_ResPart as ::protobuf::Message>::default_instance()
    }
}

impl Transaction_Stream_ResPart {
    pub fn new() -> Transaction_Stream_ResPart {
        ::std::default::Default::default()
    }

    // .typedb.protocol.Transaction.Stream.State state = 1;


    pub fn get_state(&self) -> Transaction_Stream_State {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = Transaction_Stream_State::CONTINUE;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: Transaction_Stream_State) {
        self.state = v;
    }
}

impl ::protobuf::Message for Transaction_Stream_ResPart {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.state != Transaction_Stream_State::CONTINUE {
            my_size += ::protobuf::rt::enum_size(1, self.state);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.state != Transaction_Stream_State::CONTINUE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction_Stream_ResPart {
        Transaction_Stream_ResPart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Transaction_Stream_State>>(
                "state",
                |m: &Transaction_Stream_ResPart| { &m.state },
                |m: &mut Transaction_Stream_ResPart| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction_Stream_ResPart>(
                "Transaction.Stream.ResPart",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction_Stream_ResPart {
        static instance: ::protobuf::rt::LazyV2<Transaction_Stream_ResPart> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction_Stream_ResPart::new)
    }
}

impl ::protobuf::Clear for Transaction_Stream_ResPart {
    fn clear(&mut self) {
        self.state = Transaction_Stream_State::CONTINUE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction_Stream_ResPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Stream_ResPart {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Transaction_Stream_State {
    CONTINUE = 0,
    DONE = 1,
}

impl ::protobuf::ProtobufEnum for Transaction_Stream_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Transaction_Stream_State> {
        match value {
            0 => ::std::option::Option::Some(Transaction_Stream_State::CONTINUE),
            1 => ::std::option::Option::Some(Transaction_Stream_State::DONE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Transaction_Stream_State] = &[
            Transaction_Stream_State::CONTINUE,
            Transaction_Stream_State::DONE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Transaction_Stream_State>("Transaction.Stream.State", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Transaction_Stream_State {
}

impl ::std::default::Default for Transaction_Stream_State {
    fn default() -> Self {
        Transaction_Stream_State::CONTINUE
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Stream_State {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction_Commit {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction_Commit {
    fn default() -> &'a Transaction_Commit {
        <Transaction_Commit as ::protobuf::Message>::default_instance()
    }
}

impl Transaction_Commit {
    pub fn new() -> Transaction_Commit {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Transaction_Commit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction_Commit {
        Transaction_Commit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction_Commit>(
                "Transaction.Commit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction_Commit {
        static instance: ::protobuf::rt::LazyV2<Transaction_Commit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction_Commit::new)
    }
}

impl ::protobuf::Clear for Transaction_Commit {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction_Commit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Commit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction_Commit_Req {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction_Commit_Req {
    fn default() -> &'a Transaction_Commit_Req {
        <Transaction_Commit_Req as ::protobuf::Message>::default_instance()
    }
}

impl Transaction_Commit_Req {
    pub fn new() -> Transaction_Commit_Req {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Transaction_Commit_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction_Commit_Req {
        Transaction_Commit_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction_Commit_Req>(
                "Transaction.Commit.Req",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction_Commit_Req {
        static instance: ::protobuf::rt::LazyV2<Transaction_Commit_Req> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction_Commit_Req::new)
    }
}

impl ::protobuf::Clear for Transaction_Commit_Req {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction_Commit_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Commit_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction_Commit_Res {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction_Commit_Res {
    fn default() -> &'a Transaction_Commit_Res {
        <Transaction_Commit_Res as ::protobuf::Message>::default_instance()
    }
}

impl Transaction_Commit_Res {
    pub fn new() -> Transaction_Commit_Res {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Transaction_Commit_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction_Commit_Res {
        Transaction_Commit_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction_Commit_Res>(
                "Transaction.Commit.Res",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction_Commit_Res {
        static instance: ::protobuf::rt::LazyV2<Transaction_Commit_Res> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction_Commit_Res::new)
    }
}

impl ::protobuf::Clear for Transaction_Commit_Res {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction_Commit_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Commit_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction_Rollback {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction_Rollback {
    fn default() -> &'a Transaction_Rollback {
        <Transaction_Rollback as ::protobuf::Message>::default_instance()
    }
}

impl Transaction_Rollback {
    pub fn new() -> Transaction_Rollback {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Transaction_Rollback {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction_Rollback {
        Transaction_Rollback::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction_Rollback>(
                "Transaction.Rollback",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction_Rollback {
        static instance: ::protobuf::rt::LazyV2<Transaction_Rollback> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction_Rollback::new)
    }
}

impl ::protobuf::Clear for Transaction_Rollback {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction_Rollback {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Rollback {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction_Rollback_Req {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction_Rollback_Req {
    fn default() -> &'a Transaction_Rollback_Req {
        <Transaction_Rollback_Req as ::protobuf::Message>::default_instance()
    }
}

impl Transaction_Rollback_Req {
    pub fn new() -> Transaction_Rollback_Req {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Transaction_Rollback_Req {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction_Rollback_Req {
        Transaction_Rollback_Req::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction_Rollback_Req>(
                "Transaction.Rollback.Req",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction_Rollback_Req {
        static instance: ::protobuf::rt::LazyV2<Transaction_Rollback_Req> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction_Rollback_Req::new)
    }
}

impl ::protobuf::Clear for Transaction_Rollback_Req {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction_Rollback_Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Rollback_Req {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction_Rollback_Res {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction_Rollback_Res {
    fn default() -> &'a Transaction_Rollback_Res {
        <Transaction_Rollback_Res as ::protobuf::Message>::default_instance()
    }
}

impl Transaction_Rollback_Res {
    pub fn new() -> Transaction_Rollback_Res {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Transaction_Rollback_Res {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction_Rollback_Res {
        Transaction_Rollback_Res::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction_Rollback_Res>(
                "Transaction.Rollback.Res",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction_Rollback_Res {
        static instance: ::protobuf::rt::LazyV2<Transaction_Rollback_Res> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction_Rollback_Res::new)
    }
}

impl ::protobuf::Clear for Transaction_Rollback_Res {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction_Rollback_Res {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Rollback_Res {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Transaction_Type {
    READ = 0,
    WRITE = 1,
}

impl ::protobuf::ProtobufEnum for Transaction_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Transaction_Type> {
        match value {
            0 => ::std::option::Option::Some(Transaction_Type::READ),
            1 => ::std::option::Option::Some(Transaction_Type::WRITE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Transaction_Type] = &[
            Transaction_Type::READ,
            Transaction_Type::WRITE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Transaction_Type>("Transaction.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Transaction_Type {
}

impl ::std::default::Default for Transaction_Type {
    fn default() -> Self {
        Transaction_Type::READ
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x18common/transaction.proto\x12\x0ftypedb.protocol\x1a\x14common/conc\
    ept.proto\x1a\x12common/logic.proto\x1a\x14common/options.proto\x1a\x12c\
    ommon/query.proto\"\xed\x14\n\x0bTransaction\x1a>\n\x06Client\x124\n\x04\
    reqs\x18\x01\x20\x03(\x0b2\x20.typedb.protocol.Transaction.ReqR\x04reqs\
    \x1a\x8b\x01\n\x06Server\x124\n\x03res\x18\x02\x20\x01(\x0b2\x20.typedb.\
    protocol.Transaction.ResH\0R\x03res\x12A\n\x08res_part\x18\x03\x20\x01(\
    \x0b2$.typedb.protocol.Transaction.ResPartH\0R\x07resPartB\x08\n\x06serv\
    er\x1a\xf8\x06\n\x03Req\x12\x15\n\x06req_id\x18\x01\x20\x01(\x0cR\x05req\
    Id\x12J\n\x08metadata\x18\x02\x20\x03(\x0b2..typedb.protocol.Transaction\
    .Req.MetadataEntryR\x08metadata\x12B\n\x08open_req\x18\x03\x20\x01(\x0b2\
    %.typedb.protocol.Transaction.Open.ReqH\0R\x07openReq\x12H\n\nstream_req\
    \x18\x04\x20\x01(\x0b2'.typedb.protocol.Transaction.Stream.ReqH\0R\tstre\
    amReq\x12H\n\ncommit_req\x18\x05\x20\x01(\x0b2'.typedb.protocol.Transact\
    ion.Commit.ReqH\0R\tcommitReq\x12N\n\x0crollback_req\x18\x06\x20\x01(\
    \x0b2).typedb.protocol.Transaction.Rollback.ReqH\0R\x0brollbackReq\x12O\
    \n\x11query_manager_req\x18\x07\x20\x01(\x0b2!.typedb.protocol.QueryMana\
    ger.ReqH\0R\x0fqueryManagerReq\x12U\n\x13concept_manager_req\x18\x08\x20\
    \x01(\x0b2#.typedb.protocol.ConceptManager.ReqH\0R\x11conceptManagerReq\
    \x12O\n\x11logic_manager_req\x18\t\x20\x01(\x0b2!.typedb.protocol.LogicM\
    anager.ReqH\0R\x0flogicManagerReq\x126\n\x08rule_req\x18\n\x20\x01(\x0b2\
    \x19.typedb.protocol.Rule.ReqH\0R\x07ruleReq\x126\n\x08type_req\x18\x0b\
    \x20\x01(\x0b2\x19.typedb.protocol.Type.ReqH\0R\x07typeReq\x129\n\tthing\
    _req\x18\x0c\x20\x01(\x0b2\x1a.typedb.protocol.Thing.ReqH\0R\x08thingReq\
    \x1a;\n\rMetadataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01B\x05\n\x03req\x1a\
    \xa5\x05\n\x03Res\x12\x15\n\x06req_id\x18\x01\x20\x01(\x0cR\x05reqId\x12\
    B\n\x08open_res\x18\x02\x20\x01(\x0b2%.typedb.protocol.Transaction.Open.\
    ResH\0R\x07openRes\x12H\n\ncommit_res\x18\x03\x20\x01(\x0b2'.typedb.prot\
    ocol.Transaction.Commit.ResH\0R\tcommitRes\x12N\n\x0crollback_res\x18\
    \x04\x20\x01(\x0b2).typedb.protocol.Transaction.Rollback.ResH\0R\x0broll\
    backRes\x12O\n\x11query_manager_res\x18\x05\x20\x01(\x0b2!.typedb.protoc\
    ol.QueryManager.ResH\0R\x0fqueryManagerRes\x12U\n\x13concept_manager_res\
    \x18\x06\x20\x01(\x0b2#.typedb.protocol.ConceptManager.ResH\0R\x11concep\
    tManagerRes\x12O\n\x11logic_manager_res\x18\x07\x20\x01(\x0b2!.typedb.pr\
    otocol.LogicManager.ResH\0R\x0flogicManagerRes\x126\n\x08rule_res\x18\
    \x08\x20\x01(\x0b2\x19.typedb.protocol.Rule.ResH\0R\x07ruleRes\x126\n\
    \x08type_res\x18\t\x20\x01(\x0b2\x19.typedb.protocol.Type.ResH\0R\x07typ\
    eRes\x129\n\tthing_res\x18\n\x20\x01(\x0b2\x1a.typedb.protocol.Thing.Res\
    H\0R\x08thingResB\x05\n\x03res\x1a\xc7\x03\n\x07ResPart\x12\x15\n\x06req\
    _id\x18\x01\x20\x01(\x0cR\x05reqId\x12U\n\x0fstream_res_part\x18\x02\x20\
    \x01(\x0b2+.typedb.protocol.Transaction.Stream.ResPartH\0R\rstreamResPar\
    t\x12\\\n\x16query_manager_res_part\x18\x03\x20\x01(\x0b2%.typedb.protoc\
    ol.QueryManager.ResPartH\0R\x13queryManagerResPart\x12\\\n\x16logic_mana\
    ger_res_part\x18\x04\x20\x01(\x0b2%.typedb.protocol.LogicManager.ResPart\
    H\0R\x13logicManagerResPart\x12C\n\rtype_res_part\x18\x05\x20\x01(\x0b2\
    \x1d.typedb.protocol.Type.ResPartH\0R\x0btypeResPart\x12F\n\x0ething_res\
    _part\x18\x06\x20\x01(\x0b2\x1e.typedb.protocol.Thing.ResPartH\0R\x0cthi\
    ngResPartB\x05\n\x03res\x1a\xd5\x01\n\x04Open\x1a\xc5\x01\n\x03Req\x12\
    \x1d\n\nsession_id\x18\x01\x20\x01(\x0cR\tsessionId\x125\n\x04type\x18\
    \x02\x20\x01(\x0e2!.typedb.protocol.Transaction.TypeR\x04type\x122\n\x07\
    options\x18\x03\x20\x01(\x0b2\x18.typedb.protocol.OptionsR\x07options\
    \x124\n\x16network_latency_millis\x18\x04\x20\x01(\x05R\x14networkLatenc\
    yMillis\x1a\x05\n\x03Res\x1a|\n\x06Stream\x1a\x05\n\x03Req\x1aJ\n\x07Res\
    Part\x12?\n\x05state\x18\x01\x20\x01(\x0e2).typedb.protocol.Transaction.\
    Stream.StateR\x05state\"\x1f\n\x05State\x12\x0c\n\x08CONTINUE\x10\0\x12\
    \x08\n\x04DONE\x10\x01\x1a\x16\n\x06Commit\x1a\x05\n\x03Req\x1a\x05\n\
    \x03Res\x1a\x18\n\x08Rollback\x1a\x05\n\x03Req\x1a\x05\n\x03Res\"\x1b\n\
    \x04Type\x12\x08\n\x04READ\x10\0\x12\t\n\x05WRITE\x10\x01B/\n\x1bcom.vat\
    icle.typedb.protocolB\x10TransactionProtob\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
